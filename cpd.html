<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 from org.apache.maven.plugins:maven-pmd-plugin:3.15.0:aggregate-cpd at 2022-02-14
 | Rendered using Apache Maven Fluido Skin 1.10.0
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <title>waffle-parent &#x2013; CPD Results</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.10.0.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-1.10.0.min.js"></script>
  </head>
  <body class="topBarEnabled">
    <header id="topbar" class="navbar navbar-fixed-top ">
      <div class="navbar-inner">
        <div class="container-fluid">
        <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
            <ul class="nav">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">User guide <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="README.html" title="README">README</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Project Documentation <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li class="dropdown-submenu">
<a href="project-info.html" title="Project Information">Project Information</a>
              <ul class="dropdown-menu">
                  <li><a href="ci-management.html" title="CI Management">CI Management</a></li>
                  <li><a href="dependencies.html" title="Dependencies">Dependencies</a></li>
                  <li><a href="dependency-convergence.html" title="Dependency Convergence">Dependency Convergence</a></li>
                  <li><a href="dependency-info.html" title="Dependency Information">Dependency Information</a></li>
                  <li><a href="distribution-management.html" title="Distribution Management">Distribution Management</a></li>
                  <li><a href="index.html" title="About">About</a></li>
                  <li><a href="issue-management.html" title="Issue Management">Issue Management</a></li>
                  <li><a href="licenses.html" title="Licenses">Licenses</a></li>
                  <li><a href="modules.html" title="Project Modules">Project Modules</a></li>
                  <li><a href="plugin-management.html" title="Plugin Management">Plugin Management</a></li>
                  <li><a href="plugins.html" title="Plugins">Plugins</a></li>
                  <li><a href="scm.html" title="Source Code Management">Source Code Management</a></li>
                  <li><a href="summary.html" title="Summary">Summary</a></li>
                  <li><a href="team.html" title="Team">Team</a></li>
              </ul>
            </li>
            <li class="dropdown-submenu">
<a href="project-reports.html" title="Project Reports">Project Reports</a>
              <ul class="dropdown-menu">
                  <li><a href="changelog.html" title="Change Log">Change Log</a></li>
                  <li><a href="file-activity.html" title="File Activity">File Activity</a></li>
                  <li><a href="dev-activity.html" title="Developer Activity">Developer Activity</a></li>
                  <li><a href="github-report.html" title="GitHub Report">GitHub Report</a></li>
                  <li><a href="checkstyle-aggregate.html" title="Checkstyle">Checkstyle</a></li>
                  <li><a href="apidocs/index.html" title="Javadoc">Javadoc</a></li>
                  <li><a href="testapidocs/index.html" title="Test Javadoc">Test Javadoc</a></li>
                  <li><a href="xref/index.html" title="Source Xref">Source Xref</a></li>
                  <li><a href="xref-test/index.html" title="Test Source Xref">Test Source Xref</a></li>
                  <li><a href="cpd.html" title="CPD">CPD</a></li>
                  <li><a href="pmd.html" title="PMD">PMD</a></li>
                  <li><a href="surefire-report.html" title="Surefire Report">Surefire Report</a></li>
                  <li><a href="jacoco-aggregate/index.html" title="JaCoCo Aggregate">JaCoCo Aggregate</a></li>
                  <li><a href="dependency-updates-report.html" title="Dependency Updates Report">Dependency Updates Report</a></li>
                  <li><a href="plugin-updates-report.html" title="Plugin Updates Report">Plugin Updates Report</a></li>
                  <li><a href="property-updates-report.html" title="Property Updates Report">Property Updates Report</a></li>
                  <li><a href="dependency-check-report.html" title="dependency-check:aggregate">dependency-check:aggregate</a></li>
              </ul>
            </li>
        </ul>
      </li>
            </ul>
            <ul class="nav pull-right">
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown">External Links <b class="caret"></b></a>
                <ul class="dropdown-menu">
    <li><a href="https://github.com/Waffle/waffle" title="waffle">waffle</a></li>
                </ul>
              </li>
            </ul>
        </div>
      </div>
    </header>
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left"><a href="https://github.com/Waffle/waffle" id="bannerLeft"><img src="images/waffle.jpg"  alt=""/></a></div>
          <div class="pull-right"><a href="https://github.com/Waffle/waffle" id="bannerRight"><img src="images/waffle.jpg"  alt=""/></a></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2022-02-14<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 3.1.2-SNAPSHOT</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">User guide</li>
    <li><a href="README.html" title="README"><span class="none"></span>README</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="project-reports.html" title="Project Reports"><span class="icon-chevron-down"></span>Project Reports</a>
     <ul class="nav nav-list">
      <li><a href="changelog.html" title="Change Log"><span class="none"></span>Change Log</a></li>
      <li><a href="file-activity.html" title="File Activity"><span class="none"></span>File Activity</a></li>
      <li><a href="dev-activity.html" title="Developer Activity"><span class="none"></span>Developer Activity</a></li>
      <li><a href="github-report.html" title="GitHub Report"><span class="none"></span>GitHub Report</a></li>
      <li><a href="checkstyle-aggregate.html" title="Checkstyle"><span class="none"></span>Checkstyle</a></li>
      <li><a href="apidocs/index.html" title="Javadoc"><span class="none"></span>Javadoc</a></li>
      <li><a href="testapidocs/index.html" title="Test Javadoc"><span class="none"></span>Test Javadoc</a></li>
      <li><a href="xref/index.html" title="Source Xref"><span class="none"></span>Source Xref</a></li>
      <li><a href="xref-test/index.html" title="Test Source Xref"><span class="none"></span>Test Source Xref</a></li>
      <li class="active"><a href="#"><span class="none"></span>CPD</a></li>
      <li><a href="pmd.html" title="PMD"><span class="none"></span>PMD</a></li>
      <li><a href="surefire-report.html" title="Surefire Report"><span class="none"></span>Surefire Report</a></li>
      <li><a href="jacoco-aggregate/index.html" title="JaCoCo Aggregate"><span class="none"></span>JaCoCo Aggregate</a></li>
      <li><a href="dependency-updates-report.html" title="Dependency Updates Report"><span class="none"></span>Dependency Updates Report</a></li>
      <li><a href="plugin-updates-report.html" title="Plugin Updates Report"><span class="none"></span>Plugin Updates Report</a></li>
      <li><a href="property-updates-report.html" title="Property Updates Report"><span class="none"></span>Property Updates Report</a></li>
      <li><a href="dependency-check-report.html" title="dependency-check:aggregate"><span class="none"></span>dependency-check:aggregate</a></li>
     </ul></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <hr />
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >
<section>
<h2><a name="CPD_Results"></a>CPD Results</h2>
<p>The following document contains the results of PMD's  <a class="externalLink" href="https://pmd.github.io/latest/pmd_userdocs_cpd.html">CPD</a> 6.38.0.</p></section><section>
<h2><a name="Duplications"></a>Duplications</h2>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/servlet/NegotiateSecurityFilter.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/servlet/NegotiateSecurityFilter.html#L65">65</a></td></tr>
<tr class="a">
<td>waffle/servlet/NegotiateSecurityFilter.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/servlet/NegotiateSecurityFilter.html#L64">64</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class NegotiateSecurityFilter implements Filter {

    /** The Constant LOGGER. */
    private static final Logger LOGGER = LoggerFactory.getLogger(NegotiateSecurityFilter.class);

    /** The Constant PRINCIPALSESSIONKEY. */
    private static final String PRINCIPALSESSIONKEY = NegotiateSecurityFilter.class.getName() + &quot;.PRINCIPAL&quot;;

    /** The windows flag. */
    private static Boolean windows;

    /** The principal format. */
    private PrincipalFormat principalFormat = PrincipalFormat.FQN;

    /** The role format. */
    private PrincipalFormat roleFormat = PrincipalFormat.FQN;

    /** The providers. */
    private SecurityFilterProviderCollection providers;

    /** The auth. */
    private IWindowsAuthProvider auth;

    /** The exclusion filter. */
    private String[] excludePatterns;

    /** The allow guest login. */
    private boolean allowGuestLogin = true;

    /** The impersonate. */
    private boolean impersonate;

    /** The exclusion bearer authorization. */
    private boolean excludeBearerAuthorization;

    /** The exclusions cors pre flight. */
    private boolean excludeCorsPreflight;

    /** The disable SSO. */
    private boolean disableSSO;

    /**
     * Instantiates a new negotiate security filter.
     */
    public NegotiateSecurityFilter() {
        NegotiateSecurityFilter.LOGGER.debug(&quot;[waffle.servlet.NegotiateSecurityFilter] loaded&quot;);
    }

    @Override
    public void destroy() {
        NegotiateSecurityFilter.LOGGER.info(&quot;[waffle.servlet.NegotiateSecurityFilter] stopped&quot;);
    }

    @Override
    public void doFilter(final ServletRequest sreq, final ServletResponse sres, final FilterChain chain)
            throws IOException, ServletException {

        final HttpServletRequest request = (HttpServletRequest) sreq;
        final HttpServletResponse response = (HttpServletResponse) sres;

        NegotiateSecurityFilter.LOGGER.debug(&quot;{} {}, contentlength: {}&quot;, request.getMethod(), request.getRequestURI(),
                Integer.valueOf(request.getContentLength()));

        // If we are not in a windows environment, resume filter chain
        if (!NegotiateSecurityFilter.isWindows()) {
            NegotiateSecurityFilter.LOGGER.debug(&quot;Running in a non windows environment, SSO skipped&quot;);
            chain.doFilter(request, response);
            return;
        }

        // If sso is disabled, resume filter chain
        if (this.disableSSO) {
            NegotiateSecurityFilter.LOGGER.debug(&quot;SSO is disabled, resuming filter chain&quot;);
            chain.doFilter(request, response);
            return;
        }

        // If excluded URL, resume the filter chain
        if (request.getRequestURL() != null &amp;&amp; this.excludePatterns != null) {
            final String url = request.getRequestURL().toString();
            for (final String pattern : this.excludePatterns) {
                if (url.matches(pattern)) {
                    NegotiateSecurityFilter.LOGGER.info(&quot;Pattern :{} excluded URL:{}&quot;, url, pattern);
                    chain.doFilter(sreq, sres);
                    return;
                }
            }
        }

        // If exclude cores pre-flight and is pre flight, resume the filter chain
        if (this.excludeCorsPreflight &amp;&amp; CorsPreFlightCheck.isPreflight(request)) {
            NegotiateSecurityFilter.LOGGER.debug(&quot;[waffle.servlet.NegotiateSecurityFilter] CORS preflight&quot;);
            chain.doFilter(sreq, sres);
            return;
        }

        final AuthorizationHeader authorizationHeader = new AuthorizationHeader(request);

        // If exclude bearer authorization and is bearer authorization, result the filter chain
        if (this.excludeBearerAuthorization &amp;&amp; authorizationHeader.isBearerAuthorizationHeader()) {
            NegotiateSecurityFilter.LOGGER.debug(&quot;[waffle.servlet.NegotiateSecurityFilter] Authorization: Bearer&quot;);
            chain.doFilter(sreq, sres);
            return;
        }

        if (this.doFilterPrincipal(request, response, chain)) {
            // previously authenticated user
            return;
        }

        // authenticate user
        if (!authorizationHeader.isNull()) {

            // log the user in using the token
            IWindowsIdentity windowsIdentity;
            try {
                windowsIdentity = this.providers.doFilter(request, response);
                if (windowsIdentity == null) {
                    return;
                }
            } catch (final IOException e) {
                NegotiateSecurityFilter.LOGGER.warn(&quot;error logging in user: {}&quot;, e.getMessage());
                NegotiateSecurityFilter.LOGGER.trace(&quot;&quot;, e);
                this.sendUnauthorized(response, true);
                return;
            }

            IWindowsImpersonationContext ctx = null;
            try {
                if (!this.allowGuestLogin &amp;&amp; windowsIdentity.isGuest()) {
                    NegotiateSecurityFilter.LOGGER.warn(&quot;guest login disabled: {}&quot;, windowsIdentity.getFqn());
                    this.sendUnauthorized(response, true);
                    return;
                }

                NegotiateSecurityFilter.LOGGER.debug(&quot;logged in user: {} ({})&quot;, windowsIdentity.getFqn(),
                        windowsIdentity.getSidString());

                final HttpSession session = request.getSession(true);
                if (session == null) {
                    throw new ServletException(&quot;Expected HttpSession&quot;);
                }

                Subject subject = (Subject) session.getAttribute(&quot;javax.security.auth.subject&quot;);
                if (subject == null) {
                    subject = new Subject();
                }

                WindowsPrincipal windowsPrincipal;
                if (this.impersonate) {
                    windowsPrincipal = new AutoDisposableWindowsPrincipal(windowsIdentity, this.principalFormat,
                            this.roleFormat);
                } else {
                    windowsPrincipal = new WindowsPrincipal(windowsIdentity, this.principalFormat, this.roleFormat);
                }

                NegotiateSecurityFilter.LOGGER.debug(&quot;roles: {}&quot;, windowsPrincipal.getRolesString());
                subject.getPrincipals().add(windowsPrincipal);
                request.getSession(false).setAttribute(&quot;javax.security.auth.subject&quot;, subject);

                NegotiateSecurityFilter.LOGGER.info(&quot;successfully logged in user: {}&quot;, windowsIdentity.getFqn());

                request.getSession(false).setAttribute(NegotiateSecurityFilter.PRINCIPALSESSIONKEY, windowsPrincipal);

                final NegotiateRequestWrapper requestWrapper = new NegotiateRequestWrapper(request, windowsPrincipal);

                if (this.impersonate) {
                    NegotiateSecurityFilter.LOGGER.debug(&quot;impersonating user&quot;);
                    ctx = windowsIdentity.impersonate();
                }

                chain.doFilter(requestWrapper, response);
            } finally {
                if (this.impersonate &amp;&amp; ctx != null) {
                    NegotiateSecurityFilter.LOGGER.debug(&quot;terminating impersonation&quot;);
                    ctx.revertToSelf();
                } else {
                    windowsIdentity.dispose();
                }
            }

            return;
        }

        NegotiateSecurityFilter.LOGGER.debug(&quot;authorization required&quot;);
        this.sendUnauthorized(response, false);
    }

    /**
     * Filter for a previously logged on user.
     *
     * @param request
     *            HTTP request.
     * @param response
     *            HTTP response.
     * @param chain
     *            Filter chain.
     * @return True if a user already authenticated.
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     * @throws ServletException
     *             the servlet exception
     */
    private boolean doFilterPrincipal(final HttpServletRequest request, final HttpServletResponse response,
            final FilterChain chain) throws IOException, ServletException {
        Principal principal = request.getUserPrincipal();
        if (principal == null) {
            final HttpSession session = request.getSession(false);
            if (session != null) {
                principal = (Principal) session.getAttribute(NegotiateSecurityFilter.PRINCIPALSESSIONKEY);
            }
        }

        if (principal == null) {
            // no principal in this request
            return false;
        }

        if (this.providers.isPrincipalException(request)) {
            // the providers signal to authenticate despite an existing principal, eg. NTLM post
            return false;
        }

        // user already authenticated
        if (principal instanceof WindowsPrincipal) {
            NegotiateSecurityFilter.LOGGER.debug(&quot;previously authenticated Windows user: {}&quot;, principal.getName());
            final WindowsPrincipal windowsPrincipal = (WindowsPrincipal) principal;

            if (this.impersonate &amp;&amp; windowsPrincipal.getIdentity() == null) {
                // This can happen when the session has been serialized then de-serialized
                // and because the IWindowsIdentity field is transient. In this case re-ask an
                // authentication to get a new identity.
                return false;
            }

            final NegotiateRequestWrapper requestWrapper = new NegotiateRequestWrapper(request, windowsPrincipal);

            IWindowsImpersonationContext ctx = null;
            if (this.impersonate) {
                NegotiateSecurityFilter.LOGGER.debug(&quot;re-impersonating user&quot;);
                ctx = windowsPrincipal.getIdentity().impersonate();
            }
            try {
                chain.doFilter(requestWrapper, response);
            } finally {
                if (this.impersonate &amp;&amp; ctx != null) {
                    NegotiateSecurityFilter.LOGGER.debug(&quot;terminating impersonation&quot;);
                    ctx.revertToSelf();
                }
            }
        } else {
            NegotiateSecurityFilter.LOGGER.debug(&quot;previously authenticated user: {}&quot;, principal.getName());
            chain.doFilter(request, response);
        }
        return true;
    }

    @Override
    public void init(final FilterConfig filterConfig) throws ServletException {
        final Map&lt;String, String&gt; implParameters = new HashMap&lt;&gt;();

        NegotiateSecurityFilter.LOGGER.debug(&quot;[waffle.servlet.NegotiateSecurityFilter] starting&quot;);

        String authProvider = null;
        String[] providerNames = null;
        if (filterConfig != null) {
            final List&lt;String&gt; parameterNames = Collections.list(filterConfig.getInitParameterNames());
            NegotiateSecurityFilter.LOGGER.debug(&quot;[waffle.servlet.NegotiateSecurityFilter] processing filterConfig&quot;);
            for (String parameterName : parameterNames) {
                final String parameterValue = filterConfig.getInitParameter(parameterName);
                NegotiateSecurityFilter.LOGGER.debug(&quot;Init Param: '{}={}'&quot;, parameterName, parameterValue);
                switch (parameterName) {
                    case &quot;principalFormat&quot;:
                        this.principalFormat = PrincipalFormat.valueOf(parameterValue.toUpperCase(Locale.ENGLISH));
                        break;
                    case &quot;roleFormat&quot;:
                        this.roleFormat = PrincipalFormat.valueOf(parameterValue.toUpperCase(Locale.ENGLISH));
                        break;
                    case &quot;allowGuestLogin&quot;:
                        this.allowGuestLogin = Boolean.parseBoolean(parameterValue);
                        break;
                    case &quot;impersonate&quot;:
                        this.impersonate = Boolean.parseBoolean(parameterValue);
                        break;
                    case &quot;securityFilterProviders&quot;:
                        providerNames = parameterValue.split(&quot;\\s+&quot;, -1);
                        break;
                    case &quot;authProvider&quot;:
                        authProvider = parameterValue;
                        break;
                    case &quot;excludePatterns&quot;:
                        this.excludePatterns = parameterValue.split(&quot;\\s+&quot;, -1);
                        break;
                    case &quot;excludeCorsPreflight&quot;:
                        this.excludeCorsPreflight = Boolean.parseBoolean(parameterValue);
                        break;
                    case &quot;excludeBearerAuthorization&quot;:
                        this.excludeBearerAuthorization = Boolean.parseBoolean(parameterValue);
                        break;
                    case &quot;disableSSO&quot;:
                        this.disableSSO = Boolean.parseBoolean(parameterValue);
                        break;
                    default:
                        implParameters.put(parameterName, parameterValue);
                        break;
                }
            }
        }

        NegotiateSecurityFilter.LOGGER.debug(&quot;[waffle.servlet.NegotiateSecurityFilter] authProvider&quot;);
        if (authProvider != null) {
            try {
                this.auth = (IWindowsAuthProvider) Class.forName(authProvider).getConstructor().newInstance();
            } catch (final ClassNotFoundException | IllegalArgumentException | SecurityException
                    | InstantiationException | IllegalAccessException | InvocationTargetException
                    | NoSuchMethodException e) {
                NegotiateSecurityFilter.LOGGER.error(&quot;error loading '{}': {}&quot;, authProvider, e.getMessage());
                NegotiateSecurityFilter.LOGGER.trace(&quot;&quot;, e);
                throw new ServletException(e);
            }
        }

        if (this.auth == null) {
            this.auth = new WindowsAuthProviderImpl();
        }

        if (providerNames != null) {
            this.providers = new SecurityFilterProviderCollection(providerNames, this.auth);
        }

        // create default providers if none specified
        if (this.providers == null) {
            NegotiateSecurityFilter.LOGGER.debug(&quot;initializing default security filter providers&quot;);
            this.providers = new SecurityFilterProviderCollection(this.auth);
        }

        // apply provider implementation parameters
        NegotiateSecurityFilter.LOGGER.debug(&quot;[waffle.servlet.NegotiateSecurityFilter] load provider parameters&quot;);
        for (final Map.Entry&lt;String, String&gt; implParameter : implParameters.entrySet()) {
            final String[] classAndParameter = implParameter.getKey().split(&quot;/&quot;, 2);
            if (classAndParameter.length == 2) {
                try {

                    NegotiateSecurityFilter.LOGGER.debug(&quot;setting {}, {}={}&quot;, classAndParameter[0],
                            classAndParameter[1], implParameter.getValue());

                    final SecurityFilterProvider provider = this.providers.getByClassName(classAndParameter[0]);
                    provider.initParameter(classAndParameter[1], implParameter.getValue());

                } catch (final ClassNotFoundException e) {
                    NegotiateSecurityFilter.LOGGER.error(&quot;invalid class: {} in {}&quot;, classAndParameter[0],
                            implParameter.getKey());
                    throw new ServletException(e);
                } catch (final Exception e) {
                    NegotiateSecurityFilter.LOGGER.error(&quot;{}: error setting '{}': {}&quot;, classAndParameter[0],
                            classAndParameter[1], e.getMessage());
                    NegotiateSecurityFilter.LOGGER.trace(&quot;&quot;, e);
                    throw new ServletException(e);
                }
            } else {
                NegotiateSecurityFilter.LOGGER.error(&quot;Invalid parameter: {}&quot;, implParameter.getKey());
                throw new ServletException(&quot;Invalid parameter: &quot; + implParameter.getKey());
            }
        }

        NegotiateSecurityFilter.LOGGER.info(&quot;[waffle.servlet.NegotiateSecurityFilter] started&quot;);
    }

    /**
     * Set the principal format.
     *
     * @param format
     *            Principal format.
     */
    public void setPrincipalFormat(final String format) {
        this.principalFormat = PrincipalFormat.valueOf(format.toUpperCase(Locale.ENGLISH));
        NegotiateSecurityFilter.LOGGER.info(&quot;principal format: {}&quot;, this.principalFormat);
    }

    /**
     * Principal format.
     *
     * @return Principal format.
     */
    public PrincipalFormat getPrincipalFormat() {
        return this.principalFormat;
    }

    /**
     * Set the principal format.
     *
     * @param format
     *            Role format.
     */
    public void setRoleFormat(final String format) {
        this.roleFormat = PrincipalFormat.valueOf(format.toUpperCase(Locale.ENGLISH));
        NegotiateSecurityFilter.LOGGER.info(&quot;role format: {}&quot;, this.roleFormat);
    }

    /**
     * Principal format.
     *
     * @return Role format.
     */
    public PrincipalFormat getRoleFormat() {
        return this.roleFormat;
    }

    /**
     * Send a 401 Unauthorized along with protocol authentication headers.
     *
     * @param response
     *            HTTP Response
     * @param close
     *            Close connection.
     */
    private void sendUnauthorized(final HttpServletResponse response, final boolean close) {
        try {
            this.providers.sendUnauthorized(response);
            if (close) {
                response.setHeader(&quot;Connection&quot;, &quot;close&quot;);
            } else {
                response.setHeader(&quot;Connection&quot;, &quot;keep-alive&quot;);
            }
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
            response.flushBuffer();
        } catch (final IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Windows auth provider.
     *
     * @return IWindowsAuthProvider.
     */
    public IWindowsAuthProvider getAuth() {
        return this.auth;
    }

    /**
     * Set Windows auth provider.
     *
     * @param provider
     *            Class implements IWindowsAuthProvider.
     */
    public void setAuth(final IWindowsAuthProvider provider) {
        this.auth = provider;
    }

    /**
     * True if guest login is allowed.
     *
     * @return True if guest login is allowed, false otherwise.
     */
    public boolean isAllowGuestLogin() {
        return this.allowGuestLogin;
    }

    /**
     * Enable/Disable impersonation.
     *
     * @param value
     *            true to enable impersonation, false otherwise
     */
    public void setImpersonate(final boolean value) {
        this.impersonate = value;
    }

    /**
     * Checks if is impersonate.
     *
     * @return true if impersonation is enabled, false otherwise
     */
    public boolean isImpersonate() {
        return this.impersonate;
    }

    /**
     * Security filter providers.
     *
     * @return A collection of security filter providers.
     */
    public SecurityFilterProviderCollection getProviders() {
        return this.providers;
    }

    private static boolean isWindows() {
        if (NegotiateSecurityFilter.windows == null) {
            NegotiateSecurityFilter.windows = System.getProperty(&quot;os.name&quot;).toLowerCase(Locale.ENGLISH).contains(&quot;win&quot;);
        }
        return NegotiateSecurityFilter.windows.booleanValue();
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat10</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L54">54</a></td></tr>
<tr class="a">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat85</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L54">54</a></td></tr>
<tr class="b">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat9</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L54">54</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>public class MixedAuthenticator extends WaffleAuthenticatorBase {

    /**
     * Instantiates a new mixed authenticator.
     */
    public MixedAuthenticator() {
        super();
        this.log = LoggerFactory.getLogger(MixedAuthenticator.class);
        this.info = &quot;waffle.apache.MixedAuthenticator/1.0&quot;;
        this.log.debug(&quot;[waffle.apache.MixedAuthenticator] loaded&quot;);
    }

    @Override
    public synchronized void startInternal() throws LifecycleException {
        this.log.info(&quot;[waffle.apache.MixedAuthenticator] started&quot;);
        super.startInternal();
    }

    @Override
    public synchronized void stopInternal() throws LifecycleException {
        super.stopInternal();
        this.log.info(&quot;[waffle.apache.MixedAuthenticator] stopped&quot;);
    }

    @Override
    public boolean authenticate(final Request request, final HttpServletResponse response) {

        // realm: fail if no realm is configured
        if (this.context == null || this.context.getRealm() == null) {
            this.log.warn(&quot;missing context/realm&quot;);
            this.sendError(response, HttpServletResponse.SC_SERVICE_UNAVAILABLE);
            return false;
        }

        this.log.debug(&quot;{} {}, contentlength: {}&quot;, request.getMethod(), request.getRequestURI(),
                Integer.valueOf(request.getContentLength()));

        final boolean negotiateCheck = request.getParameter(&quot;j_negotiate_check&quot;) != null;
        this.log.debug(&quot;negotiateCheck: {}&quot;, Boolean.valueOf(negotiateCheck));
        final boolean securityCheck = request.getParameter(&quot;j_security_check&quot;) != null;
        this.log.debug(&quot;securityCheck: {}&quot;, Boolean.valueOf(securityCheck));

        final Principal principal = request.getUserPrincipal();

        final AuthorizationHeader authorizationHeader = new AuthorizationHeader(request);
        final boolean ntlmPost = authorizationHeader.isNtlmType1PostAuthorizationHeader();
        this.log.debug(&quot;authorization: {}, ntlm post: {}&quot;, authorizationHeader, Boolean.valueOf(ntlmPost));

        final LoginConfig loginConfig = this.context.getLoginConfig();

        if (principal != null &amp;&amp; !ntlmPost) {
            this.log.debug(&quot;previously authenticated user: {}&quot;, principal.getName());
            return true;
        } else if (negotiateCheck) {
            if (!authorizationHeader.isNull()) {
                boolean negotiateResult = this.negotiate(request, response, authorizationHeader);
                if (!negotiateResult) {
                    this.redirectTo(request, response, loginConfig.getErrorPage());
                }
                return negotiateResult;
            }
            this.log.debug(&quot;authorization required&quot;);
            this.sendUnauthorized(response);
            return false;
        } else if (securityCheck) {
            final boolean postResult = this.post(request, response);
            if (!postResult) {
                this.redirectTo(request, response, loginConfig.getErrorPage());
            }
            return postResult;
        } else {
            this.redirectTo(request, response, loginConfig.getLoginPage());
            return false;
        }
    }

    /**
     * Negotiate.
     *
     * @param request
     *            the request
     * @param response
     *            the response
     * @param authorizationHeader
     *            the authorization header
     * @return true, if successful
     */
    private boolean negotiate(final Request request, final HttpServletResponse response,
            final AuthorizationHeader authorizationHeader) {

        final String securityPackage = authorizationHeader.getSecurityPackage();
        // maintain a connection-based session for NTLM tokens
        final String connectionId = NtlmServletRequest.getConnectionId(request);

        this.log.debug(&quot;security package: {}, connection id: {}&quot;, securityPackage, connectionId);

        final boolean ntlmPost = authorizationHeader.isNtlmType1PostAuthorizationHeader();

        if (ntlmPost) {
            // type 1 NTLM authentication message received
            this.auth.resetSecurityToken(connectionId);
        }

        final byte[] tokenBuffer = authorizationHeader.getTokenBytes();
        this.log.debug(&quot;token buffer: {} byte(s)&quot;, Integer.valueOf(tokenBuffer.length));

        // log the user in using the token
        IWindowsSecurityContext securityContext;
        try {
            securityContext = this.auth.acceptSecurityToken(connectionId, tokenBuffer, securityPackage);
        } catch (final Win32Exception e) {
            this.log.warn(&quot;error logging in user: {}&quot;, e.getMessage());
            this.log.trace(&quot;&quot;, e);
            this.sendUnauthorized(response);
            return false;
        }
        this.log.debug(&quot;continue required: {}&quot;, Boolean.valueOf(securityContext.isContinue()));

        final byte[] continueTokenBytes = securityContext.getToken();
        if (continueTokenBytes != null &amp;&amp; continueTokenBytes.length &gt; 0) {
            final String continueToken = Base64.getEncoder().encodeToString(continueTokenBytes);
            this.log.debug(&quot;continue token: {}&quot;, continueToken);
            response.addHeader(&quot;WWW-Authenticate&quot;, securityPackage + &quot; &quot; + continueToken);
        }

        try {
            if (securityContext.isContinue() || ntlmPost) {
                response.setHeader(&quot;Connection&quot;, &quot;keep-alive&quot;);
                response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
                response.flushBuffer();
                return false;
            }
        } catch (final IOException e) {
            this.log.warn(&quot;error logging in user: {}&quot;, e.getMessage());
            this.log.trace(&quot;&quot;, e);
            this.sendUnauthorized(response);
            return false;
        }

        // create and register the user principal with the session
        final IWindowsIdentity windowsIdentity = securityContext.getIdentity();

        // disable guest login
        if (!this.allowGuestLogin &amp;&amp; windowsIdentity.isGuest()) {
            this.log.warn(&quot;guest login disabled: {}&quot;, windowsIdentity.getFqn());
            this.sendUnauthorized(response);
            return false;
        }

        try {

            this.log.debug(&quot;logged in user: {} ({})&quot;, windowsIdentity.getFqn(), windowsIdentity.getSidString());

            final GenericPrincipal genericPrincipal = this.createPrincipal(windowsIdentity);

            this.log.debug(&quot;roles: {}&quot;, String.join(&quot;, &quot;, genericPrincipal.getRoles()));

            // create a session associated with this request if there's none
            final HttpSession session = request.getSession(true);
            this.log.debug(&quot;session id: {}&quot;, session == null ? &quot;null&quot; : session.getId());

            this.register(request, response, genericPrincipal, securityPackage, genericPrincipal.getName(), null);
            this.log.info(&quot;successfully logged in user: {}&quot;, genericPrincipal.getName());

        } finally {
            windowsIdentity.dispose();
        }

        return true;
    }

    /**
     * Post.
     *
     * @param request
     *            the request
     * @param response
     *            the response
     * @return true, if successful
     */
    private boolean post(final Request request, final HttpServletResponse response) {

        final String username = request.getParameter(&quot;j_username&quot;);
        final String password = request.getParameter(&quot;j_password&quot;);

        this.log.debug(&quot;logging in: {}&quot;, username);

        IWindowsIdentity windowsIdentity;
        try {
            windowsIdentity = this.auth.logonUser(username, password);
        } catch (final Exception e) {
            this.log.error(e.getMessage());
            this.log.trace(&quot;&quot;, e);
            return false;
        }

        // disable guest login
        if (!this.allowGuestLogin &amp;&amp; windowsIdentity.isGuest()) {
            this.log.warn(&quot;guest login disabled: {}&quot;, windowsIdentity.getFqn());
            return false;
        }

        try {
            this.log.debug(&quot;successfully logged in {} ({})&quot;, username, windowsIdentity.getSidString());

            final GenericPrincipal genericPrincipal = this.createPrincipal(windowsIdentity);

            this.log.debug(&quot;roles: {}&quot;, String.join(&quot;, &quot;, genericPrincipal.getRoles()));
            // create a session associated with this request if there's none
            final HttpSession session = request.getSession(true);
            this.log.debug(&quot;session id: {}&quot;, session == null ? &quot;null&quot; : session.getId());

            this.register(request, response, genericPrincipal, &quot;FORM&quot;, genericPrincipal.getName(), null);
            this.log.info(&quot;successfully logged in user: {}&quot;, genericPrincipal.getName());
        } finally {
            windowsIdentity.dispose();
        }

        return true;
    }

    /**
     * Redirect to.
     *
     * @param request
     *            the request
     * @param response
     *            the response
     * @param url
     *            the url
     */
    private void redirectTo(final Request request, final HttpServletResponse response, final String url) {
        try {
            this.log.debug(&quot;redirecting to: {}&quot;, url);
            final ServletContext servletContext = this.context.getServletContext();
            final RequestDispatcher disp = servletContext.getRequestDispatcher(url);
            disp.forward(request.getRequest(), response);
        } catch (final IOException | ServletException e) {
            this.log.error(e.getMessage());
            this.log.trace(&quot;&quot;, e);
            throw new RuntimeException(e);
        }
    }

    /**
     * XXX The 'doAuthenticate' is intended to replace 'authenticate' for needs like ours. In order to support old and
     * new at this time, we will continue to have both for time being.
     */
    @Override
    protected boolean doAuthenticate(final Request request, final HttpServletResponse response) throws IOException {
        return this.authenticate(request, response);
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/util/WaffleInfo.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/util/WaffleInfo.html#L97">97</a></td></tr>
<tr class="b">
<td>waffle/util/WaffleInfo.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/util/WaffleInfo.html#L97">97</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>public class WaffleInfo {

    /** The Constant LOGGER. */
    private static final Logger LOGGER = LoggerFactory.getLogger(WaffleInfo.class);

    /**
     * Get a Document with basic system information
     *
     * This uses the builtin jakarta.xml package even though the API is quite verbose
     *
     * @return Document with waffle info.
     *
     * @throws ParserConfigurationException
     *             when getting new document builder.
     */
    public Document getWaffleInfo() throws ParserConfigurationException {
        final DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();
        df.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);
        df.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, &quot;&quot;);
        df.setExpandEntityReferences(false);

        final Document doc = df.newDocumentBuilder().newDocument();

        // create the root element and add it to the document
        final Element root = doc.createElement(&quot;waffle&quot;);

        // Add Version Information as attributes
        String version = WaffleInfo.class.getPackage().getImplementationVersion();
        if (version != null) {
            root.setAttribute(&quot;version&quot;, version);
        }
        version = Platform.class.getPackage().getImplementationVersion();
        if (version != null) {
            root.setAttribute(&quot;jna&quot;, version);
        }
        version = WindowUtils.class.getPackage().getImplementationVersion();
        if (version != null) {
            root.setAttribute(&quot;jna-platform&quot;, version);
        }

        doc.appendChild(root);
        root.appendChild(this.getAuthProviderInfo(doc));

        return doc;
    }

    /**
     * Gets the auth provider info.
     *
     * @param doc
     *            the doc
     * @return the auth provider info
     */
    protected Element getAuthProviderInfo(final Document doc) {
        final IWindowsAuthProvider auth = new WindowsAuthProviderImpl();

        final Element node = doc.createElement(&quot;auth&quot;);
        node.setAttribute(&quot;class&quot;, auth.getClass().getName());

        // Current User
        Element child = doc.createElement(&quot;currentUser&quot;);
        node.appendChild(child);

        final String currentUsername = WindowsAccountImpl.getCurrentUsername();
        this.addAccountInfo(doc, child, new WindowsAccountImpl(currentUsername));

        // Computer
        child = doc.createElement(&quot;computer&quot;);
        node.appendChild(child);

        final IWindowsComputer c = auth.getCurrentComputer();
        Element value = doc.createElement(&quot;computerName&quot;);
        value.setTextContent(c.getComputerName());
        child.appendChild(value);

        value = doc.createElement(&quot;memberOf&quot;);
        value.setTextContent(c.getMemberOf());
        child.appendChild(value);

        value = doc.createElement(&quot;joinStatus&quot;);
        value.setTextContent(c.getJoinStatus());
        child.appendChild(value);

        value = doc.createElement(&quot;groups&quot;);
        Element g;
        for (final String s : c.getGroups()) {
            g = doc.createElement(&quot;group&quot;);
            g.setTextContent(s);
            value.appendChild(g);
        }
        child.appendChild(value);

        // Only Show Domains if we are in a Domain
        if (Netapi32Util.getJoinStatus() == LMJoin.NETSETUP_JOIN_STATUS.NetSetupDomainName) {
            child = doc.createElement(&quot;domains&quot;);
            node.appendChild(child);

            Element d;
            for (final IWindowsDomain domain : auth.getDomains()) {
                d = doc.createElement(&quot;domain&quot;);
                node.appendChild(d);

                value = doc.createElement(&quot;FQN&quot;);
                value.setTextContent(domain.getFqn());
                child.appendChild(value);

                value = doc.createElement(&quot;TrustTypeString&quot;);
                value.setTextContent(domain.getTrustTypeString());
                child.appendChild(value);

                value = doc.createElement(&quot;TrustDirectionString&quot;);
                value.setTextContent(domain.getTrustDirectionString());
                child.appendChild(value);
            }
        }
        return node;
    }

    /**
     * Adds the account info.
     *
     * @param doc
     *            the doc
     * @param node
     *            the node
     * @param account
     *            the account
     */
    protected void addAccountInfo(final Document doc, final Element node, final IWindowsAccount account) {
        Element value = doc.createElement(&quot;Name&quot;);
        value.setTextContent(account.getName());
        node.appendChild(value);

        value = doc.createElement(&quot;FQN&quot;);
        value.setTextContent(account.getFqn());
        node.appendChild(value);

        value = doc.createElement(&quot;Domain&quot;);
        value.setTextContent(account.getDomain());
        node.appendChild(value);

        value = doc.createElement(&quot;SID&quot;);
        value.setTextContent(account.getSidString());
        node.appendChild(value);
    }

    /**
     * Gets the lookup info.
     *
     * @param doc
     *            the doc
     * @param lookup
     *            the lookup
     * @return the lookup info
     */
    public Element getLookupInfo(final Document doc, final String lookup) {
        final IWindowsAuthProvider auth = new WindowsAuthProviderImpl();
        final Element node = doc.createElement(&quot;lookup&quot;);
        node.setAttribute(&quot;name&quot;, lookup);
        try {
            this.addAccountInfo(doc, node, auth.lookupAccount(lookup));
        } catch (final Win32Exception e) {
            node.appendChild(WaffleInfo.getException(doc, e));
        }
        return node;
    }

    /**
     * Gets the exception.
     *
     * @param doc
     *            the doc
     * @param t
     *            the t
     * @return the exception
     */
    public static Element getException(final Document doc, final Exception t) {
        final Element node = doc.createElement(&quot;exception&quot;);
        node.setAttribute(&quot;class&quot;, t.getClass().getName());

        Element value = doc.createElement(&quot;message&quot;);
        if (t.getMessage() != null) {
            value.setTextContent(t.getMessage());
            node.appendChild(value);
        }

        value = doc.createElement(&quot;trace&quot;);
        value.setTextContent(Arrays.toString(t.getStackTrace()));
        node.appendChild(value);
        return node;
    }

    /**
     * To pretty xml.
     *
     * @param doc
     *            the doc
     * @return the string
     * @throws TransformerException
     *             the transformer exception
     */
    public static String toPrettyXML(final Document doc) throws TransformerException {
        // set up a transformer
        final TransformerFactory transfac = TransformerFactory.newInstance();
        transfac.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);
        transfac.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, &quot;&quot;);

        final Transformer trans = transfac.newTransformer();
        trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, &quot;yes&quot;);
        trans.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);

        // create string from xml tree
        final StringWriter sw = new StringWriter();
        final StreamResult result = new StreamResult(sw);
        final DOMSource source = new DOMSource(doc);
        trans.transform(source, result);
        return sw.toString();
    }

    /**
     * Print system information.
     *
     * @param args
     *            variable arguments to pass to main. Valid values are &quot;-show&quot; and &quot;-lookup&quot;.
     */
    public static void main(final String[] args) {
        boolean show = false;
        final List&lt;String&gt; lookup = new ArrayList&lt;&gt;();
        if (args != null) {
            String arg;
            for (int i = 0; i &lt; args.length; i++) {
                arg = args[i];
                if (null != arg) {
                    switch (arg) {
                        case &quot;-show&quot;:
                            show = true;
                            break;
                        case &quot;-lookup&quot;:
                            lookup.add(args[++i]);
                            break;
                        default:
                            WaffleInfo.LOGGER.error(&quot;Unknown Argument: {}&quot;, arg);
                            throw new RuntimeException(&quot;Unknown Argument: &quot; + arg);
                    }
                }
            }
        }

        final WaffleInfo helper = new WaffleInfo();
        try {
            final Document info = helper.getWaffleInfo();
            for (final String name : lookup) {
                info.getDocumentElement().appendChild(helper.getLookupInfo(info, name));
            }

            final String xml = WaffleInfo.toPrettyXML(info);
            final File f;
            if (show) {
                f = File.createTempFile(&quot;waffle-info-&quot;, &quot;.xml&quot;);
                Files.write(f.toPath(), xml.getBytes(StandardCharsets.UTF_8), StandardOpenOption.APPEND);
                Desktop.getDesktop().open(f);
            } else {
                WaffleInfo.LOGGER.info(xml);
            }
        } catch (final IOException | TransformerException | ParserConfigurationException e) {
            WaffleInfo.LOGGER.error(e.getMessage());
            WaffleInfo.LOGGER.trace(&quot;&quot;, e);
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat10</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L102">102</a></td></tr>
<tr class="b">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat7</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L101">101</a></td></tr>
<tr class="a">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat85</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L102">102</a></td></tr>
<tr class="b">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat9</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L102">102</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>final LoginConfig loginConfig = this.context.getLoginConfig();

        if (principal != null &amp;&amp; !ntlmPost) {
            this.log.debug(&quot;previously authenticated user: {}&quot;, principal.getName());
            return true;
        } else if (negotiateCheck) {
            if (!authorizationHeader.isNull()) {
                boolean negotiateResult = this.negotiate(request, response, authorizationHeader);
                if (!negotiateResult) {
                    this.redirectTo(request, response, loginConfig.getErrorPage());
                }
                return negotiateResult;
            }
            this.log.debug(&quot;authorization required&quot;);
            this.sendUnauthorized(response);
            return false;
        } else if (securityCheck) {
            final boolean postResult = this.post(request, response);
            if (!postResult) {
                this.redirectTo(request, response, loginConfig.getErrorPage());
            }
            return postResult;
        } else {
            this.redirectTo(request, response, loginConfig.getLoginPage());
            return false;
        }
    }

    /**
     * Negotiate.
     *
     * @param request
     *            the request
     * @param response
     *            the response
     * @param authorizationHeader
     *            the authorization header
     * @return true, if successful
     */
    private boolean negotiate(final Request request, final HttpServletResponse response,
            final AuthorizationHeader authorizationHeader) {

        final String securityPackage = authorizationHeader.getSecurityPackage();
        // maintain a connection-based session for NTLM tokens
        final String connectionId = NtlmServletRequest.getConnectionId(request);

        this.log.debug(&quot;security package: {}, connection id: {}&quot;, securityPackage, connectionId);

        final boolean ntlmPost = authorizationHeader.isNtlmType1PostAuthorizationHeader();

        if (ntlmPost) {
            // type 1 NTLM authentication message received
            this.auth.resetSecurityToken(connectionId);
        }

        final byte[] tokenBuffer = authorizationHeader.getTokenBytes();
        this.log.debug(&quot;token buffer: {} byte(s)&quot;, Integer.valueOf(tokenBuffer.length));

        // log the user in using the token
        IWindowsSecurityContext securityContext;
        try {
            securityContext = this.auth.acceptSecurityToken(connectionId, tokenBuffer, securityPackage);
        } catch (final Win32Exception e) {
            this.log.warn(&quot;error logging in user: {}&quot;, e.getMessage());
            this.log.trace(&quot;&quot;, e);
            this.sendUnauthorized(response);
            return false;
        }
        this.log.debug(&quot;continue required: {}&quot;, Boolean.valueOf(securityContext.isContinue()));

        final byte[] continueTokenBytes = securityContext.getToken();
        if (continueTokenBytes != null &amp;&amp; continueTokenBytes.length &gt; 0) {
            final String continueToken = Base64.getEncoder().encodeToString(continueTokenBytes);
            this.log.debug(&quot;continue token: {}&quot;, continueToken);
            response.addHeader(&quot;WWW-Authenticate&quot;, securityPackage + &quot; &quot; + continueToken);
        }

        try {
            if (securityContext.isContinue() || ntlmPost) {
                response.setHeader(&quot;Connection&quot;, &quot;keep-alive&quot;);
                response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
                response.flushBuffer();
                return false;
            }
        } catch (final IOException e) {
            this.log.warn(&quot;error logging in user: {}&quot;, e.getMessage());
            this.log.trace(&quot;&quot;, e);
            this.sendUnauthorized(response);
            return false;
        }

        // create and register the user principal with the session
        final IWindowsIdentity windowsIdentity = securityContext.getIdentity();

        // disable guest login
        if (!this.allowGuestLogin &amp;&amp; windowsIdentity.isGuest()) {
            this.log.warn(&quot;guest login disabled: {}&quot;, windowsIdentity.getFqn());
            this.sendUnauthorized(response);
            return false;
        }

        try {

            this.log.debug(&quot;logged in user: {} ({})&quot;, windowsIdentity.getFqn(), windowsIdentity.getSidString());

            final GenericPrincipal genericPrincipal = this.createPrincipal(windowsIdentity);

            this.log.debug(&quot;roles: {}&quot;, String.join(&quot;, &quot;, genericPrincipal.getRoles()));

            // create a session associated with this request if there's none
            final HttpSession session = request.getSession(true);
            this.log.debug(&quot;session id: {}&quot;, session == null ? &quot;null&quot; : session.getId());

            this.register(request, response, genericPrincipal, securityPackage, genericPrincipal.getName(), null);
            this.log.info(&quot;successfully logged in user: {}&quot;, genericPrincipal.getName());

        } finally {
            windowsIdentity.dispose();
        }

        return true;
    }

    /**
     * Post.
     *
     * @param request
     *            the request
     * @param response
     *            the response
     * @return true, if successful
     */
    private boolean post(final Request request, final HttpServletResponse response) {

        final String username = request.getParameter(&quot;j_username&quot;);
        final String password = request.getParameter(&quot;j_password&quot;);

        this.log.debug(&quot;logging in: {}&quot;, username);

        IWindowsIdentity windowsIdentity;
        try {
            windowsIdentity = this.auth.logonUser(username, password);
        } catch (final Exception e) {
            this.log.error(e.getMessage());
            this.log.trace(&quot;&quot;, e);
            return false;
        }

        // disable guest login
        if (!this.allowGuestLogin &amp;&amp; windowsIdentity.isGuest()) {
            this.log.warn(&quot;guest login disabled: {}&quot;, windowsIdentity.getFqn());
            return false;
        }

        try {
            this.log.debug(&quot;successfully logged in {} ({})&quot;, username, windowsIdentity.getSidString());

            final GenericPrincipal genericPrincipal = this.createPrincipal(windowsIdentity);

            this.log.debug(&quot;roles: {}&quot;, String.join(&quot;, &quot;, genericPrincipal.getRoles()));
            // create a session associated with this request if there's none
            final HttpSession session = request.getSession(true);
            this.log.debug(&quot;session id: {}&quot;, session == null ? &quot;null&quot; : session.getId());

            this.register(request, response, genericPrincipal, &quot;FORM&quot;, genericPrincipal.getName(), null);
            this.log.info(&quot;successfully logged in user: {}&quot;, genericPrincipal.getName());
        } finally {
            windowsIdentity.dispose();
        }

        return true;
    }

    /**
     * Redirect to.
     *
     * @param request
     *            the request
     * @param response
     *            the response
     * @param url
     *            the url
     */
    private void redirectTo(final Request request, final HttpServletResponse response, final String url) {
        try {
            this.log.debug(&quot;redirecting to: {}&quot;, url);
            final ServletContext servletContext = this.context.getServletContext();
            final RequestDispatcher disp = servletContext.getRequestDispatcher(url);
            disp.forward(request.getRequest(), response);
        } catch (final IOException | ServletException e) {
            this.log.error(e.getMessage());
            this.log.trace(&quot;&quot;, e);
            throw new RuntimeException(e);
        }
    }</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/windows/auth/impl/WindowsAuthProviderImpl.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/windows/auth/impl/WindowsAuthProviderImpl.html#L59">59</a></td></tr>
<tr class="b">
<td>waffle/windows/auth/impl/WindowsAuthProviderImpl.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/windows/auth/impl/WindowsAuthProviderImpl.html#L59">59</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>public class WindowsAuthProviderImpl implements IWindowsAuthProvider {

    /** The Continue Context Timeout. */
    public static final int CONTINUE_CONTEXT_TIMEOUT = 30;

    /**
     * The Class ContinueContext.
     */
    private static class ContinueContext {
        /** The continue handle. */
        CtxtHandle continueHandle;

        /** The server credential. */
        IWindowsCredentialsHandle serverCredential;

        /**
         * Instantiates a new continue context.
         *
         * @param handle
         *            the handle
         * @param windowsCredential
         *            the windows credential
         */
        public ContinueContext(final CtxtHandle handle, final IWindowsCredentialsHandle windowsCredential) {
            this.continueHandle = handle;
            this.serverCredential = windowsCredential;
        }
    }

    /** The continue contexts. */
    private final Cache&lt;String, ContinueContext&gt; continueContexts;

    /**
     * Instantiates a new windows auth provider impl.
     */
    public WindowsAuthProviderImpl() {
        this(WindowsAuthProviderImpl.CONTINUE_CONTEXT_TIMEOUT);
    }

    /**
     * A Windows authentication provider.
     *
     * @param continueContextsTimeout
     *            Timeout for security contexts in seconds.
     */
    public WindowsAuthProviderImpl(final int continueContextsTimeout) {
        this.continueContexts = Cache.newCache(continueContextsTimeout);
    }

    @Override
    public IWindowsSecurityContext acceptSecurityToken(final String connectionId, final byte[] token,
            final String securityPackage) {

        if (token == null || token.length == 0) {
            this.resetSecurityToken(connectionId);
            throw new Win32Exception(WinError.SEC_E_INVALID_TOKEN);
        }

        CtxtHandle continueHandle = null;
        IWindowsCredentialsHandle serverCredential;
        ContinueContext continueContext = this.continueContexts.get(connectionId);
        if (continueContext != null) {
            continueHandle = continueContext.continueHandle;
            serverCredential = continueContext.serverCredential;
        } else {
            serverCredential = new WindowsCredentialsHandleImpl(null, Sspi.SECPKG_CRED_INBOUND, securityPackage);
            serverCredential.initialize();
        }

        WindowsSecurityContextImpl sc;

        int rc;
        int tokenSize = Sspi.MAX_TOKEN_SIZE;

        do {
            final ManagedSecBufferDesc pbServerToken = new ManagedSecBufferDesc(Sspi.SECBUFFER_TOKEN, tokenSize);
            final ManagedSecBufferDesc pbClientToken = new ManagedSecBufferDesc(Sspi.SECBUFFER_TOKEN, token);
            final IntByReference pfClientContextAttr = new IntByReference();

            final CtxtHandle phNewServerContext = new CtxtHandle();
            rc = Secur32.INSTANCE.AcceptSecurityContext(serverCredential.getHandle(), continueHandle, pbClientToken,
                    Sspi.ISC_REQ_CONNECTION, Sspi.SECURITY_NATIVE_DREP, phNewServerContext, pbServerToken,
                    pfClientContextAttr, null);

            sc = new WindowsSecurityContextImpl();
            sc.setCredentialsHandle(serverCredential);
            sc.setSecurityPackage(securityPackage);
            sc.setSecurityContext(phNewServerContext);

            switch (rc) {
                case WinError.SEC_E_BUFFER_TOO_SMALL:
                    tokenSize += Sspi.MAX_TOKEN_SIZE;
                    sc.dispose();
                    WindowsSecurityContextImpl.dispose(continueHandle);
                    break;
                case WinError.SEC_E_OK:
                    // the security context received from the client was accepted
                    this.resetSecurityToken(connectionId);
                    // if an output token was generated by the function, it must be sent to the client process
                    if (pbServerToken.pBuffers != null &amp;&amp; pbServerToken.cBuffers == 1
                            &amp;&amp; pbServerToken.getBuffer(0).cbBuffer &gt; 0) {
                        sc.setToken(pbServerToken.getBuffer(0).getBytes() == null ? new byte[0]
                                : pbServerToken.getBuffer(0).getBytes().clone());
                    }
                    sc.setContinue(false);
                    break;
                case WinError.SEC_I_CONTINUE_NEEDED:
                    // the server must send the output token to the client and wait for a returned token
                    continueContext = new ContinueContext(phNewServerContext, serverCredential);
                    this.continueContexts.put(connectionId, continueContext);
                    sc.setToken(pbServerToken.getBuffer(0).getBytes() == null ? new byte[0]
                            : pbServerToken.getBuffer(0).getBytes().clone());
                    sc.setContinue(true);
                    break;
                default:
                    sc.dispose();
                    WindowsSecurityContextImpl.dispose(continueHandle);
                    this.resetSecurityToken(connectionId);
                    throw new Win32Exception(rc);
            }
        } while (rc == WinError.SEC_E_BUFFER_TOO_SMALL);

        return sc;
    }

    @Override
    public IWindowsComputer getCurrentComputer() {
        try {
            return new WindowsComputerImpl(InetAddress.getLocalHost().getHostName());
        } catch (final UnknownHostException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public IWindowsDomain[] getDomains() {
        final List&lt;IWindowsDomain&gt; domains = new ArrayList&lt;&gt;();
        final DomainTrust[] trusts = Netapi32Util.getDomainTrusts();
        for (final DomainTrust trust : trusts) {
            domains.add(new WindowsDomainImpl(trust));
        }
        return domains.toArray(new IWindowsDomain[0]);
    }

    @Override
    public IWindowsIdentity logonDomainUser(final String username, final String domain, final String password) {
        return this.logonDomainUserEx(username, domain, password, WinBase.LOGON32_LOGON_NETWORK,
                WinBase.LOGON32_PROVIDER_DEFAULT);
    }

    @Override
    public IWindowsIdentity logonDomainUserEx(final String username, final String domain, final String password,
            final int logonType, final int logonProvider) {
        final HANDLEByReference phUser = new HANDLEByReference();
        if (!Advapi32.INSTANCE.LogonUser(username, domain, password, logonType, logonProvider, phUser)) {
            throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
        }
        return new WindowsIdentityImpl(phUser.getValue());
    }

    @Override
    public IWindowsIdentity logonUser(final String username, final String password) {
        // username@domain UPN format is natively supported by the
        // Windows LogonUser API process domain\\username format
        final String[] userNameDomain = username.split(&quot;\\\\&quot;, 2);
        if (userNameDomain.length == 2) {
            return this.logonDomainUser(userNameDomain[1], userNameDomain[0], password);
        }
        return this.logonDomainUser(username, null, password);
    }

    @Override
    public IWindowsAccount lookupAccount(final String username) {
        return new WindowsAccountImpl(username);
    }

    @Override
    public void resetSecurityToken(final String connectionId) {
        this.continueContexts.remove(connectionId);
    }

    /**
     * Number of elements in the continue contexts map.
     *
     * @return Number of elements in the hash map.
     */
    public int getContinueContextsSize() {
        return this.continueContexts.size();
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat10</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L50">50</a></td></tr>
<tr class="b">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat85</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L50">50</a></td></tr>
<tr class="a">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat9</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L50">50</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class NegotiateAuthenticator extends WaffleAuthenticatorBase {

    /**
     * Instantiates a new negotiate authenticator.
     */
    public NegotiateAuthenticator() {
        super();
        this.log = LoggerFactory.getLogger(NegotiateAuthenticator.class);
        this.info = &quot;waffle.apache.NegotiateAuthenticator/1.0&quot;;
        this.log.debug(&quot;[waffle.apache.NegotiateAuthenticator] loaded&quot;);
    }

    @Override
    public synchronized void startInternal() throws LifecycleException {
        this.log.info(&quot;[waffle.apache.NegotiateAuthenticator] started&quot;);
        super.startInternal();
    }

    @Override
    public synchronized void stopInternal() throws LifecycleException {
        super.stopInternal();
        this.log.info(&quot;[waffle.apache.NegotiateAuthenticator] stopped&quot;);
    }

    @Override
    public boolean authenticate(final Request request, final HttpServletResponse response) {

        Principal principal = request.getUserPrincipal();
        final AuthorizationHeader authorizationHeader = new AuthorizationHeader(request);
        final boolean ntlmPost = authorizationHeader.isNtlmType1PostAuthorizationHeader();

        this.log.debug(&quot;{} {}, contentlength: {}&quot;, request.getMethod(), request.getRequestURI(),
                Integer.valueOf(request.getContentLength()));
        this.log.debug(&quot;authorization: {}, ntlm post: {}&quot;, authorizationHeader, Boolean.valueOf(ntlmPost));

        if (principal != null &amp;&amp; !ntlmPost) {
            // user already authenticated
            this.log.debug(&quot;previously authenticated user: {}&quot;, principal.getName());
            return true;
        }

        // authenticate user
        if (!authorizationHeader.isNull()) {

            final String securityPackage = authorizationHeader.getSecurityPackage();
            // maintain a connection-based session for NTLM tokens
            final String connectionId = NtlmServletRequest.getConnectionId(request);

            this.log.debug(&quot;security package: {}, connection id: {}&quot;, securityPackage, connectionId);

            if (ntlmPost) {
                // type 1 NTLM authentication message received
                this.auth.resetSecurityToken(connectionId);
            }

            final byte[] tokenBuffer = authorizationHeader.getTokenBytes();
            this.log.debug(&quot;token buffer: {} byte(s)&quot;, Integer.valueOf(tokenBuffer.length));

            // log the user in using the token
            IWindowsSecurityContext securityContext;
            try {
                securityContext = this.auth.acceptSecurityToken(connectionId, tokenBuffer, securityPackage);
            } catch (final Win32Exception e) {
                this.log.warn(&quot;error logging in user: {}&quot;, e.getMessage());
                this.log.trace(&quot;&quot;, e);
                this.sendUnauthorized(response);
                return false;
            }
            this.log.debug(&quot;continue required: {}&quot;, Boolean.valueOf(securityContext.isContinue()));

            final byte[] continueTokenBytes = securityContext.getToken();
            if (continueTokenBytes != null &amp;&amp; continueTokenBytes.length &gt; 0) {
                final String continueToken = Base64.getEncoder().encodeToString(continueTokenBytes);
                this.log.debug(&quot;continue token: {}&quot;, continueToken);
                response.addHeader(&quot;WWW-Authenticate&quot;, securityPackage + &quot; &quot; + continueToken);
            }

            try {
                if (securityContext.isContinue()) {
                    response.setHeader(&quot;Connection&quot;, &quot;keep-alive&quot;);
                    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
                    response.flushBuffer();
                    return false;
                }
            } catch (final IOException e) {
                this.log.warn(&quot;error logging in user: {}&quot;, e.getMessage());
                this.log.trace(&quot;&quot;, e);
                this.sendUnauthorized(response);
                return false;
            }

            // realm: fail if no realm is configured
            if (this.context == null || this.context.getRealm() == null) {
                this.log.warn(&quot;missing context/realm&quot;);
                this.sendError(response, HttpServletResponse.SC_SERVICE_UNAVAILABLE);
                return false;
            }

            // create and register the user principal with the session
            final IWindowsIdentity windowsIdentity = securityContext.getIdentity();

            // disable guest login
            if (!this.allowGuestLogin &amp;&amp; windowsIdentity.isGuest()) {
                this.log.warn(&quot;guest login disabled: {}&quot;, windowsIdentity.getFqn());
                this.sendUnauthorized(response);
                return false;
            }

            try {
                this.log.debug(&quot;logged in user: {} ({})&quot;, windowsIdentity.getFqn(), windowsIdentity.getSidString());

                final GenericPrincipal genericPrincipal = this.createPrincipal(windowsIdentity);

                this.log.debug(&quot;roles: {}&quot;, String.join(&quot;, &quot;, genericPrincipal.getRoles()));

                principal = genericPrincipal;

                // create a session associated with this request if there's none
                final HttpSession session = request.getSession(true);
                this.log.debug(&quot;session id: {}&quot;, session == null ? &quot;null&quot; : session.getId());

                // register the authenticated principal
                this.register(request, response, principal, securityPackage, principal.getName(), null);
                this.log.info(&quot;successfully logged in user: {}&quot;, principal.getName());

            } finally {
                windowsIdentity.dispose();
                securityContext.dispose();
            }

            return true;
        }

        this.log.debug(&quot;authorization required&quot;);
        this.sendUnauthorized(response);
        return false;
    }

    /**
     * XXX The 'doAuthenticate' is intended to replace 'authenticate' for needs like ours. In order to support old and
     * new at this time, we will continue to have both for time being.
     */
    @Override
    protected boolean doAuthenticate(final Request request, final HttpServletResponse response) throws IOException {
        return this.authenticate(request, response);
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/apache/WaffleAuthenticatorBase.java</td>
<td>waffle-tomcat10</td>
<td><a href="./xref/waffle/apache/WaffleAuthenticatorBase.html#L52">52</a></td></tr>
<tr class="a">
<td>waffle/apache/WaffleAuthenticatorBase.java</td>
<td>waffle-tomcat85</td>
<td><a href="./xref/waffle/apache/WaffleAuthenticatorBase.html#L52">52</a></td></tr>
<tr class="b">
<td>waffle/apache/WaffleAuthenticatorBase.java</td>
<td>waffle-tomcat9</td>
<td><a href="./xref/waffle/apache/WaffleAuthenticatorBase.html#L52">52</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>abstract class WaffleAuthenticatorBase extends AuthenticatorBase {

    /** The Constant SUPPORTED_PROTOCOLS. */
    private static final Set&lt;String&gt; SUPPORTED_PROTOCOLS = new LinkedHashSet&lt;&gt;(Arrays.asList(&quot;Negotiate&quot;, &quot;NTLM&quot;));

    /** The info. */
    protected String info;

    /** The log. */
    protected Logger log;

    /** The principal format. */
    protected PrincipalFormat principalFormat = PrincipalFormat.FQN;

    /** The role format. */
    protected PrincipalFormat roleFormat = PrincipalFormat.FQN;

    /** The allow guest login. */
    protected boolean allowGuestLogin = true;

    /** The protocols. */
    protected Set&lt;String&gt; protocols = WaffleAuthenticatorBase.SUPPORTED_PROTOCOLS;

    /** The auth continueContextsTimeout configuration. */
    protected int continueContextsTimeout = WindowsAuthProviderImpl.CONTINUE_CONTEXT_TIMEOUT;

    /** The auth. */
    protected IWindowsAuthProvider auth;

    /**
     * Gets the continue context time out configuration.
     *
     * @return the continue contexts timeout
     */
    public int getContinueContextsTimeout() {
        return this.continueContextsTimeout;
    }

    /**
     * Sets the continue context time out configuration.
     *
     * @param continueContextsTimeout
     *            the new continue contexts timeout
     */
    public void setContinueContextsTimeout(final int continueContextsTimeout) {
        this.continueContextsTimeout = continueContextsTimeout;
    }

    /**
     * Windows authentication provider.
     *
     * @return IWindowsAuthProvider.
     */
    public IWindowsAuthProvider getAuth() {
        return this.auth;
    }

    /**
     * Set Windows auth provider.
     *
     * @param provider
     *            Class implements IWindowsAuthProvider.
     */
    public void setAuth(final IWindowsAuthProvider provider) {
        this.auth = provider;
    }

    /**
     * Gets the info.
     *
     * @return the info
     */
    public String getInfo() {
        return this.info;
    }

    /**
     * Set the principal format.
     *
     * @param format
     *            Principal format.
     */
    public void setPrincipalFormat(final String format) {
        this.principalFormat = PrincipalFormat.valueOf(format.toUpperCase(Locale.ENGLISH));
        this.log.debug(&quot;principal format: {}&quot;, this.principalFormat);
    }

    /**
     * Principal format.
     *
     * @return Principal format.
     */
    public PrincipalFormat getPrincipalFormat() {
        return this.principalFormat;
    }

    /**
     * Set the principal format.
     *
     * @param format
     *            Role format.
     */
    public void setRoleFormat(final String format) {
        this.roleFormat = PrincipalFormat.valueOf(format.toUpperCase(Locale.ENGLISH));
        this.log.debug(&quot;role format: {}&quot;, this.roleFormat);
    }

    /**
     * Principal format.
     *
     * @return Role format.
     */
    public PrincipalFormat getRoleFormat() {
        return this.roleFormat;
    }

    /**
     * True if Guest login permitted.
     *
     * @return True if Guest login permitted, false otherwise.
     */
    public boolean isAllowGuestLogin() {
        return this.allowGuestLogin;
    }

    /**
     * Set whether Guest login is permitted. Default is true, if the Guest account is enabled, an invalid
     * username/password results in a Guest login.
     *
     * @param value
     *            True or false.
     */
    public void setAllowGuestLogin(final boolean value) {
        this.allowGuestLogin = value;
    }

    /**
     * Set the authentication protocols. Default is &quot;Negotiate, NTLM&quot;.
     *
     * @param value
     *            Authentication protocols
     */
    public void setProtocols(final String value) {
        this.protocols = new LinkedHashSet&lt;&gt;();
        final String[] protocolNames = value.split(&quot;,&quot;, -1);
        for (String protocolName : protocolNames) {
            protocolName = protocolName.trim();
            if (!protocolName.isEmpty()) {
                this.log.debug(&quot;init protocol: {}&quot;, protocolName);
                if (WaffleAuthenticatorBase.SUPPORTED_PROTOCOLS.contains(protocolName)) {
                    this.protocols.add(protocolName);
                } else {
                    this.log.error(&quot;unsupported protocol: {}&quot;, protocolName);
                    throw new RuntimeException(&quot;Unsupported protocol: &quot; + protocolName);
                }
            }
        }
    }

    /**
     * Send a 401 Unauthorized along with protocol authentication headers.
     *
     * @param response
     *            HTTP Response
     */
    protected void sendUnauthorized(final HttpServletResponse response) {
        try {
            for (final String protocol : this.protocols) {
                response.addHeader(&quot;WWW-Authenticate&quot;, protocol);
            }
            response.setHeader(&quot;Connection&quot;, &quot;close&quot;);
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
            response.flushBuffer();
        } catch (final IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Send an error code.
     *
     * @param response
     *            HTTP Response
     * @param code
     *            Error Code
     */
    protected void sendError(final HttpServletResponse response, final int code) {
        try {
            response.sendError(code);
        } catch (final IOException e) {
            this.log.error(e.getMessage());
            this.log.trace(&quot;&quot;, e);
            throw new RuntimeException(e);
        }
    }

    @Override
    protected String getAuthMethod() {
        return null;
    }

    @Override
    protected Principal doLogin(final Request request, final String username, final String password)
            throws ServletException {
        this.log.debug(&quot;logging in: {}&quot;, username);
        IWindowsIdentity windowsIdentity;
        try {
            windowsIdentity = this.auth.logonUser(username, password);
        } catch (final Exception e) {
            this.log.error(e.getMessage());
            this.log.trace(&quot;&quot;, e);
            return super.doLogin(request, username, password);
        }
        // disable guest login
        if (!this.allowGuestLogin &amp;&amp; windowsIdentity.isGuest()) {
            this.log.warn(&quot;guest login disabled: {}&quot;, windowsIdentity.getFqn());
            return super.doLogin(request, username, password);
        }
        try {
            this.log.debug(&quot;successfully logged in {} ({})&quot;, username, windowsIdentity.getSidString());
            final GenericPrincipal genericPrincipal = this.createPrincipal(windowsIdentity);
            this.log.debug(&quot;roles: {}&quot;, String.join(&quot;, &quot;, genericPrincipal.getRoles()));
            return genericPrincipal;
        } finally {
            windowsIdentity.dispose();
        }
    }

    /**
     * This method will create an instance of a IWindowsIdentity based GenericPrincipal. It is used for creating custom
     * implementation within subclasses.
     *
     * @param windowsIdentity
     *            the windows identity to initialize the principal
     * @return the Generic Principal
     */
    protected GenericPrincipal createPrincipal(final IWindowsIdentity windowsIdentity) {
        return new GenericWindowsPrincipal(windowsIdentity, this.principalFormat, this.roleFormat);
    }

    /**
     * Hook to the start and to set up the dependencies.
     *
     * @throws LifecycleException
     *             the lifecycle exception
     */
    @Override
    public synchronized void startInternal() throws LifecycleException {
        this.log.debug(&quot;Creating a windows authentication provider with continueContextsTimeout property set to: {}&quot;,
                this.continueContextsTimeout);
        this.auth = new WindowsAuthProviderImpl(this.continueContextsTimeout);
        super.startInternal();
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/servlet/WindowsPrincipal.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/servlet/WindowsPrincipal.html#L43">43</a></td></tr>
<tr class="b">
<td>waffle/servlet/WindowsPrincipal.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/servlet/WindowsPrincipal.html#L43">43</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>public class WindowsPrincipal implements Principal, Serializable {

    /** The Constant serialVersionUID. */
    private static final long serialVersionUID = 1L;

    /** The fqn. */
    private final String fqn;

    /** The sid. */
    private final byte[] sid;

    /** The sid string. */
    private final String sidString;

    /** The roles. */
    private final List&lt;String&gt; roles;

    /** The identity. */
    private transient IWindowsIdentity identity;

    /** The groups. */
    private final Map&lt;String, WindowsAccount&gt; groups;

    /**
     * A windows principal.
     *
     * @param windowsIdentity
     *            Windows identity.
     */
    public WindowsPrincipal(final IWindowsIdentity windowsIdentity) {
        this(windowsIdentity, PrincipalFormat.FQN, PrincipalFormat.FQN);
    }

    /**
     * A windows principal.
     *
     * @param windowsIdentity
     *            Windows identity.
     * @param principalFormat
     *            Principal format.
     * @param roleFormat
     *            Role format.
     */
    public WindowsPrincipal(final IWindowsIdentity windowsIdentity, final PrincipalFormat principalFormat,
            final PrincipalFormat roleFormat) {
        this.identity = windowsIdentity;
        this.fqn = windowsIdentity.getFqn();
        this.sid = windowsIdentity.getSid();
        this.sidString = windowsIdentity.getSidString();
        this.groups = WindowsPrincipal.getGroups(windowsIdentity.getGroups());
        this.roles = WindowsPrincipal.getRoles(windowsIdentity, principalFormat, roleFormat);
    }

    /**
     * Gets the roles.
     *
     * @param windowsIdentity
     *            the windows identity
     * @param principalFormat
     *            the principal format
     * @param roleFormat
     *            the role format
     * @return the roles
     */
    private static List&lt;String&gt; getRoles(final IWindowsIdentity windowsIdentity, final PrincipalFormat principalFormat,
            final PrincipalFormat roleFormat) {
        final List&lt;String&gt; roles = new ArrayList&lt;&gt;();
        roles.addAll(WindowsPrincipal.getPrincipalNames(windowsIdentity, principalFormat));
        for (final IWindowsAccount group : windowsIdentity.getGroups()) {
            roles.addAll(WindowsPrincipal.getRoleNames(group, roleFormat));
        }
        return roles;
    }

    /**
     * Gets the groups.
     *
     * @param groups
     *            the groups
     * @return the groups
     */
    private static Map&lt;String, WindowsAccount&gt; getGroups(final IWindowsAccount[] groups) {
        final Map&lt;String, WindowsAccount&gt; groupMap = new HashMap&lt;&gt;();
        for (final IWindowsAccount group : groups) {
            groupMap.put(group.getFqn(), new WindowsAccount(group));
        }
        return groupMap;
    }

    /**
     * Byte representation of the SID.
     *
     * @return Array of bytes.
     */
    public byte[] getSid() {
        return this.sid.clone();
    }

    /**
     * String representation of the SID.
     *
     * @return String.
     */
    public String getSidString() {
        return this.sidString;
    }

    /**
     * Windows groups that the user is a member of.
     *
     * @return A map of group names to groups.
     */
    public Map&lt;String, WindowsAccount&gt; getGroups() {
        return this.groups;
    }

    /**
     * Returns a list of role principal objects.
     *
     * @param group
     *            Windows group.
     * @param principalFormat
     *            Principal format.
     * @return List of role principal objects.
     */
    private static List&lt;String&gt; getRoleNames(final IWindowsAccount group, final PrincipalFormat principalFormat) {
        final List&lt;String&gt; principals = new ArrayList&lt;&gt;();
        switch (principalFormat) {
            case FQN:
                principals.add(group.getFqn());
                break;
            case SID:
                principals.add(group.getSidString());
                break;
            case BOTH:
                principals.add(group.getFqn());
                principals.add(group.getSidString());
                break;
            case NONE:
            default:
                break;
        }
        return principals;
    }

    /**
     * Returns a list of user principal objects.
     *
     * @param windowsIdentity
     *            Windows identity.
     * @param principalFormat
     *            Principal format.
     * @return A list of user principal objects.
     */
    private static List&lt;String&gt; getPrincipalNames(final IWindowsIdentity windowsIdentity,
            final PrincipalFormat principalFormat) {
        final List&lt;String&gt; principals = new ArrayList&lt;&gt;();
        switch (principalFormat) {
            case FQN:
                principals.add(windowsIdentity.getFqn());
                break;
            case SID:
                principals.add(windowsIdentity.getSidString());
                break;
            case BOTH:
                principals.add(windowsIdentity.getFqn());
                principals.add(windowsIdentity.getSidString());
                break;
            case NONE:
            default:
                break;
        }
        return principals;
    }

    /**
     * Get an array of roles as a string.
     *
     * @return Role1, Role2, ...
     */
    public String getRolesString() {
        return String.join(&quot;, &quot;, this.roles);
    }

    /**
     * Checks whether the principal has a given role.
     *
     * @param role
     *            Role name.
     * @return True if the principal has a role, false otherwise.
     */
    public boolean hasRole(final String role) {
        return this.roles.contains(role);
    }

    /**
     * Fully qualified name.
     *
     * @return String.
     */
    @Override
    public String getName() {
        return this.fqn;
    }

    /**
     * Underlying identity.
     *
     * @return String.
     */
    public IWindowsIdentity getIdentity() {
        return this.identity;
    }

    @Override
    public String toString() {
        return this.getName();
    }

    @Override
    public boolean equals(final Object o) {
        if (this == o) {
            return true;
        }

        if (o instanceof WindowsPrincipal) {
            return this.getName().equals(((WindowsPrincipal) o).getName());
        }

        return false;
    }

    @Override
    public int hashCode() {
        return this.getName().hashCode();
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/servlet/spi/NegotiateSecurityFilterProvider.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/servlet/spi/NegotiateSecurityFilterProvider.html#L49">49</a></td></tr>
<tr class="b">
<td>waffle/servlet/spi/NegotiateSecurityFilterProvider.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/servlet/spi/NegotiateSecurityFilterProvider.html#L49">49</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>public class NegotiateSecurityFilterProvider implements SecurityFilterProvider {

    /** The Constant LOGGER. */
    private static final Logger LOGGER = LoggerFactory.getLogger(NegotiateSecurityFilterProvider.class);

    /** The Constant WWW_AUTHENTICATE. */
    private static final String WWW_AUTHENTICATE = &quot;WWW-Authenticate&quot;;

    /** The Constant PROTOCOLS. */
    private static final String PROTOCOLS = &quot;protocols&quot;;

    /** The Constant NEGOTIATE. */
    private static final String NEGOTIATE = &quot;Negotiate&quot;;

    /** The Constant NTLM. */
    private static final String NTLM = &quot;NTLM&quot;;

    /** The protocols. */
    private List&lt;String&gt; protocols = new ArrayList&lt;&gt;();

    /** The auth. */
    private final IWindowsAuthProvider auth;

    /**
     * Instantiates a new negotiate security filter provider.
     *
     * @param newAuthProvider
     *            the new auth provider
     */
    public NegotiateSecurityFilterProvider(final IWindowsAuthProvider newAuthProvider) {
        this.auth = newAuthProvider;
        this.protocols.add(NegotiateSecurityFilterProvider.NEGOTIATE);
        this.protocols.add(NegotiateSecurityFilterProvider.NTLM);
    }

    /**
     * Gets the protocols.
     *
     * @return the protocols
     */
    public List&lt;String&gt; getProtocols() {
        return this.protocols;
    }

    /**
     * Sets the protocols.
     *
     * @param values
     *            the new protocols
     */
    public void setProtocols(final List&lt;String&gt; values) {
        this.protocols = values;
    }

    @Override
    public void sendUnauthorized(final HttpServletResponse response) {
        for (final String protocol : this.protocols) {
            response.addHeader(NegotiateSecurityFilterProvider.WWW_AUTHENTICATE, protocol);
        }
    }

    @Override
    public boolean isPrincipalException(final HttpServletRequest request) {
        final AuthorizationHeader authorizationHeader = new AuthorizationHeader(request);
        final boolean ntlmPost = authorizationHeader.isNtlmType1PostAuthorizationHeader();
        NegotiateSecurityFilterProvider.LOGGER.debug(&quot;authorization: {}, ntlm post: {}&quot;, authorizationHeader,
                Boolean.valueOf(ntlmPost));
        return ntlmPost;
    }

    @Override
    public IWindowsIdentity doFilter(final HttpServletRequest request, final HttpServletResponse response)
            throws IOException {

        final AuthorizationHeader authorizationHeader = new AuthorizationHeader(request);
        final boolean ntlmPost = authorizationHeader.isNtlmType1PostAuthorizationHeader();

        // maintain a connection-based session for NTLM tokens
        final String connectionId = NtlmServletRequest.getConnectionId(request);
        final String securityPackage = authorizationHeader.getSecurityPackage();
        NegotiateSecurityFilterProvider.LOGGER.debug(&quot;security package: {}, connection id: {}&quot;, securityPackage,
                connectionId);

        if (ntlmPost) {
            // type 2 NTLM authentication message received
            this.auth.resetSecurityToken(connectionId);
        }

        final byte[] tokenBuffer = authorizationHeader.getTokenBytes();
        NegotiateSecurityFilterProvider.LOGGER.debug(&quot;token buffer: {} byte(s)&quot;, Integer.valueOf(tokenBuffer.length));
        final IWindowsSecurityContext securityContext = this.auth.acceptSecurityToken(connectionId, tokenBuffer,
                securityPackage);

        final byte[] continueTokenBytes = securityContext.getToken();
        if (continueTokenBytes != null &amp;&amp; continueTokenBytes.length &gt; 0) {
            final String continueToken = Base64.getEncoder().encodeToString(continueTokenBytes);
            NegotiateSecurityFilterProvider.LOGGER.debug(&quot;continue token: {}&quot;, continueToken);
            response.addHeader(NegotiateSecurityFilterProvider.WWW_AUTHENTICATE, securityPackage + &quot; &quot; + continueToken);
        }

        NegotiateSecurityFilterProvider.LOGGER.debug(&quot;continue required: {}&quot;,
                Boolean.valueOf(securityContext.isContinue()));
        if (securityContext.isContinue()) {
            response.setHeader(&quot;Connection&quot;, &quot;keep-alive&quot;);
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.flushBuffer();
            return null;
        }

        final IWindowsIdentity identity = securityContext.getIdentity();
        securityContext.dispose();
        return identity;
    }

    @Override
    public boolean isSecurityPackageSupported(final String securityPackage) {
        for (final String protocol : this.protocols) {
            if (protocol.equalsIgnoreCase(securityPackage)) {
                return true;
            }
        }
        return false;
    }

    @Override
    public void initParameter(final String parameterName, final String parameterValue) {
        if (NegotiateSecurityFilterProvider.PROTOCOLS.equals(parameterName)) {
            this.protocols = new ArrayList&lt;&gt;();
            final String[] protocolNames = parameterValue.split(&quot;\\s+&quot;, -1);
            for (String protocolName : protocolNames) {
                protocolName = protocolName.trim();
                if (protocolName.length() &gt; 0) {
                    NegotiateSecurityFilterProvider.LOGGER.debug(&quot;init protocol: {}&quot;, protocolName);
                    if (NegotiateSecurityFilterProvider.NEGOTIATE.equals(protocolName)
                            || NegotiateSecurityFilterProvider.NTLM.equals(protocolName)) {
                        this.protocols.add(protocolName);
                    } else {
                        NegotiateSecurityFilterProvider.LOGGER.error(&quot;unsupported protocol: {}&quot;, protocolName);
                        throw new RuntimeException(&quot;Unsupported protocol: &quot; + protocolName);
                    }
                }
            }
        } else {
            throw new InvalidParameterException(parameterName);
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/windows/auth/impl/WindowsSecurityContextImpl.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/windows/auth/impl/WindowsSecurityContextImpl.html#L46">46</a></td></tr>
<tr class="b">
<td>waffle/windows/auth/impl/WindowsSecurityContextImpl.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/windows/auth/impl/WindowsSecurityContextImpl.html#L46">46</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>public class WindowsSecurityContextImpl implements IWindowsSecurityContext {

    /** The principal name. */
    private String principalName;

    /** The security package. */
    private String securityPackage;

    /** The token. */
    private ManagedSecBufferDesc token;

    /** The ctx. */
    private CtxtHandle ctx;

    /** The credentials. */
    private IWindowsCredentialsHandle credentials;

    /** The continue flag. */
    private boolean continueFlag;

    @Override
    public IWindowsImpersonationContext impersonate() {
        return new WindowsSecurityContextImpersonationContextImpl(this.ctx);
    }

    @Override
    public IWindowsIdentity getIdentity() {
        final HANDLEByReference phContextToken = new HANDLEByReference();
        final int rc = Secur32.INSTANCE.QuerySecurityContextToken(this.ctx, phContextToken);
        if (WinError.SEC_E_OK != rc) {
            throw new Win32Exception(rc);
        }
        return new WindowsIdentityImpl(phContextToken.getValue());
    }

    @Override
    public String getSecurityPackage() {
        return this.securityPackage;
    }

    @Override
    public byte[] getToken() {
        return this.token == null || this.token.getBuffer(0).getBytes() == null ? null
                : this.token.getBuffer(0).getBytes().clone();
    }

    /**
     * Get the current Windows security context for a given SSPI package.
     *
     * @param securityPackage
     *            SSPI package.
     * @param targetName
     *            The target of the context. The string contents are security-package specific.
     * @return Windows security context.
     */
    public static IWindowsSecurityContext getCurrent(final String securityPackage, final String targetName) {
        IWindowsCredentialsHandle credentialsHandle = WindowsCredentialsHandleImpl.getCurrent(securityPackage);
        credentialsHandle.initialize();
        try {
            final WindowsSecurityContextImpl ctx = new WindowsSecurityContextImpl();
            ctx.setPrincipalName(WindowsAccountImpl.getCurrentUsername());
            ctx.setCredentialsHandle(credentialsHandle);
            ctx.setSecurityPackage(securityPackage);
            ctx.initialize(null, null, targetName);

            // Starting from here ctx 'owns' the credentials handle, so let's null out the
            // variable. This will prevent the finally block below from disposing it right away.
            credentialsHandle = null;

            return ctx;
        } finally {
            if (credentialsHandle != null) {
                credentialsHandle.dispose();
            }
        }
    }

    @Override
    public void initialize(final CtxtHandle continueCtx, final SecBufferDesc continueToken, final String targetName) {
        final IntByReference attr = new IntByReference();
        this.ctx = new CtxtHandle();
        int tokenSize = Sspi.MAX_TOKEN_SIZE;
        int rc;
        do {
            this.token = new ManagedSecBufferDesc(Sspi.SECBUFFER_TOKEN, tokenSize);
            rc = Secur32.INSTANCE.InitializeSecurityContext(this.credentials.getHandle(), continueCtx, targetName,
                    Sspi.ISC_REQ_CONNECTION, 0, Sspi.SECURITY_NATIVE_DREP, continueToken, 0, this.ctx, this.token, attr,
                    null);
            switch (rc) {
                case WinError.SEC_E_INSUFFICIENT_MEMORY:
                case WinError.SEC_E_BUFFER_TOO_SMALL:
                    tokenSize += Sspi.MAX_TOKEN_SIZE;
                    break;
                case WinError.SEC_I_CONTINUE_NEEDED:
                    this.continueFlag = true;
                    break;
                case WinError.SEC_E_OK:
                    this.continueFlag = false;
                    break;
                default:
                    throw new Win32Exception(rc);
            }
        } while (rc == WinError.SEC_E_INSUFFICIENT_MEMORY || rc == WinError.SEC_E_BUFFER_TOO_SMALL);
    }

    @Override
    public void dispose() {
        WindowsSecurityContextImpl.dispose(this.ctx);

        if (this.credentials != null) {
            this.credentials.dispose();
        }
    }

    /**
     * Dispose a security context.
     *
     * @param ctx
     *            Security context.
     * @return True if a context was disposed.
     */
    public static boolean dispose(final CtxtHandle ctx) {
        if (ctx != null &amp;&amp; !ctx.isNull()) {
            final int rc = Secur32.INSTANCE.DeleteSecurityContext(ctx);
            if (WinError.SEC_E_OK != rc) {
                throw new Win32Exception(rc);
            }
            return true;
        }
        return false;
    }

    @Override
    public String getPrincipalName() {
        return this.principalName;
    }

    /**
     * Sets the principal name.
     *
     * @param value
     *            the new principal name
     */
    public void setPrincipalName(final String value) {
        this.principalName = value;
    }

    @Override
    public CtxtHandle getHandle() {
        return this.ctx;
    }

    /**
     * Sets the credentials handle.
     *
     * @param handle
     *            the new credentials handle
     */
    public void setCredentialsHandle(final IWindowsCredentialsHandle handle) {
        this.credentials = handle;
    }

    /**
     * Sets the token.
     *
     * @param bytes
     *            the new token
     */
    public void setToken(final byte[] bytes) {
        this.token = new ManagedSecBufferDesc(Sspi.SECBUFFER_TOKEN, bytes);
    }

    /**
     * Sets the security package.
     *
     * @param value
     *            the new security package
     */
    public void setSecurityPackage(final String value) {
        this.securityPackage = value;
    }

    /**
     * Sets the security context.
     *
     * @param phNewServerContext
     *            the new security context
     */
    public void setSecurityContext(final CtxtHandle phNewServerContext) {
        this.ctx = phNewServerContext;
    }

    @Override
    public boolean isContinue() {
        return this.continueFlag;
    }

    /**
     * Sets the continue.
     *
     * @param b
     *            the new continue
     */
    public void setContinue(final boolean b) {
        this.continueFlag = b;
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/apache/WaffleAuthenticatorBase.java</td>
<td>waffle-tomcat10</td>
<td><a href="./xref/waffle/apache/WaffleAuthenticatorBase.html#L124">124</a></td></tr>
<tr class="b">
<td>waffle/apache/WaffleAuthenticatorBase.java</td>
<td>waffle-tomcat7</td>
<td><a href="./xref/waffle/apache/WaffleAuthenticatorBase.html#L120">120</a></td></tr>
<tr class="a">
<td>waffle/apache/WaffleAuthenticatorBase.java</td>
<td>waffle-tomcat85</td>
<td><a href="./xref/waffle/apache/WaffleAuthenticatorBase.html#L124">124</a></td></tr>
<tr class="b">
<td>waffle/apache/WaffleAuthenticatorBase.java</td>
<td>waffle-tomcat9</td>
<td><a href="./xref/waffle/apache/WaffleAuthenticatorBase.html#L124">124</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>public String getInfo() {
        return this.info;
    }

    /**
     * Set the principal format.
     *
     * @param format
     *            Principal format.
     */
    public void setPrincipalFormat(final String format) {
        this.principalFormat = PrincipalFormat.valueOf(format.toUpperCase(Locale.ENGLISH));
        this.log.debug(&quot;principal format: {}&quot;, this.principalFormat);
    }

    /**
     * Principal format.
     *
     * @return Principal format.
     */
    public PrincipalFormat getPrincipalFormat() {
        return this.principalFormat;
    }

    /**
     * Set the principal format.
     *
     * @param format
     *            Role format.
     */
    public void setRoleFormat(final String format) {
        this.roleFormat = PrincipalFormat.valueOf(format.toUpperCase(Locale.ENGLISH));
        this.log.debug(&quot;role format: {}&quot;, this.roleFormat);
    }

    /**
     * Principal format.
     *
     * @return Role format.
     */
    public PrincipalFormat getRoleFormat() {
        return this.roleFormat;
    }

    /**
     * True if Guest login permitted.
     *
     * @return True if Guest login permitted, false otherwise.
     */
    public boolean isAllowGuestLogin() {
        return this.allowGuestLogin;
    }

    /**
     * Set whether Guest login is permitted. Default is true, if the Guest account is enabled, an invalid
     * username/password results in a Guest login.
     *
     * @param value
     *            True or false.
     */
    public void setAllowGuestLogin(final boolean value) {
        this.allowGuestLogin = value;
    }

    /**
     * Set the authentication protocols. Default is &quot;Negotiate, NTLM&quot;.
     *
     * @param value
     *            Authentication protocols
     */
    public void setProtocols(final String value) {
        this.protocols = new LinkedHashSet&lt;&gt;();
        final String[] protocolNames = value.split(&quot;,&quot;, -1);
        for (String protocolName : protocolNames) {
            protocolName = protocolName.trim();
            if (!protocolName.isEmpty()) {
                this.log.debug(&quot;init protocol: {}&quot;, protocolName);
                if (WaffleAuthenticatorBase.SUPPORTED_PROTOCOLS.contains(protocolName)) {
                    this.protocols.add(protocolName);
                } else {
                    this.log.error(&quot;unsupported protocol: {}&quot;, protocolName);
                    throw new RuntimeException(&quot;Unsupported protocol: &quot; + protocolName);
                }
            }
        }
    }

    /**
     * Send a 401 Unauthorized along with protocol authentication headers.
     *
     * @param response
     *            HTTP Response
     */
    protected void sendUnauthorized(final HttpServletResponse response) {
        try {
            for (final String protocol : this.protocols) {
                response.addHeader(&quot;WWW-Authenticate&quot;, protocol);
            }
            response.setHeader(&quot;Connection&quot;, &quot;close&quot;);
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
            response.flushBuffer();
        } catch (final IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Send an error code.
     *
     * @param response
     *            HTTP Response
     * @param code
     *            Error Code
     */
    protected void sendError(final HttpServletResponse response, final int code) {
        try {
            response.sendError(code);
        } catch (final IOException e) {
            this.log.error(e.getMessage());
            this.log.trace(&quot;&quot;, e);
            throw new RuntimeException(e);
        }
    }

    @Override
    protected String getAuthMethod() {
        return null;
    }

    @Override
    protected Principal doLogin(final Request request, final String username, final String password)
            throws ServletException {
        this.log.debug(&quot;logging in: {}&quot;, username);
        IWindowsIdentity windowsIdentity;
        try {
            windowsIdentity = this.auth.logonUser(username, password);
        } catch (final Exception e) {
            this.log.error(e.getMessage());
            this.log.trace(&quot;&quot;, e);
            return super.doLogin(request, username, password);
        }
        // disable guest login
        if (!this.allowGuestLogin &amp;&amp; windowsIdentity.isGuest()) {
            this.log.warn(&quot;guest login disabled: {}&quot;, windowsIdentity.getFqn());
            return super.doLogin(request, username, password);
        }
        try {
            this.log.debug(&quot;successfully logged in {} ({})&quot;, username, windowsIdentity.getSidString());
            final GenericPrincipal genericPrincipal = this.createPrincipal(windowsIdentity);
            this.log.debug(&quot;roles: {}&quot;, String.join(&quot;, &quot;, genericPrincipal.getRoles()));
            return genericPrincipal;
        } finally {
            windowsIdentity.dispose();
        }
    }

    /**
     * This method will create an instance of a IWindowsIdentity based GenericPrincipal. It is used for creating custom
     * implementation within subclasses.
     *
     * @param windowsIdentity
     *            the windows identity to initialize the principal
     * @return the Generic Principal
     */
    protected GenericPrincipal createPrincipal(final IWindowsIdentity windowsIdentity) {
        return new GenericWindowsPrincipal(windowsIdentity, this.principalFormat, this.roleFormat);
    }

    /**
     * Hook to the start and to set up the dependencies.
     *
     * @throws LifecycleException
     *             the lifecycle exception
     */
    @Override
    public synchronized void startInternal() throws LifecycleException {
        this.log.debug(&quot;Creating a windows authentication provider with continueContextsTimeout property set to: {}&quot;,
                this.continueContextsTimeout);
        this.auth = new WindowsAuthProviderImpl(this.continueContextsTimeout);
        super.startInternal();
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat10</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L75">75</a></td></tr>
<tr class="b">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat7</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L77">77</a></td></tr>
<tr class="a">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat85</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L75">75</a></td></tr>
<tr class="b">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat9</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L75">75</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>public boolean authenticate(final Request request, final HttpServletResponse response) {

        Principal principal = request.getUserPrincipal();
        final AuthorizationHeader authorizationHeader = new AuthorizationHeader(request);
        final boolean ntlmPost = authorizationHeader.isNtlmType1PostAuthorizationHeader();

        this.log.debug(&quot;{} {}, contentlength: {}&quot;, request.getMethod(), request.getRequestURI(),
                Integer.valueOf(request.getContentLength()));
        this.log.debug(&quot;authorization: {}, ntlm post: {}&quot;, authorizationHeader, Boolean.valueOf(ntlmPost));

        if (principal != null &amp;&amp; !ntlmPost) {
            // user already authenticated
            this.log.debug(&quot;previously authenticated user: {}&quot;, principal.getName());
            return true;
        }

        // authenticate user
        if (!authorizationHeader.isNull()) {

            final String securityPackage = authorizationHeader.getSecurityPackage();
            // maintain a connection-based session for NTLM tokens
            final String connectionId = NtlmServletRequest.getConnectionId(request);

            this.log.debug(&quot;security package: {}, connection id: {}&quot;, securityPackage, connectionId);

            if (ntlmPost) {
                // type 1 NTLM authentication message received
                this.auth.resetSecurityToken(connectionId);
            }

            final byte[] tokenBuffer = authorizationHeader.getTokenBytes();
            this.log.debug(&quot;token buffer: {} byte(s)&quot;, Integer.valueOf(tokenBuffer.length));

            // log the user in using the token
            IWindowsSecurityContext securityContext;
            try {
                securityContext = this.auth.acceptSecurityToken(connectionId, tokenBuffer, securityPackage);
            } catch (final Win32Exception e) {
                this.log.warn(&quot;error logging in user: {}&quot;, e.getMessage());
                this.log.trace(&quot;&quot;, e);
                this.sendUnauthorized(response);
                return false;
            }
            this.log.debug(&quot;continue required: {}&quot;, Boolean.valueOf(securityContext.isContinue()));

            final byte[] continueTokenBytes = securityContext.getToken();
            if (continueTokenBytes != null &amp;&amp; continueTokenBytes.length &gt; 0) {
                final String continueToken = Base64.getEncoder().encodeToString(continueTokenBytes);
                this.log.debug(&quot;continue token: {}&quot;, continueToken);
                response.addHeader(&quot;WWW-Authenticate&quot;, securityPackage + &quot; &quot; + continueToken);
            }

            try {
                if (securityContext.isContinue()) {
                    response.setHeader(&quot;Connection&quot;, &quot;keep-alive&quot;);
                    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
                    response.flushBuffer();
                    return false;
                }
            } catch (final IOException e) {
                this.log.warn(&quot;error logging in user: {}&quot;, e.getMessage());
                this.log.trace(&quot;&quot;, e);
                this.sendUnauthorized(response);
                return false;
            }

            // realm: fail if no realm is configured
            if (this.context == null || this.context.getRealm() == null) {
                this.log.warn(&quot;missing context/realm&quot;);
                this.sendError(response, HttpServletResponse.SC_SERVICE_UNAVAILABLE);
                return false;
            }

            // create and register the user principal with the session
            final IWindowsIdentity windowsIdentity = securityContext.getIdentity();

            // disable guest login
            if (!this.allowGuestLogin &amp;&amp; windowsIdentity.isGuest()) {
                this.log.warn(&quot;guest login disabled: {}&quot;, windowsIdentity.getFqn());
                this.sendUnauthorized(response);
                return false;
            }

            try {
                this.log.debug(&quot;logged in user: {} ({})&quot;, windowsIdentity.getFqn(), windowsIdentity.getSidString());

                final GenericPrincipal genericPrincipal = this.createPrincipal(windowsIdentity);

                this.log.debug(&quot;roles: {}&quot;, String.join(&quot;, &quot;, genericPrincipal.getRoles()));

                principal = genericPrincipal;

                // create a session associated with this request if there's none
                final HttpSession session = request.getSession(true);
                this.log.debug(&quot;session id: {}&quot;, session == null ? &quot;null&quot; : session.getId());

                // register the authenticated principal
                this.register(request, response, principal, securityPackage, principal.getName(), null);
                this.log.info(&quot;successfully logged in user: {}&quot;, principal.getName());

            } finally {
                windowsIdentity.dispose();
                securityContext.dispose();
            }

            return true;
        }

        this.log.debug(&quot;authorization required&quot;);
        this.sendUnauthorized(response);
        return false;
    }</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/mock/http/SimpleHttpResponse.java</td>
<td>waffle-tests-jakarta</td>
<td><a href="./xref/waffle/mock/http/SimpleHttpResponse.html#L51">51</a></td></tr>
<tr class="b">
<td>waffle/mock/http/SimpleHttpResponse.java</td>
<td>waffle-tests</td>
<td><a href="./xref/waffle/mock/http/SimpleHttpResponse.html#L51">51</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>public class SimpleHttpResponse extends HttpServletResponseWrapper {

    /** The Constant LOGGER. */
    private static final Logger LOGGER = LoggerFactory.getLogger(SimpleHttpResponse.class);

    /** The status. */
    private int status = 500;

    /** The headers. */
    private final Map&lt;String, List&lt;String&gt;&gt; headers = new HashMap&lt;&gt;();

    /** The bytes. */
    final ByteArrayOutputStream bytes = new ByteArrayOutputStream();

    /** The out. */
    private final ServletOutputStream out = new ServletOutputStream() {
        @Override
        public void write(final int b) throws IOException {
            SimpleHttpResponse.this.bytes.write(b);
        }

        @Override
        public boolean isReady() {
            return false;
        }

        @Override
        public void setWriteListener(final WriteListener writeListener) {
            // Not used
        }
    };

    /** The writer. */
    private final PrintWriter writer = new PrintWriter(new OutputStreamWriter(this.bytes, StandardCharsets.UTF_8),
            true);

    /**
     * Instantiates a new simple http response.
     */
    public SimpleHttpResponse() {
        super(Mockito.mock(HttpServletResponse.class));
    }

    /**
     * Gets the status.
     *
     * @return the status
     */
    @Override
    public int getStatus() {
        return this.status;
    }

    @Override
    public void addHeader(final String headerName, final String headerValue) {
        List&lt;String&gt; current = this.headers.get(headerName);
        if (current == null) {
            current = new ArrayList&lt;&gt;();
        }
        current.add(headerValue);
        this.headers.put(headerName, current);
    }

    @Override
    public void setHeader(final String headerName, final String headerValue) {
        List&lt;String&gt; current = this.headers.get(headerName);
        if (current == null) {
            current = new ArrayList&lt;&gt;();
        } else {
            current.clear();
        }
        current.add(headerValue);
        this.headers.put(headerName, current);
    }

    @Override
    public void setStatus(final int value) {
        this.status = value;
    }

    /**
     * Gets the status string.
     *
     * @return the status string
     */
    public String getStatusString() {
        if (this.status == 401) {
            return &quot;Unauthorized&quot;;
        }
        return &quot;Unknown&quot;;
    }

    @Override
    public void flushBuffer() {
        SimpleHttpResponse.LOGGER.info(&quot;{}: {}&quot;, Integer.valueOf(this.status), this.getStatusString());
        for (final Map.Entry&lt;String, List&lt;String&gt;&gt; header : this.headers.entrySet()) {
            for (final String headerValue : header.getValue()) {
                SimpleHttpResponse.LOGGER.info(&quot;{}: {}&quot;, header, headerValue);
            }
        }
    }

    /**
     * Use this for testing the number of headers.
     *
     * @return int header name size.
     */
    public int getHeaderNamesSize() {
        return this.headers.size();
    }

    /**
     * Gets the header values.
     *
     * @param headerName
     *            the header name
     * @return the header values
     */
    public String[] getHeaderValues(final String headerName) {
        final List&lt;String&gt; headerValues = this.headers.get(headerName);
        return headerValues == null ? null : headerValues.toArray(new String[0]);
    }

    /**
     * Gets the header.
     *
     * @param headerName
     *            the header name
     * @return the header
     */
    @Override
    public String getHeader(final String headerName) {
        final List&lt;String&gt; headerValues = this.headers.get(headerName);
        return headerValues == null ? null : String.join(&quot;, &quot;, headerValues);
    }

    @Override
    public void sendError(final int rc, final String message) {
        this.status = rc;
    }

    @Override
    public void sendError(final int rc) {
        this.status = rc;
    }

    @Override
    public PrintWriter getWriter() {
        return this.writer;
    }

    @Override
    public ServletOutputStream getOutputStream() throws IOException {
        return this.out;
    }

    /**
     * Gets the output text.
     *
     * @return the output text
     */
    public String getOutputText() {
        this.writer.flush();
        try {
            return this.bytes.toString(StandardCharsets.UTF_8.name());
        } catch (final UnsupportedEncodingException e) {
            SimpleHttpResponse.LOGGER.error(&quot;&quot;, e);
        }
        return null;
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/mock/http/SimpleHttpRequest.java</td>
<td>waffle-tests-jakarta</td>
<td><a href="./xref/waffle/mock/http/SimpleHttpRequest.html#L43">43</a></td></tr>
<tr class="b">
<td>waffle/mock/http/SimpleHttpRequest.java</td>
<td>waffle-tests</td>
<td><a href="./xref/waffle/mock/http/SimpleHttpRequest.html#L43">43</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>public class SimpleHttpRequest extends HttpServletRequestWrapper {

    /** The remote port s. */
    private static int remotePortS = 0;

    /** The request uri. */
    private String requestURI;

    /** The query string. */
    private String queryString;

    /** The remote user. */
    private String remoteUser;

    /** The method. */
    private String method = &quot;GET&quot;;

    /** The remote host. */
    private String remoteHost;

    /** The remote addr. */
    private String remoteAddr;

    /** The remote port. */
    private int remotePort = -1;

    /** The headers. */
    private final Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();

    /** The parameters. */
    private final Map&lt;String, String&gt; parameters = new HashMap&lt;&gt;();

    /** The content. */
    private byte[] content;

    /** The session. */
    private HttpSession session = new SimpleHttpSession();

    /** The principal. */
    private Principal principal;

    /**
     * Instantiates a new simple http request.
     */
    public SimpleHttpRequest() {
        super(Mockito.mock(HttpServletRequest.class));
        this.remotePort = SimpleHttpRequest.nextRemotePort();
    }

    /**
     * Next remote port.
     *
     * @return the int
     */
    public static synchronized int nextRemotePort() {
        return ++SimpleHttpRequest.remotePortS;
    }

    /**
     * Reset remote port.
     */
    public static synchronized void resetRemotePort() {
        SimpleHttpRequest.remotePortS = 0;
    }

    /**
     * Adds the header.
     *
     * @param headerName
     *            the header name
     * @param headerValue
     *            the header value
     */
    public void addHeader(final String headerName, final String headerValue) {
        this.headers.put(headerName, headerValue);
    }

    @Override
    public String getHeader(final String headerName) {
        return this.headers.get(headerName);
    }

    @Override
    public Enumeration&lt;String&gt; getHeaderNames() {
        return Collections.enumeration(this.headers.keySet());
    }

    @Override
    public String getMethod() {
        return this.method;
    }

    @Override
    public int getContentLength() {
        return this.content == null ? -1 : this.content.length;
    }

    @Override
    public int getRemotePort() {
        return this.remotePort;
    }

    /**
     * Sets the method.
     *
     * @param methodName
     *            the new method
     */
    public void setMethod(final String methodName) {
        this.method = methodName;
    }

    /**
     * Sets the content length.
     *
     * @param length
     *            the new content length
     */
    public void setContentLength(final int length) {
        this.content = new byte[length];
    }

    /**
     * Sets the remote user.
     *
     * @param username
     *            the new remote user
     */
    public void setRemoteUser(final String username) {
        this.remoteUser = username;
    }

    @Override
    public String getRemoteUser() {
        return this.remoteUser;
    }

    @Override
    public HttpSession getSession() {
        return this.session;
    }

    @Override
    public HttpSession getSession(final boolean create) {
        if (this.session == null &amp;&amp; create) {
            this.session = new SimpleHttpSession();
        }
        return this.session;
    }

    @Override
    public String getQueryString() {
        return this.queryString;
    }

    /**
     * Sets the query string.
     *
     * @param query
     *            the new query string
     */
    public void setQueryString(final String query) {
        this.queryString = query;
        if (this.queryString != null) {
            for (final String eachParameter : this.queryString.split(&quot;[&amp;]&quot;, -1)) {
                final String[] pair = eachParameter.split(&quot;=&quot;, -1);
                final String value = pair.length == 2 ? pair[1] : &quot;&quot;;
                this.addParameter(pair[0], value);
            }
        }
    }

    /**
     * Sets the request uri.
     *
     * @param uri
     *            the new request uri
     */
    public void setRequestURI(final String uri) {
        this.requestURI = uri;
    }

    @Override
    public String getRequestURI() {
        return this.requestURI;
    }

    @Override
    public String getParameter(final String parameterName) {
        return this.parameters.get(parameterName);
    }

    /**
     * Adds the parameter.
     *
     * @param parameterName
     *            the parameter name
     * @param parameterValue
     *            the parameter value
     */
    public void addParameter(final String parameterName, final String parameterValue) {
        this.parameters.put(parameterName, parameterValue);
    }

    @Override
    public String getRemoteHost() {
        return this.remoteHost;
    }

    /**
     * Sets the remote host.
     *
     * @param value
     *            the new remote host
     */
    public void setRemoteHost(final String value) {
        this.remoteHost = value;
    }

    @Override
    public String getRemoteAddr() {
        return this.remoteAddr;
    }

    /**
     * Sets the remote addr.
     *
     * @param value
     *            the new remote addr
     */
    public void setRemoteAddr(final String value) {
        this.remoteAddr = value;
    }

    @Override
    public Principal getUserPrincipal() {
        return this.principal;
    }

    /**
     * Sets the user principal.
     *
     * @param value
     *            the new user principal
     */
    public void setUserPrincipal(final Principal value) {
        this.principal = value;
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/servlet/spi/SecurityFilterProviderCollection.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/servlet/spi/SecurityFilterProviderCollection.html#L49">49</a></td></tr>
<tr class="b">
<td>waffle/servlet/spi/SecurityFilterProviderCollection.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/servlet/spi/SecurityFilterProviderCollection.html#L49">49</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>public class SecurityFilterProviderCollection {

    /** The Constant LOGGER. */
    private static final Logger LOGGER = LoggerFactory.getLogger(SecurityFilterProviderCollection.class);

    /** The providers. */
    private final List&lt;SecurityFilterProvider&gt; providers = new ArrayList&lt;&gt;();

    /**
     * Instantiates a new security filter provider collection.
     *
     * @param providerArray
     *            the provider array
     */
    public SecurityFilterProviderCollection(final SecurityFilterProvider[] providerArray) {
        for (final SecurityFilterProvider provider : providerArray) {
            SecurityFilterProviderCollection.LOGGER.info(&quot;using '{}'&quot;, provider.getClass().getName());
            this.providers.add(provider);
        }
    }

    /**
     * Instantiates a new security filter provider collection.
     *
     * @param providerNames
     *            the provider names
     * @param auth
     *            the auth
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public SecurityFilterProviderCollection(final String[] providerNames, final IWindowsAuthProvider auth) {
        Class&lt;SecurityFilterProvider&gt; providerClass;
        Constructor&lt;SecurityFilterProvider&gt; providerConstructor;
        for (String providerName : providerNames) {
            providerName = providerName.trim();
            SecurityFilterProviderCollection.LOGGER.info(&quot;loading '{}'&quot;, providerName);
            try {
                providerClass = (Class&lt;SecurityFilterProvider&gt;) Class.forName(providerName);
                providerConstructor = providerClass.getConstructor(IWindowsAuthProvider.class);
                final SecurityFilterProvider provider = providerConstructor.newInstance(auth);
                this.providers.add(provider);
            } catch (final ClassNotFoundException e) {
                SecurityFilterProviderCollection.LOGGER.error(&quot;error loading '{}': {}&quot;, providerName, e.getMessage());
                SecurityFilterProviderCollection.LOGGER.trace(&quot;&quot;, e);
                throw new RuntimeException(e);
            } catch (final SecurityException | NoSuchMethodException | IllegalArgumentException | InstantiationException
                    | IllegalAccessException | InvocationTargetException e) {
                SecurityFilterProviderCollection.LOGGER.error(&quot;error loading '{}': {}&quot;, providerName, e.getMessage());
                SecurityFilterProviderCollection.LOGGER.trace(&quot;&quot;, e);
            }
        }
    }

    /**
     * Instantiates a new security filter provider collection.
     *
     * @param auth
     *            the auth
     */
    public SecurityFilterProviderCollection(final IWindowsAuthProvider auth) {
        this.providers.add(new NegotiateSecurityFilterProvider(auth));
        this.providers.add(new BasicSecurityFilterProvider(auth));
    }

    /**
     * Tests whether a specific security package is supported by any of the underlying providers.
     *
     * @param securityPackage
     *            Security package.
     * @return True if the security package is supported, false otherwise.
     */
    public boolean isSecurityPackageSupported(final String securityPackage) {
        return this.get(securityPackage) != null;
    }

    /**
     * Gets the.
     *
     * @param securityPackage
     *            the security package
     * @return the security filter provider
     */
    private SecurityFilterProvider get(final String securityPackage) {
        for (final SecurityFilterProvider provider : this.providers) {
            if (provider.isSecurityPackageSupported(securityPackage)) {
                return provider;
            }
        }
        return null;
    }

    /**
     * Filter.
     *
     * @param request
     *            Http Request
     * @param response
     *            Http Response
     * @return Windows Identity or NULL.
     * @throws IOException
     *             on doFilter.
     */
    public IWindowsIdentity doFilter(final HttpServletRequest request, final HttpServletResponse response)
            throws IOException {
        final AuthorizationHeader authorizationHeader = new AuthorizationHeader(request);
        final SecurityFilterProvider provider = this.get(authorizationHeader.getSecurityPackage());
        if (provider == null) {
            throw new RuntimeException(&quot;Unsupported security package: &quot; + authorizationHeader.getSecurityPackage());
        }
        try {
            return provider.doFilter(request, response);
        } catch (final Win32Exception e) {
            throw new IOException(e);
        }
    }

    /**
     * Returns true if authentication still needs to happen despite an existing principal.
     *
     * @param request
     *            Http Request
     * @return True if authentication is required.
     */
    public boolean isPrincipalException(final HttpServletRequest request) {
        for (final SecurityFilterProvider provider : this.providers) {
            if (provider.isPrincipalException(request)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Send authorization headers.
     *
     * @param response
     *            Http Response
     */
    public void sendUnauthorized(final HttpServletResponse response) {
        for (final SecurityFilterProvider provider : this.providers) {
            provider.sendUnauthorized(response);
        }
    }

    /**
     * Number of providers.
     *
     * @return Number of providers.
     */
    public int size() {
        return this.providers.size();
    }

    /**
     * Get a security provider by class name.
     *
     * @param name
     *            Class name.
     * @return A security provider instance.
     * @throws ClassNotFoundException
     *             when class not found.
     */
    public SecurityFilterProvider getByClassName(final String name) throws ClassNotFoundException {
        for (final SecurityFilterProvider provider : this.providers) {
            if (provider.getClass().getName().equals(name)) {
                return provider;
            }
        }
        throw new ClassNotFoundException(name);
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/jaas/WindowsLoginModule.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/jaas/WindowsLoginModule.html#L59">59</a></td></tr>
<tr class="b">
<td>waffle/jaas/WindowsLoginModule.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/jaas/WindowsLoginModule.html#L59">59</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>public class WindowsLoginModule implements LoginModule {

    /** The Constant LOGGER. */
    private static final Logger LOGGER = LoggerFactory.getLogger(WindowsLoginModule.class);

    /** The username. */
    private String username;

    /** The debug. */
    private boolean debug;

    /** The subject. */
    private Subject subject;

    /** The callback handler. */
    private CallbackHandler callbackHandler;

    /** The auth. */
    private IWindowsAuthProvider auth = new WindowsAuthProviderImpl();

    /** The principals. */
    private Set&lt;Principal&gt; principals;

    /** The principal format. */
    private PrincipalFormat principalFormat = PrincipalFormat.FQN;

    /** The role format. */
    private PrincipalFormat roleFormat = PrincipalFormat.FQN;

    /** The allow guest login. */
    private boolean allowGuestLogin = true;

    @Override
    public void initialize(final Subject initSubject, final CallbackHandler initCallbackHandler,
            final Map&lt;String, ?&gt; initSharedState, final Map&lt;String, ?&gt; initOptions) {

        this.subject = initSubject;
        this.callbackHandler = initCallbackHandler;

        for (final Map.Entry&lt;String, ?&gt; option : initOptions.entrySet()) {
            if (&quot;debug&quot;.equalsIgnoreCase(option.getKey())) {
                this.debug = Boolean.parseBoolean((String) option.getValue());
            } else if (&quot;principalFormat&quot;.equalsIgnoreCase(option.getKey())) {
                this.principalFormat = PrincipalFormat
                        .valueOf(((String) option.getValue()).toUpperCase(Locale.ENGLISH));
            } else if (&quot;roleFormat&quot;.equalsIgnoreCase(option.getKey())) {
                this.roleFormat = PrincipalFormat.valueOf(((String) option.getValue()).toUpperCase(Locale.ENGLISH));
            }
        }
    }

    /**
     * Use Windows SSPI to authenticate a username with a password.
     *
     * @return true, if successful
     * @throws LoginException
     *             the login exception
     */
    @Override
    public boolean login() throws LoginException {
        if (this.callbackHandler == null) {
            throw new LoginException(&quot;Missing callback to gather information from the user.&quot;);
        }

        final NameCallback usernameCallback = new NameCallback(&quot;user name: &quot;);
        final PasswordCallback passwordCallback = new PasswordCallback(&quot;password: &quot;, false);

        final Callback[] callbacks = new Callback[2];
        callbacks[0] = usernameCallback;
        callbacks[1] = passwordCallback;

        final String userName;
        final String password;

        try {
            this.callbackHandler.handle(callbacks);
            userName = usernameCallback.getName();
            password = passwordCallback.getPassword() == null ? &quot;&quot; : new String(passwordCallback.getPassword());
            passwordCallback.clearPassword();
        } catch (final IOException e) {
            WindowsLoginModule.LOGGER.trace(&quot;&quot;, e);
            throw new LoginException(e.toString());
        } catch (final UnsupportedCallbackException e) {
            WindowsLoginModule.LOGGER.trace(&quot;&quot;, e);
            throw new LoginException(&quot;Callback {} not available to gather authentication information from the user.&quot;
                    .replace(&quot;{}&quot;, e.getCallback().getClass().getName()));
        }

        IWindowsIdentity windowsIdentity;
        try {
            windowsIdentity = this.auth.logonUser(userName, password);
        } catch (final Exception e) {
            WindowsLoginModule.LOGGER.trace(&quot;&quot;, e);
            throw new LoginException(e.getMessage());
        }

        try {
            // disable guest login
            if (!this.allowGuestLogin &amp;&amp; windowsIdentity.isGuest()) {
                WindowsLoginModule.LOGGER.debug(&quot;guest login disabled: {}&quot;, windowsIdentity.getFqn());
                throw new LoginException(&quot;Guest login disabled&quot;);
            }

            this.principals = new LinkedHashSet&lt;&gt;();
            // add the main user principal to the subject principals
            this.principals.addAll(WindowsLoginModule.getUserPrincipals(windowsIdentity, this.principalFormat));
            if (this.roleFormat != PrincipalFormat.NONE) {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/jaas/WindowsLoginModule.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/jaas/WindowsLoginModule.html#L177">177</a></td></tr>
<tr class="b">
<td>waffle/jaas/WindowsLoginModule.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/jaas/WindowsLoginModule.html#L170">170</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>}

            this.username = windowsIdentity.getFqn();
            WindowsLoginModule.LOGGER.debug(&quot;successfully logged in {} ({})&quot;, this.username,
                    windowsIdentity.getSidString());
        } finally {
            windowsIdentity.dispose();
        }

        return true;
    }

    /**
     * Abort a login process.
     *
     * @return true, if successful
     * @throws LoginException
     *             the login exception
     */
    @Override
    public boolean abort() throws LoginException {
        return this.logout();
    }

    /**
     * Commit principals to the subject.
     *
     * @return true, if successful
     * @throws LoginException
     *             the login exception
     */
    @Override
    public boolean commit() throws LoginException {
        if (this.principals == null) {
            return false;
        }

        if (this.subject.isReadOnly()) {
            throw new LoginException(&quot;Subject cannot be read-only.&quot;);
        }

        final Set&lt;Principal&gt; principalsSet = this.subject.getPrincipals();
        principalsSet.addAll(this.principals);

        WindowsLoginModule.LOGGER.debug(&quot;committing {} principals&quot;,
                Integer.valueOf(this.subject.getPrincipals().size()));
        if (this.debug) {
            for (final Principal principal : principalsSet) {
                WindowsLoginModule.LOGGER.debug(&quot; principal: {}&quot;, principal.getName());
            }
        }

        return true;
    }

    /**
     * Logout a user.
     *
     * @return true, if successful
     * @throws LoginException
     *             the login exception
     */
    @Override
    public boolean logout() throws LoginException {
        if (this.subject.isReadOnly()) {
            throw new LoginException(&quot;Subject cannot be read-only.&quot;);
        }

        this.subject.getPrincipals().clear();

        if (this.username != null) {
            WindowsLoginModule.LOGGER.debug(&quot;logging out {}&quot;, this.username);
        }

        return true;
    }

    /**
     * True if Debug is enabled.
     *
     * @return True or false.
     */
    public boolean isDebug() {
        return this.debug;
    }

    /**
     * Windows auth provider.
     *
     * @return IWindowsAuthProvider.
     */
    public IWindowsAuthProvider getAuth() {
        return this.auth;
    }

    /**
     * Set Windows auth provider.
     *
     * @param provider
     *            Class implements IWindowsAuthProvider.
     */
    public void setAuth(final IWindowsAuthProvider provider) {
        this.auth = provider;
    }

    /**
     * Returns a list of user principal objects.
     *
     * @param windowsIdentity
     *            Windows identity.
     * @param principalFormat
     *            Principal format.
     * @return A list of user principal objects.
     */
    private static List&lt;Principal&gt; getUserPrincipals(final IWindowsIdentity windowsIdentity,
            final PrincipalFormat principalFormat) {

        final List&lt;Principal&gt; principalsList = new ArrayList&lt;&gt;();
        switch (principalFormat) {
            case FQN:
                principalsList.add(new UserPrincipal(windowsIdentity.getFqn()));
                break;
            case SID:
                principalsList.add(new UserPrincipal(windowsIdentity.getSidString()));
                break;
            case BOTH:
                principalsList.add(new UserPrincipal(windowsIdentity.getFqn()));
                principalsList.add(new UserPrincipal(windowsIdentity.getSidString()));
                break;
            case NONE:
            default:
                break;
        }
        return principalsList;
    }

    /**
     * Returns a list of role principal objects.
     *
     * @param group
     *            Windows group.
     * @param principalFormat
     *            Principal format.
     * @return List of role principal objects.
     */
    private static List&lt;Principal&gt; getRolePrincipals(final IWindowsAccount group,
            final PrincipalFormat principalFormat) {

        final List&lt;Principal&gt; principalsList = new ArrayList&lt;&gt;();
        switch (principalFormat) {
            case FQN:
                principalsList.add(new RolePrincipal(group.getFqn()));
                break;
            case SID:
                principalsList.add(new RolePrincipal(group.getSidString()));
                break;
            case BOTH:
                principalsList.add(new RolePrincipal(group.getFqn()));
                principalsList.add(new RolePrincipal(group.getSidString()));
                break;
            case NONE:
                break;
            default:
                break;
        }
        return principalsList;
    }

    /**
     * True if Guest login permitted.
     *
     * @return True if Guest login permitted, false otherwise.
     */
    public boolean isAllowGuestLogin() {
        return this.allowGuestLogin;
    }

    /**
     * Set whether Guest login is permitted. Default is true, if the Guest account is enabled, an invalid
     * username/password results in a Guest login.
     *
     * @param value
     *            True or false.
     */
    public void setAllowGuestLogin(final boolean value) {
        this.allowGuestLogin = value;
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/apache/GenericWindowsPrincipal.java</td>
<td>waffle-tomcat85</td>
<td><a href="./xref/waffle/apache/GenericWindowsPrincipal.html#L43">43</a></td></tr>
<tr class="b">
<td>waffle/apache/GenericWindowsPrincipal.java</td>
<td>waffle-tomcat9</td>
<td><a href="./xref/waffle/apache/GenericWindowsPrincipal.html#L43">43</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>public class GenericWindowsPrincipal extends GenericPrincipal {

    /** The Constant serialVersionUID. */
    private static final long serialVersionUID = 1L;

    /** The sid. */
    private final byte[] sid;

    /** The sid string. */
    private final String sidString;

    /** The groups. */
    private final Map&lt;String, WindowsAccount&gt; groups;

    /**
     * A windows principal.
     *
     * @param windowsIdentity
     *            Windows identity.
     * @param principalFormat
     *            Principal format.
     * @param roleFormat
     *            Role format.
     */
    public GenericWindowsPrincipal(final IWindowsIdentity windowsIdentity, final PrincipalFormat principalFormat,
            final PrincipalFormat roleFormat) {
        super(windowsIdentity.getFqn(), &quot;&quot;,
                GenericWindowsPrincipal.getRoles(windowsIdentity, principalFormat, roleFormat));
        this.sid = windowsIdentity.getSid();
        this.sidString = windowsIdentity.getSidString();
        this.groups = GenericWindowsPrincipal.getGroups(windowsIdentity.getGroups());
    }

    /**
     * Gets the roles.
     *
     * @param windowsIdentity
     *            the windows identity
     * @param principalFormat
     *            the principal format
     * @param roleFormat
     *            the role format
     * @return the roles
     */
    private static List&lt;String&gt; getRoles(final IWindowsIdentity windowsIdentity, final PrincipalFormat principalFormat,
            final PrincipalFormat roleFormat) {
        final List&lt;String&gt; roles = new ArrayList&lt;&gt;();
        roles.addAll(GenericWindowsPrincipal.getPrincipalNames(windowsIdentity, principalFormat));
        for (final IWindowsAccount group : windowsIdentity.getGroups()) {
            roles.addAll(GenericWindowsPrincipal.getRoleNames(group, roleFormat));
        }
        return roles;
    }

    /**
     * Gets the groups.
     *
     * @param groups
     *            the groups
     * @return the groups
     */
    private static Map&lt;String, WindowsAccount&gt; getGroups(final IWindowsAccount[] groups) {
        final Map&lt;String, WindowsAccount&gt; groupMap = new HashMap&lt;&gt;();
        for (final IWindowsAccount group : groups) {
            groupMap.put(group.getFqn(), new WindowsAccount(group));
        }
        return groupMap;
    }

    /**
     * Byte representation of the SID.
     *
     * @return Array of bytes.
     */
    public byte[] getSid() {
        return this.sid.clone();
    }

    /**
     * String representation of the SID.
     *
     * @return String.
     */
    public String getSidString() {
        return this.sidString;
    }

    /**
     * Windows groups that the user is a member of.
     *
     * @return A map of group names to groups.
     */
    public Map&lt;String, WindowsAccount&gt; getGroups() {
        return this.groups;
    }

    /**
     * Returns a list of role principal objects.
     *
     * @param group
     *            Windows group.
     * @param principalFormat
     *            Principal format.
     * @return List of role principal objects.
     */
    private static List&lt;String&gt; getRoleNames(final IWindowsAccount group, final PrincipalFormat principalFormat) {
        final List&lt;String&gt; principals = new ArrayList&lt;&gt;();
        switch (principalFormat) {
            case FQN:
                principals.add(group.getFqn());
                break;
            case SID:
                principals.add(group.getSidString());
                break;
            case BOTH:
                principals.add(group.getFqn());
                principals.add(group.getSidString());
                break;
            case NONE:
            default:
                break;
        }
        return principals;
    }

    /**
     * Returns a list of user principal objects.
     *
     * @param windowsIdentity
     *            Windows identity.
     * @param principalFormat
     *            Principal format.
     * @return A list of user principal objects.
     */
    private static List&lt;String&gt; getPrincipalNames(final IWindowsIdentity windowsIdentity,
            final PrincipalFormat principalFormat) {
        final List&lt;String&gt; principals = new ArrayList&lt;&gt;();
        switch (principalFormat) {
            case FQN:
                principals.add(windowsIdentity.getFqn());
                break;
            case SID:
                principals.add(windowsIdentity.getSidString());
                break;
            case BOTH:
                principals.add(windowsIdentity.getFqn());
                principals.add(windowsIdentity.getSidString());
                break;
            case NONE:
            default:
                break;
        }
        return principals;
    }

    /**
     * Get an array of roles as a string.
     *
     * @return Role1, Role2, ...
     */
    public String getRolesString() {
        return String.join(&quot;, &quot;, this.getRoles());
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/apache/GenericWindowsPrincipal.java</td>
<td>waffle-tomcat7</td>
<td><a href="./xref/waffle/apache/GenericWindowsPrincipal.html#L46">46</a></td></tr>
<tr class="b">
<td>waffle/apache/GenericWindowsPrincipal.java</td>
<td>waffle-tomcat85</td>
<td><a href="./xref/waffle/apache/GenericWindowsPrincipal.html#L49">49</a></td></tr>
<tr class="a">
<td>waffle/apache/GenericWindowsPrincipal.java</td>
<td>waffle-tomcat9</td>
<td><a href="./xref/waffle/apache/GenericWindowsPrincipal.html#L49">49</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>private final byte[] sid;

    /** The sid string. */
    private final String sidString;

    /** The groups. */
    private final Map&lt;String, WindowsAccount&gt; groups;

    /**
     * A windows principal.
     *
     * @param windowsIdentity
     *            Windows identity.
     * @param principalFormat
     *            Principal format.
     * @param roleFormat
     *            Role format.
     */
    public GenericWindowsPrincipal(final IWindowsIdentity windowsIdentity, final PrincipalFormat principalFormat,
            final PrincipalFormat roleFormat) {
        super(windowsIdentity.getFqn(), &quot;&quot;,
                GenericWindowsPrincipal.getRoles(windowsIdentity, principalFormat, roleFormat));
        this.sid = windowsIdentity.getSid();
        this.sidString = windowsIdentity.getSidString();
        this.groups = GenericWindowsPrincipal.getGroups(windowsIdentity.getGroups());
    }

    /**
     * Gets the roles.
     *
     * @param windowsIdentity
     *            the windows identity
     * @param principalFormat
     *            the principal format
     * @param roleFormat
     *            the role format
     * @return the roles
     */
    private static List&lt;String&gt; getRoles(final IWindowsIdentity windowsIdentity, final PrincipalFormat principalFormat,
            final PrincipalFormat roleFormat) {
        final List&lt;String&gt; roles = new ArrayList&lt;&gt;();
        roles.addAll(GenericWindowsPrincipal.getPrincipalNames(windowsIdentity, principalFormat));
        for (final IWindowsAccount group : windowsIdentity.getGroups()) {
            roles.addAll(GenericWindowsPrincipal.getRoleNames(group, roleFormat));
        }
        return roles;
    }

    /**
     * Gets the groups.
     *
     * @param groups
     *            the groups
     * @return the groups
     */
    private static Map&lt;String, WindowsAccount&gt; getGroups(final IWindowsAccount[] groups) {
        final Map&lt;String, WindowsAccount&gt; groupMap = new HashMap&lt;&gt;();
        for (final IWindowsAccount group : groups) {
            groupMap.put(group.getFqn(), new WindowsAccount(group));
        }
        return groupMap;
    }

    /**
     * Byte representation of the SID.
     *
     * @return Array of bytes.
     */
    public byte[] getSid() {
        return this.sid.clone();
    }

    /**
     * String representation of the SID.
     *
     * @return String.
     */
    public String getSidString() {
        return this.sidString;
    }

    /**
     * Windows groups that the user is a member of.
     *
     * @return A map of group names to groups.
     */
    public Map&lt;String, WindowsAccount&gt; getGroups() {
        return this.groups;
    }

    /**
     * Returns a list of role principal objects.
     *
     * @param group
     *            Windows group.
     * @param principalFormat
     *            Principal format.
     * @return List of role principal objects.
     */
    private static List&lt;String&gt; getRoleNames(final IWindowsAccount group, final PrincipalFormat principalFormat) {
        final List&lt;String&gt; principals = new ArrayList&lt;&gt;();
        switch (principalFormat) {
            case FQN:
                principals.add(group.getFqn());
                break;
            case SID:
                principals.add(group.getSidString());
                break;
            case BOTH:
                principals.add(group.getFqn());
                principals.add(group.getSidString());
                break;
            case NONE:
            default:
                break;
        }
        return principals;
    }

    /**
     * Returns a list of user principal objects.
     *
     * @param windowsIdentity
     *            Windows identity.
     * @param principalFormat
     *            Principal format.
     * @return A list of user principal objects.
     */
    private static List&lt;String&gt; getPrincipalNames(final IWindowsIdentity windowsIdentity,
            final PrincipalFormat principalFormat) {
        final List&lt;String&gt; principals = new ArrayList&lt;&gt;();
        switch (principalFormat) {
            case FQN:
                principals.add(windowsIdentity.getFqn());
                break;
            case SID:
                principals.add(windowsIdentity.getSidString());
                break;
            case BOTH:
                principals.add(windowsIdentity.getFqn());
                principals.add(windowsIdentity.getSidString());
                break;
            case NONE:
            default:
                break;
        }
        return principals;
    }

    /**
     * Get an array of roles as a string.
     *
     * @return Role1, Role2, ...
     */
    public String getRolesString() {
        return String.join(&quot;, &quot;, this.getRoles());
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/util/AuthorizationHeader.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/util/AuthorizationHeader.html#L39">39</a></td></tr>
<tr class="a">
<td>waffle/util/AuthorizationHeader.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/util/AuthorizationHeader.html#L39">39</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class AuthorizationHeader {

    /** The logger. */
    private static final Logger LOGGER = LoggerFactory.getLogger(AuthorizationHeader.class);

    /** The request. */
    private final HttpServletRequest request;

    /**
     * Instantiates a new authorization header.
     *
     * @param httpServletRequest
     *            the http servlet request
     */
    public AuthorizationHeader(final HttpServletRequest httpServletRequest) {
        this.request = httpServletRequest;
    }

    /**
     * Gets the header.
     *
     * @return the header
     */
    public String getHeader() {
        return this.request.getHeader(&quot;Authorization&quot;);
    }

    /**
     * Checks if is null.
     *
     * @return true, if is null
     */
    public boolean isNull() {
        return this.getHeader() == null || this.getHeader().length() == 0;
    }

    /**
     * Returns a supported security package string.
     *
     * Authorization: NTLM the_token Authorization: Negotiate the_token Authorization: Bearer the_token
     *
     * @return AuthenticationScheme as SecurityPackage e.g. Negotiate, NTLM, Bearer.
     */
    public String getSecurityPackage() {
        final String header = this.getHeader();

        if (header == null) {
            throw new RuntimeException(&quot;Missing Authorization: header&quot;);
        }

        final int space = header.indexOf(' ');
        if (space &gt; 0) {
            return header.substring(0, space);
        }

        throw new RuntimeException(&quot;Invalid Authorization header: &quot; + header);
    }

    @Override
    public String toString() {
        return this.isNull() ? &quot;&lt;none&gt;&quot; : this.getHeader();
    }

    /**
     * Gets the token.
     *
     * @return the token
     */
    public String getToken() {
        return this.getHeader().substring(this.getSecurityPackage().length() + 1);
    }

    /**
     * Gets the token bytes.
     *
     * @return the token bytes
     */
    public byte[] getTokenBytes() {
        try {
            return Base64.getDecoder().decode(this.getToken());
        } catch (final IllegalArgumentException e) {
            AuthorizationHeader.LOGGER.debug(&quot;&quot;, e);
            throw new RuntimeException(&quot;Invalid authorization header.&quot;);
        }
    }

    /**
     * Checks if is ntlm type1 message.
     *
     * @return true, if is ntlm type1 message
     */
    public boolean isNtlmType1Message() {
        if (this.isNull()) {
            return false;
        }

        final byte[] tokenBytes = this.getTokenBytes();
        if (!NtlmMessage.isNtlmMessage(tokenBytes)) {
            return false;
        }

        return 1 == NtlmMessage.getMessageType(tokenBytes);
    }

    /**
     * Checks if is SP nego message.
     *
     * @return true, if is SP nego message that contains NegTokenInit
     */
    public boolean isSPNegTokenInitMessage() {

        if (this.isNull()) {
            return false;
        }

        final byte[] tokenBytes = this.getTokenBytes();
        return SPNegoMessage.isNegTokenInit(tokenBytes);
    }

    /**
     * When using NTLM authentication and the browser is making a POST request, it preemptively sends a Type 2
     * authentication message (without the POSTed data). The server responds with a 401, and the browser sends a Type 3
     * request with the POSTed data. This is to avoid the situation where user's credentials might be potentially
     * invalid, and all this data is being POSTed across the wire.
     *
     * @return True if request is an NTLM POST, PUT, or DELETE with an Authorization header and no data.
     */
    public boolean isNtlmType1PostAuthorizationHeader() {
        if (!&quot;POST&quot;.equals(this.request.getMethod()) &amp;&amp; !&quot;PUT&quot;.equals(this.request.getMethod())
                &amp;&amp; !&quot;DELETE&quot;.equals(this.request.getMethod())) {
            return false;
        }

        if (this.request.getContentLength() != 0) {
            return false;
        }

        return this.isNtlmType1Message() || this.isSPNegTokenInitMessage();
    }

    public boolean isBearerAuthorizationHeader() {
        if (this.isNull()) {
            return false;
        }

        return this.getSecurityPackage().toUpperCase(Locale.ENGLISH).equalsIgnoreCase(&quot;BEARER&quot;);
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/apache/GenericWindowsPrincipal.java</td>
<td>waffle-tomcat10</td>
<td><a href="./xref/waffle/apache/GenericWindowsPrincipal.html#L69">69</a></td></tr>
<tr class="a">
<td>waffle/apache/GenericWindowsPrincipal.java</td>
<td>waffle-tomcat7</td>
<td><a href="./xref/waffle/apache/GenericWindowsPrincipal.html#L66">66</a></td></tr>
<tr class="b">
<td>waffle/apache/GenericWindowsPrincipal.java</td>
<td>waffle-tomcat85</td>
<td><a href="./xref/waffle/apache/GenericWindowsPrincipal.html#L69">69</a></td></tr>
<tr class="a">
<td>waffle/apache/GenericWindowsPrincipal.java</td>
<td>waffle-tomcat9</td>
<td><a href="./xref/waffle/apache/GenericWindowsPrincipal.html#L69">69</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>super(windowsIdentity.getFqn(), GenericWindowsPrincipal.getRoles(windowsIdentity, principalFormat, roleFormat));
        this.sid = windowsIdentity.getSid();
        this.sidString = windowsIdentity.getSidString();
        this.groups = GenericWindowsPrincipal.getGroups(windowsIdentity.getGroups());
    }

    /**
     * Gets the roles.
     *
     * @param windowsIdentity
     *            the windows identity
     * @param principalFormat
     *            the principal format
     * @param roleFormat
     *            the role format
     * @return the roles
     */
    private static List&lt;String&gt; getRoles(final IWindowsIdentity windowsIdentity, final PrincipalFormat principalFormat,
            final PrincipalFormat roleFormat) {
        final List&lt;String&gt; roles = new ArrayList&lt;&gt;();
        roles.addAll(GenericWindowsPrincipal.getPrincipalNames(windowsIdentity, principalFormat));
        for (final IWindowsAccount group : windowsIdentity.getGroups()) {
            roles.addAll(GenericWindowsPrincipal.getRoleNames(group, roleFormat));
        }
        return roles;
    }

    /**
     * Gets the groups.
     *
     * @param groups
     *            the groups
     * @return the groups
     */
    private static Map&lt;String, WindowsAccount&gt; getGroups(final IWindowsAccount[] groups) {
        final Map&lt;String, WindowsAccount&gt; groupMap = new HashMap&lt;&gt;();
        for (final IWindowsAccount group : groups) {
            groupMap.put(group.getFqn(), new WindowsAccount(group));
        }
        return groupMap;
    }

    /**
     * Byte representation of the SID.
     *
     * @return Array of bytes.
     */
    public byte[] getSid() {
        return this.sid.clone();
    }

    /**
     * String representation of the SID.
     *
     * @return String.
     */
    public String getSidString() {
        return this.sidString;
    }

    /**
     * Windows groups that the user is a member of.
     *
     * @return A map of group names to groups.
     */
    public Map&lt;String, WindowsAccount&gt; getGroups() {
        return this.groups;
    }

    /**
     * Returns a list of role principal objects.
     *
     * @param group
     *            Windows group.
     * @param principalFormat
     *            Principal format.
     * @return List of role principal objects.
     */
    private static List&lt;String&gt; getRoleNames(final IWindowsAccount group, final PrincipalFormat principalFormat) {
        final List&lt;String&gt; principals = new ArrayList&lt;&gt;();
        switch (principalFormat) {
            case FQN:
                principals.add(group.getFqn());
                break;
            case SID:
                principals.add(group.getSidString());
                break;
            case BOTH:
                principals.add(group.getFqn());
                principals.add(group.getSidString());
                break;
            case NONE:
            default:
                break;
        }
        return principals;
    }

    /**
     * Returns a list of user principal objects.
     *
     * @param windowsIdentity
     *            Windows identity.
     * @param principalFormat
     *            Principal format.
     * @return A list of user principal objects.
     */
    private static List&lt;String&gt; getPrincipalNames(final IWindowsIdentity windowsIdentity,
            final PrincipalFormat principalFormat) {
        final List&lt;String&gt; principals = new ArrayList&lt;&gt;();
        switch (principalFormat) {
            case FQN:
                principals.add(windowsIdentity.getFqn());
                break;
            case SID:
                principals.add(windowsIdentity.getSidString());
                break;
            case BOTH:
                principals.add(windowsIdentity.getFqn());
                principals.add(windowsIdentity.getSidString());
                break;
            case NONE:
            default:
                break;
        }
        return principals;
    }

    /**
     * Get an array of roles as a string.
     *
     * @return Role1, Role2, ...
     */
    public String getRolesString() {
        return String.join(&quot;, &quot;, this.getRoles());
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/windows/auth/impl/WindowsIdentityImpl.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/windows/auth/impl/WindowsIdentityImpl.html#L44">44</a></td></tr>
<tr class="a">
<td>waffle/windows/auth/impl/WindowsIdentityImpl.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/windows/auth/impl/WindowsIdentityImpl.html#L44">44</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class WindowsIdentityImpl implements IWindowsIdentity {

    /** The windows identity. */
    private final HANDLE windowsIdentity;

    /** The user groups. */
    private Account[] userGroups;

    /** The windows account. */
    private Account windowsAccount;

    /**
     * Instantiates a new windows identity impl.
     *
     * @param newWindowsIdentity
     *            the new windows identity
     */
    public WindowsIdentityImpl(final HANDLE newWindowsIdentity) {
        this.windowsIdentity = newWindowsIdentity;
    }

    /**
     * Gets the windows account.
     *
     * @return the windows account
     */
    private Account getWindowsAccount() {
        if (this.windowsAccount == null) {
            this.windowsAccount = Advapi32Util.getTokenAccount(this.windowsIdentity);
        }
        return this.windowsAccount;
    }

    /**
     * Gets the user groups.
     *
     * @return the user groups
     */
    private Account[] getUserGroups() {
        if (this.userGroups == null) {
            this.userGroups = Advapi32Util.getTokenGroups(this.windowsIdentity);
        }
        return this.userGroups.clone();
    }

    @Override
    public String getFqn() {
        return this.getWindowsAccount().fqn;
    }

    @Override
    public IWindowsAccount[] getGroups() {

        final Account[] groups = this.getUserGroups();

        final List&lt;IWindowsAccount&gt; result = new ArrayList&lt;&gt;(groups.length);
        for (final Account userGroup : groups) {
            final WindowsAccountImpl account = new WindowsAccountImpl(userGroup);
            result.add(account);
        }

        return result.toArray(new IWindowsAccount[0]);
    }

    @Override
    public byte[] getSid() {
        return this.getWindowsAccount().sid;
    }

    @Override
    public String getSidString() {
        return this.getWindowsAccount().sidString;
    }

    @Override
    public void dispose() {
        if (this.windowsIdentity != null) {
            Kernel32.INSTANCE.CloseHandle(this.windowsIdentity);
        }
    }

    @Override
    public IWindowsImpersonationContext impersonate() {
        return new WindowsIdentityImpersonationContextImpl(this.windowsIdentity);
    }

    @Override
    public boolean isGuest() {
        for (final Account userGroup : this.getUserGroups()) {
            if (Advapi32Util.isWellKnownSid(userGroup.sid, WELL_KNOWN_SID_TYPE.WinBuiltinGuestsSid)) {
                return true;
            }
            if (Advapi32Util.isWellKnownSid(userGroup.sid, WELL_KNOWN_SID_TYPE.WinAccountDomainGuestsSid)) {
                return true;
            }
            if (Advapi32Util.isWellKnownSid(userGroup.sid, WELL_KNOWN_SID_TYPE.WinAccountGuestSid)) {
                return true;
            }
        }
        return Advapi32Util.isWellKnownSid(this.getSid(), WELL_KNOWN_SID_TYPE.WinAnonymousSid);
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/servlet/WindowsPrincipal.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/servlet/WindowsPrincipal.html#L112">112</a></td></tr>
<tr class="a">
<td>waffle/servlet/WindowsPrincipal.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/servlet/WindowsPrincipal.html#L112">112</a></td></tr>
<tr class="b">
<td>waffle/apache/GenericWindowsPrincipal.java</td>
<td>waffle-tomcat10</td>
<td><a href="./xref/waffle/apache/GenericWindowsPrincipal.html#L91">91</a></td></tr>
<tr class="a">
<td>waffle/apache/GenericWindowsPrincipal.java</td>
<td>waffle-tomcat7</td>
<td><a href="./xref/waffle/apache/GenericWindowsPrincipal.html#L89">89</a></td></tr>
<tr class="b">
<td>waffle/apache/GenericWindowsPrincipal.java</td>
<td>waffle-tomcat85</td>
<td><a href="./xref/waffle/apache/GenericWindowsPrincipal.html#L92">92</a></td></tr>
<tr class="a">
<td>waffle/apache/GenericWindowsPrincipal.java</td>
<td>waffle-tomcat9</td>
<td><a href="./xref/waffle/apache/GenericWindowsPrincipal.html#L92">92</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>roles.addAll(WindowsPrincipal.getRoleNames(group, roleFormat));
        }
        return roles;
    }

    /**
     * Gets the groups.
     *
     * @param groups
     *            the groups
     * @return the groups
     */
    private static Map&lt;String, WindowsAccount&gt; getGroups(final IWindowsAccount[] groups) {
        final Map&lt;String, WindowsAccount&gt; groupMap = new HashMap&lt;&gt;();
        for (final IWindowsAccount group : groups) {
            groupMap.put(group.getFqn(), new WindowsAccount(group));
        }
        return groupMap;
    }

    /**
     * Byte representation of the SID.
     *
     * @return Array of bytes.
     */
    public byte[] getSid() {
        return this.sid.clone();
    }

    /**
     * String representation of the SID.
     *
     * @return String.
     */
    public String getSidString() {
        return this.sidString;
    }

    /**
     * Windows groups that the user is a member of.
     *
     * @return A map of group names to groups.
     */
    public Map&lt;String, WindowsAccount&gt; getGroups() {
        return this.groups;
    }

    /**
     * Returns a list of role principal objects.
     *
     * @param group
     *            Windows group.
     * @param principalFormat
     *            Principal format.
     * @return List of role principal objects.
     */
    private static List&lt;String&gt; getRoleNames(final IWindowsAccount group, final PrincipalFormat principalFormat) {
        final List&lt;String&gt; principals = new ArrayList&lt;&gt;();
        switch (principalFormat) {
            case FQN:
                principals.add(group.getFqn());
                break;
            case SID:
                principals.add(group.getSidString());
                break;
            case BOTH:
                principals.add(group.getFqn());
                principals.add(group.getSidString());
                break;
            case NONE:
            default:
                break;
        }
        return principals;
    }

    /**
     * Returns a list of user principal objects.
     *
     * @param windowsIdentity
     *            Windows identity.
     * @param principalFormat
     *            Principal format.
     * @return A list of user principal objects.
     */
    private static List&lt;String&gt; getPrincipalNames(final IWindowsIdentity windowsIdentity,
            final PrincipalFormat principalFormat) {
        final List&lt;String&gt; principals = new ArrayList&lt;&gt;();
        switch (principalFormat) {
            case FQN:
                principals.add(windowsIdentity.getFqn());
                break;
            case SID:
                principals.add(windowsIdentity.getSidString());
                break;
            case BOTH:
                principals.add(windowsIdentity.getFqn());
                principals.add(windowsIdentity.getSidString());
                break;
            case NONE:
            default:
                break;
        }
        return principals;
    }

    /**
     * Get an array of roles as a string.
     *
     * @return Role1, Role2, ...
     */
    public String getRolesString() {
        return String.join(&quot;, &quot;, this.roles);</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/mock/MockWindowsAuthProvider.java</td>
<td>waffle-tests-jakarta</td>
<td><a href="./xref/waffle/mock/MockWindowsAuthProvider.html#L45">45</a></td></tr>
<tr class="a">
<td>waffle/mock/MockWindowsAuthProvider.java</td>
<td>waffle-tests</td>
<td><a href="./xref/waffle/mock/MockWindowsAuthProvider.html#L45">45</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class MockWindowsAuthProvider implements IWindowsAuthProvider {

    /** The Constant GUEST. */
    private static final String GUEST = &quot;Guest&quot;;

    /** The groups. */
    private final List&lt;String&gt; groups = new ArrayList&lt;&gt;();

    /**
     * Instantiates a new mock windows auth provider.
     */
    public MockWindowsAuthProvider() {
        this.groups.add(&quot;Users&quot;);
        this.groups.add(&quot;Everyone&quot;);
    }

    /**
     * Adds the group.
     *
     * @param name
     *            the name
     */
    public void addGroup(final String name) {
        this.groups.add(name);
    }

    @Override
    public IWindowsSecurityContext acceptSecurityToken(final String connectionId, final byte[] token,
            final String securityPackage) {
        return new MockWindowsSecurityContext(new String(token, StandardCharsets.UTF_8));
    }

    @Override
    public IWindowsComputer getCurrentComputer() {
        return null;
    }

    @Override
    public IWindowsDomain[] getDomains() {
        return new IWindowsDomain[0];
    }

    @Override
    public IWindowsIdentity logonDomainUser(final String username, final String domain, final String password) {
        return null;
    }

    @Override
    public IWindowsIdentity logonDomainUserEx(final String username, final String domain, final String password,
            final int logonType, final int logonProvider) {
        return null;
    }

    /**
     * Will login the current user with any password. Will logon a &quot;Guest&quot; user as guest.
     *
     * @param username
     *            the username
     * @param password
     *            the password
     * @return the i windows identity
     */
    @Override
    public IWindowsIdentity logonUser(final String username, final String password) {
        final String currentUsername = Secur32Util.getUserNameEx(EXTENDED_NAME_FORMAT.NameSamCompatible);
        if (username.equals(currentUsername)) {
            return new MockWindowsIdentity(currentUsername, this.groups);
        } else if (username.equals(MockWindowsAuthProvider.GUEST)) {
            return new MockWindowsIdentity(MockWindowsAuthProvider.GUEST, this.groups);
        } else {
            throw new RuntimeException(&quot;Mock error: &quot; + username);
        }
    }

    @Override
    public IWindowsAccount lookupAccount(final String username) {
        return null;
    }

    @Override
    public void resetSecurityToken(final String connectionId) {
        // Do Nothing
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/util/SPNegoMessage.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/util/SPNegoMessage.html#L31">31</a></td></tr>
<tr class="a">
<td>waffle/util/SPNegoMessage.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/util/SPNegoMessage.html#L31">31</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public final class SPNegoMessage {

    // Check for NegTokenInit. It has always a special oid (&quot;spnegoOid&quot;),
    // which makes it rather easy to detect.
    /** The Constant SPENGO_OID. */
    private static final byte[] SPENGO_OID = { 0x06, 0x06, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x02 };

    // Check if this message is SPNEGO authentication token. There
    // are two token types, NegTokenInit and NegTokenArg.
    // For details and specification, see
    // https://msdn.microsoft.com/en-us/library/ms995330.aspx

    /**
     * Checks if is neg token init.
     *
     * @param message
     *            the message
     * @return true, if is neg token init
     */
    public static boolean isNegTokenInit(final byte[] message) {

        // Message should always contains at least some kind of
        // id byte and length. If it is too short, it
        // cannot be a SPNEGO message.
        if (message == null || message.length &lt; 2) {
            return false;
        }

        // First byte should always be 0x60 (Application Constructed Object)
        if (message[0] != 0x60) {
            return false;
        }

        // Next byte(s) contain token length, figure out
        // how many bytes are used for length data
        int lenBytes = 1;
        if ((message[1] &amp; 0x80) != 0) {
            lenBytes = 1 + (message[1] &amp; 0x7f);
        }

        if (message.length &lt; SPNegoMessage.SPENGO_OID.length + 1 + lenBytes) {
            return false;
        }

        // Now check for SPNEGO OID, which should start just after length data.
        for (int i = 0; i &lt; SPNegoMessage.SPENGO_OID.length; i++) {
            if (SPNegoMessage.SPENGO_OID[i] != message[i + 1 + lenBytes]) {
                return false;
            }
        }

        return true;
    }

    // Check for NegTokenArg. It doesn't have oid similar to NegTokenInit.
    // Instead id has one-byte id (0xa1). Obviously this is not
    // a great way to detect the message, so we check encoded
    // message length against number of received message bytes.
    /**
     * Checks if is neg token arg.
     *
     * @param message
     *            the message
     * @return true, if is neg token arg
     */
    public static boolean isNegTokenArg(final byte[] message) {

        // Message should always contains at least some kind of
        // id byte and length. If it is too short, it
        // cannot be a SPNEGO message.
        if (message == null || message.length &lt; 2) {
            return false;
        }

        // Check if this is NegTokenArg packet, it's id is 0xa1
        if ((message[0] &amp; 0xff) != 0xa1) {
            return false;
        }

        int lenBytes;
        int len;

        // Get length of message for additional check.
        if ((message[1] &amp; 0x80) == 0) {
            len = message[1];
        } else {
            lenBytes = message[1] &amp; 0x7f;
            len = 0;
            final int i = 2;
            while (lenBytes &gt; 0) {
                len = len &lt;&lt; 8;
                len |= message[i] &amp; 0xff;
                --lenBytes;
            }
        }

        return len + 2 == message.length;
    }

    /**
     * Instantiates a new SP nego message.
     */
    private SPNegoMessage() {
        // Prevent Instantiation of object
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/servlet/spi/BasicSecurityFilterProvider.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/servlet/spi/BasicSecurityFilterProvider.html#L45">45</a></td></tr>
<tr class="a">
<td>waffle/servlet/spi/BasicSecurityFilterProvider.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/servlet/spi/BasicSecurityFilterProvider.html#L45">45</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class BasicSecurityFilterProvider implements SecurityFilterProvider {

    /** The Constant LOGGER. */
    private static final Logger LOGGER = LoggerFactory.getLogger(BasicSecurityFilterProvider.class);

    /** The realm. */
    private String realm = &quot;BasicSecurityFilterProvider&quot;;

    /** The auth. */
    private final IWindowsAuthProvider auth;

    /**
     * Instantiates a new basic security filter provider.
     *
     * @param newAuthProvider
     *            the new auth provider
     */
    public BasicSecurityFilterProvider(final IWindowsAuthProvider newAuthProvider) {
        this.auth = newAuthProvider;
    }

    @Override
    public IWindowsIdentity doFilter(final HttpServletRequest request, final HttpServletResponse response)
            throws IOException {

        final AuthorizationHeader authorizationHeader = new AuthorizationHeader(request);
        final String usernamePassword = new String(authorizationHeader.getTokenBytes(), StandardCharsets.UTF_8);
        final String[] usernamePasswordArray = usernamePassword.split(&quot;:&quot;, 2);
        if (usernamePasswordArray.length != 2) {
            throw new RuntimeException(&quot;Invalid username:password in Authorization header.&quot;);
        }
        BasicSecurityFilterProvider.LOGGER.debug(&quot;logging in user: {}&quot;, usernamePasswordArray[0]);
        return this.auth.logonUser(usernamePasswordArray[0], usernamePasswordArray[1]);
    }

    @Override
    public boolean isPrincipalException(final HttpServletRequest request) {
        return false;
    }

    @Override
    public boolean isSecurityPackageSupported(final String securityPackage) {
        return &quot;Basic&quot;.equalsIgnoreCase(securityPackage);
    }

    @Override
    public void sendUnauthorized(final HttpServletResponse response) {
        response.addHeader(&quot;WWW-Authenticate&quot;, &quot;Basic realm=\&quot;&quot; + this.realm + &quot;\&quot;&quot;);
    }

    /**
     * Protection space.
     *
     * @return Name of the protection space.
     */
    public String getRealm() {
        return this.realm;
    }

    /**
     * Set the protection space.
     *
     * @param value
     *            Protection space name.
     */
    public void setRealm(final String value) {
        this.realm = value;
    }

    /**
     * Init configuration parameters.
     *
     * @param parameterName
     *            the parameter name
     * @param parameterValue
     *            the parameter value
     */
    @Override
    public void initParameter(final String parameterName, final String parameterValue) {
        if (&quot;realm&quot;.equals(parameterName)) {
            this.setRealm(parameterValue);
        } else {
            throw new InvalidParameterException(parameterName);
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/mock/http/SimpleHttpSession.java</td>
<td>waffle-tests-jakarta</td>
<td><a href="./xref/waffle/mock/http/SimpleHttpSession.html#L39">39</a></td></tr>
<tr class="a">
<td>waffle/mock/http/SimpleHttpSession.java</td>
<td>waffle-tests</td>
<td><a href="./xref/waffle/mock/http/SimpleHttpSession.html#L39">39</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class SimpleHttpSession implements HttpSession {

    /** The attributes. */
    private final Map&lt;String, Object&gt; attributes = new HashMap&lt;&gt;();

    @Override
    public Object getAttribute(final String attributeName) {
        return this.attributes.get(attributeName);
    }

    @Override
    public Enumeration&lt;String&gt; getAttributeNames() {
        return null;
    }

    @Override
    public long getCreationTime() {
        return 0;
    }

    @Override
    public String getId() {
        return null;
    }

    @Override
    public long getLastAccessedTime() {
        return 0;
    }

    @Override
    public int getMaxInactiveInterval() {
        return 0;
    }

    @Override
    public ServletContext getServletContext() {
        return null;
    }

    /**
     * Simply remove this if it is ever actually removed from servlet-api
     *
     * @deprecated Remove this once servlet does.
     */
    @Deprecated
    @Override
    public HttpSessionContext getSessionContext() {
        return null;
    }

    /**
     * Simply remove this if it is ever actually removed from servlet-api
     *
     * @deprecated Remove this once servlet does.
     */
    @Deprecated
    @Override
    public Object getValue(final String arg0) {
        return null;
    }

    /**
     * Simply remove this if it is ever actually removed from servlet-api
     *
     * @deprecated Remove this once servlet does.
     */
    @Deprecated
    @Override
    public String[] getValueNames() {
        return new String[0];
    }

    @Override
    public void invalidate() {
        // Do Nothing
    }

    @Override
    public boolean isNew() {
        return false;
    }

    /**
     * Simply remove this if it is ever actually removed from servlet-api
     *
     * @deprecated Remove this once servlet does.
     */
    @Deprecated
    @Override
    public void putValue(final String arg0, final Object arg1) {
        // Do Nothing
    }

    @Override
    public void removeAttribute(final String attributeName) {
        this.attributes.remove(attributeName);
    }

    /**
     * Simply remove this if it is ever actually removed from servlet-api
     *
     * @deprecated Remove this once servlet does.
     */
    @Deprecated
    @Override
    public void removeValue(final String arg0) {
        // Do Nothing
    }

    @Override
    public void setAttribute(final String attributeName, final Object attributeValue) {
        this.attributes.put(attributeName, attributeValue);
    }

    @Override
    public void setMaxInactiveInterval(final int arg0) {
        // Do Nothing
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/windows/auth/impl/WindowsDomainImpl.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/windows/auth/impl/WindowsDomainImpl.html#L35">35</a></td></tr>
<tr class="a">
<td>waffle/windows/auth/impl/WindowsDomainImpl.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/windows/auth/impl/WindowsDomainImpl.html#L35">35</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class WindowsDomainImpl implements IWindowsDomain {

    /**
     * The Enum TrustDirection.
     */
    private enum TrustDirection {

        /** The inbound. */
        INBOUND,
        /** The outbound. */
        OUTBOUND,
        /** The bidirectional. */
        BIDIRECTIONAL
    }

    /**
     * The Enum TrustType.
     */
    private enum TrustType {

        /** The tree root. */
        TREE_ROOT,
        /** The parent child. */
        PARENT_CHILD,
        /** The cross link. */
        CROSS_LINK,
        /** The external. */
        EXTERNAL,
        /** The forest. */
        FOREST,
        /** The kerberos. */
        KERBEROS,
        /** The unknown. */
        UNKNOWN
    }

    /** The fqn. */
    private String fqn;

    /** The trust direction. */
    private TrustDirection trustDirection = TrustDirection.BIDIRECTIONAL;

    /** The trust type. */
    private TrustType trustType = TrustType.UNKNOWN;

    /**
     * Instantiates a new windows domain impl.
     *
     * @param newFqn
     *            the new fqn
     */
    public WindowsDomainImpl(final String newFqn) {
        this.fqn = newFqn;
    }

    /**
     * Instantiates a new windows domain impl.
     *
     * @param trust
     *            the trust
     */
    public WindowsDomainImpl(final DomainTrust trust) {
        // fqn
        this.fqn = trust.DnsDomainName;
        if (this.fqn == null || this.fqn.length() == 0) {
            this.fqn = trust.NetbiosDomainName;
        }
        // trust direction
        if (trust.isInbound() &amp;&amp; trust.isOutbound()) {
            this.trustDirection = TrustDirection.BIDIRECTIONAL;
        } else if (trust.isOutbound()) {
            this.trustDirection = TrustDirection.OUTBOUND;
        } else if (trust.isInbound()) {
            this.trustDirection = TrustDirection.INBOUND;
        }
        // trust type
        if (trust.isInForest()) {
            this.trustType = TrustType.FOREST;
        } else if (trust.isRoot()) {
            this.trustType = TrustType.TREE_ROOT;
        }
    }

    @Override
    public String getFqn() {
        return this.fqn;
    }

    @Override
    public String getTrustDirectionString() {
        return this.trustDirection.toString();
    }

    @Override
    public String getTrustTypeString() {
        return this.trustType.toString();
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/windows/auth/impl/WindowsCredentialsHandleImpl.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/windows/auth/impl/WindowsCredentialsHandleImpl.html#L41">41</a></td></tr>
<tr class="a">
<td>waffle/windows/auth/impl/WindowsCredentialsHandleImpl.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/windows/auth/impl/WindowsCredentialsHandleImpl.html#L41">41</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class WindowsCredentialsHandleImpl implements IWindowsCredentialsHandle {

    /** The principal name. */
    private final String principalName;

    /** The credentials type. */
    private final int credentialsType;

    /** The security package. */
    private final String securityPackage;

    /** The handle. */
    private CredHandle handle;

    /**
     * A new Windows credentials handle.
     *
     * @param newPrincipalName
     *            Principal name.
     * @param newCredentialsType
     *            Credentials type.
     * @param newSecurityPackage
     *            Security package.
     */
    public WindowsCredentialsHandleImpl(final String newPrincipalName, final int newCredentialsType,
            final String newSecurityPackage) {
        this.principalName = newPrincipalName;
        this.credentialsType = newCredentialsType;
        this.securityPackage = newSecurityPackage;
    }

    /**
     * Returns the current credentials handle.
     *
     * @param securityPackage
     *            Security package, eg. &quot;Negotiate&quot;.
     * @return A windows credentials handle
     */
    public static IWindowsCredentialsHandle getCurrent(final String securityPackage) {
        final IWindowsCredentialsHandle handle = new WindowsCredentialsHandleImpl(null, Sspi.SECPKG_CRED_OUTBOUND,
                securityPackage);
        handle.initialize();
        return handle;
    }

    /**
     * Initialize a new credentials handle.
     */
    @Override
    public void initialize() {
        this.handle = new CredHandle();
        final TimeStamp clientLifetime = new TimeStamp();
        final int rc = Secur32.INSTANCE.AcquireCredentialsHandle(this.principalName, this.securityPackage,
                this.credentialsType, null, null, null, null, this.handle, clientLifetime);
        if (WinError.SEC_E_OK != rc) {
            throw new Win32Exception(rc);
        }
    }

    /**
     * Dispose of the credentials handle.
     */
    @Override
    public void dispose() {
        if (this.handle != null &amp;&amp; !this.handle.isNull()) {
            final int rc = Secur32.INSTANCE.FreeCredentialsHandle(this.handle);
            if (WinError.SEC_E_OK != rc) {
                throw new Win32Exception(rc);
            }
        }
    }

    /**
     * Get CredHandle.
     *
     * @return the handle
     */
    @Override
    public CredHandle getHandle() {
        return this.handle;
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/servlet/WaffleInfoServlet.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/servlet/WaffleInfoServlet.html#L114">114</a></td></tr>
<tr class="a">
<td>waffle/servlet/WaffleInfoServlet.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/servlet/WaffleInfoServlet.html#L111">111</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>throw new ServletException(e);
        }
    }

    /**
     * Gets the request info.
     *
     * @param doc
     *            the doc
     * @param request
     *            the request
     * @return the request info
     */
    private Element getRequestInfo(final Document doc, final HttpServletRequest request) {
        final Element node = doc.createElement(&quot;request&quot;);

        Element value = doc.createElement(&quot;AuthType&quot;);
        value.setTextContent(request.getAuthType());
        node.appendChild(value);

        final Principal p = request.getUserPrincipal();
        if (p != null) {
            final Element child = doc.createElement(&quot;principal&quot;);
            child.setAttribute(&quot;class&quot;, p.getClass().getName());

            value = doc.createElement(&quot;name&quot;);
            value.setTextContent(p.getName());
            child.appendChild(value);

            value = doc.createElement(&quot;string&quot;);
            value.setTextContent(p.toString());
            child.appendChild(value);

            node.appendChild(child);
        }

        final List&lt;String&gt; headers = Collections.list(request.getHeaderNames());
        if (!headers.isEmpty()) {
            final Element child = doc.createElement(&quot;headers&quot;);
            for (String header : headers) {
                value = doc.createElement(header);
                value.setTextContent(request.getHeader(header));
                child.appendChild(value);
            }
            node.appendChild(child);
        }
        return node;
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/servlet/CorsAwareNegotiateSecurityFilter.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/servlet/CorsAwareNegotiateSecurityFilter.html#L45">45</a></td></tr>
<tr class="a">
<td>waffle/servlet/CorsAwareNegotiateSecurityFilter.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/servlet/CorsAwareNegotiateSecurityFilter.html#L45">45</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class CorsAwareNegotiateSecurityFilter extends NegotiateSecurityFilter implements Filter {

    /** The Constant LOGGER. */
    private static final Logger LOGGER = LoggerFactory.getLogger(CorsAwareNegotiateSecurityFilter.class);

    /**
     * Instantiates a new negotiate security filter.
     */
    public CorsAwareNegotiateSecurityFilter() {
        CorsAwareNegotiateSecurityFilter.LOGGER.info(&quot;[waffle.servlet.CorsAwareNegotiateSecurityFilter] loaded&quot;);
    }

    @Override
    public void init(final FilterConfig filterConfig) throws ServletException {
        CorsAwareNegotiateSecurityFilter.LOGGER.info(&quot;[waffle.servlet.CorsAwareNegotiateSecurityFilter] Starting&quot;);
        super.init(filterConfig);
        CorsAwareNegotiateSecurityFilter.LOGGER.info(&quot;[waffle.servlet.CorsAwareNegotiateSecurityFilter] Started&quot;);
    }

    @Override
    public void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain)
            throws IOException, ServletException {

        CorsAwareNegotiateSecurityFilter.LOGGER.info(&quot;[waffle.servlet.CorsAwareNegotiateSecurityFilter] Filtering&quot;);

        final HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        final AuthorizationHeader authorizationHeader = new AuthorizationHeader(httpServletRequest);

        if (CorsPreFlightCheck.isPreflight(httpServletRequest)) {
            CorsAwareNegotiateSecurityFilter.LOGGER.info(
                    &quot;[waffle.servlet.CorsAwareNegotiateSecurityFilter] Request is CORS preflight; continue filter chain&quot;);
            chain.doFilter(request, response);
        } else if (authorizationHeader.isBearerAuthorizationHeader()) {
            CorsAwareNegotiateSecurityFilter.LOGGER
                    .info(&quot;[waffle.servlet.CorsAwareNegotiateSecurityFilter] Request is Bearer, continue filter chain&quot;);
            chain.doFilter(request, response);
        } else {
            CorsAwareNegotiateSecurityFilter.LOGGER
                    .info(&quot;[waffle.servlet.CorsAwareNegotiateSecurityFilter] Request is Not CORS preflight&quot;);

            super.doFilter(request, response, chain);

            CorsAwareNegotiateSecurityFilter.LOGGER
                    .info(&quot;[waffle.servlet.CorsAwareNegotiateSecurityFilter] Authentication Completed&quot;);
        }
    }

    @Override
    public void destroy() {
        super.destroy();
        CorsAwareNegotiateSecurityFilter.LOGGER.info(&quot;[waffle.servlet.CorsAwareNegotiateSecurityFilter] unloaded&quot;);
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/util/CorsPreFlightCheck.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/util/CorsPreFlightCheck.html#L37">37</a></td></tr>
<tr class="a">
<td>waffle/util/CorsPreFlightCheck.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/util/CorsPreFlightCheck.html#L37">37</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public final class CorsPreFlightCheck {

    /** The logger. */
    private static final Logger LOGGER = LoggerFactory.getLogger(CorsPreFlightCheck.class);

    /** The Constant preflightAttributeValue. */
    private static final String PRE_FLIGHT_ATTRIBUTE_VALUE = &quot;PRE_FLIGHT&quot;;

    /** The Constant CORS_PRE_FLIGHT_HEADERS. */
    private static final List&lt;String&gt; CORS_PRE_FLIGHT_HEADERS = new ArrayList&lt;String&gt;() {

        /** The Constant serialVersionUID. */
        private static final long serialVersionUID = 1L;

        {
            this.add(&quot;Access-Control-Request-Method&quot;);
            this.add(&quot;Access-Control-Request-Headers&quot;);
            this.add(&quot;Origin&quot;);
        }
    };

    /**
     * Prevent Instantiation.
     */
    private CorsPreFlightCheck() {
        // Do Nothing
    }

    /**
     * Checks if is preflight.
     *
     * @param request
     *            the request
     * @return true, if is preflight
     */
    public static boolean isPreflight(final HttpServletRequest request) {

        final String corsRequestType = (String) request.getAttribute(&quot;cors.request.type&quot;);

        CorsPreFlightCheck.LOGGER
                .debug(&quot;[waffle.util.CorsPreflightCheck] Request is CORS preflight; continue filter chain&quot;);

        // Method MUST be an OPTIONS Method to be a preflight Request
        final String method = request.getMethod();
        if (method == null || !method.equalsIgnoreCase(&quot;OPTIONS&quot;)) {
            return false;
        }

        CorsPreFlightCheck.LOGGER.debug(&quot;[waffle.util.CorsPreflightCheck] check for PRE_FLIGHT Attribute&quot;);

        /**
         * Support Apache CorsFilter which would already add the Attribute cors.request.type with a value &quot;PRE_FLIGHT&quot;
         **/
        if (corsRequestType != null
                &amp;&amp; corsRequestType.equalsIgnoreCase(CorsPreFlightCheck.PRE_FLIGHT_ATTRIBUTE_VALUE)) {
            return true;
        } else {
            /*
             * it is OPTIONS and it is not an CorsFilter PRE_FLIGHT request make sure that the request contains all of
             * the CORS preflight Headers
             */
            CorsPreFlightCheck.LOGGER.debug(&quot;[waffle.util.CorsPreflightCheck] check headers&quot;);

            for (final String header : CorsPreFlightCheck.CORS_PRE_FLIGHT_HEADERS) {
                final String headerValue = request.getHeader(header);
                CorsPreFlightCheck.LOGGER.debug(&quot;[waffle.util.CorsPreflightCheck] {}&quot;, header);

                if (headerValue == null) {
                    /* one of the CORS pre-flight headers is missing */
                    return false;
                }
            }
            CorsPreFlightCheck.LOGGER.debug(&quot;[waffle.util.CorsPreflightCheck] is preflight&quot;);

            return true;
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/windows/auth/impl/WindowsComputerImpl.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/windows/auth/impl/WindowsComputerImpl.html#L40">40</a></td></tr>
<tr class="a">
<td>waffle/windows/auth/impl/WindowsComputerImpl.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/windows/auth/impl/WindowsComputerImpl.html#L40">40</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class WindowsComputerImpl implements IWindowsComputer {

    /** The computer name. */
    private final String computerName;

    /** The domain name. */
    private final String domainName;

    /**
     * Instantiates a new windows computer impl.
     *
     * @param newComputerName
     *            the new computer name
     */
    public WindowsComputerImpl(final String newComputerName) {
        this.computerName = newComputerName;
        this.domainName = Netapi32Util.getDomainName(newComputerName);
    }

    @Override
    public String getComputerName() {
        return this.computerName;
    }

    @Override
    public String[] getGroups() {
        final List&lt;String&gt; groupNames = new ArrayList&lt;&gt;();
        final LocalGroup[] groups = Netapi32Util.getLocalGroups(this.computerName);
        for (final LocalGroup group : groups) {
            groupNames.add(group.name);
        }
        return groupNames.toArray(new String[0]);
    }

    @Override
    public String getJoinStatus() {
        final int joinStatus = Netapi32Util.getJoinStatus(this.computerName);
        switch (joinStatus) {
            case LMJoin.NETSETUP_JOIN_STATUS.NetSetupDomainName:
                return &quot;NetSetupDomainName&quot;;
            case LMJoin.NETSETUP_JOIN_STATUS.NetSetupUnjoined:
                return &quot;NetSetupUnjoined&quot;;
            case LMJoin.NETSETUP_JOIN_STATUS.NetSetupWorkgroupName:
                return &quot;NetSetupWorkgroupName&quot;;
            case LMJoin.NETSETUP_JOIN_STATUS.NetSetupUnknownStatus:
                return &quot;NetSetupUnknownStatus&quot;;
            default:
                throw new RuntimeException(&quot;Unsupported join status: &quot; + joinStatus);
        }
    }

    @Override
    public String getMemberOf() {
        return this.domainName;
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/windows/auth/WindowsAccount.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/windows/auth/WindowsAccount.html#L33">33</a></td></tr>
<tr class="a">
<td>waffle/windows/auth/WindowsAccount.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/windows/auth/WindowsAccount.html#L33">33</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class WindowsAccount implements Serializable {

    /** The Constant serialVersionUID. */
    private static final long serialVersionUID = 1L;

    /** The sid string. */
    private final String sidString;

    /** The fqn. */
    private final String fqn;

    /** The name. */
    private final String name;

    /** The domain. */
    private final String domain;

    /**
     * Instantiates a new windows account.
     *
     * @param account
     *            the account
     */
    public WindowsAccount(final IWindowsAccount account) {
        this.sidString = account.getSidString();
        this.fqn = account.getFqn();
        this.name = account.getName();
        this.domain = account.getDomain();
    }

    /**
     * Gets the sid string.
     *
     * @return the sid string
     */
    public String getSidString() {
        return this.sidString;
    }

    /**
     * Gets the fqn.
     *
     * @return the fqn
     */
    public String getFqn() {
        return this.fqn;
    }

    /**
     * Gets the name.
     *
     * @return the name
     */
    public String getName() {
        return this.name;
    }

    /**
     * Gets the domain.
     *
     * @return the domain
     */
    public String getDomain() {
        return this.domain;
    }

    @Override
    public boolean equals(final Object o) {

        if (this == o) {
            return true;
        }

        if (!(o instanceof WindowsAccount)) {
            return false;
        }

        return ((WindowsAccount) o).getSidString().equals(this.getSidString());
    }

    @Override
    public int hashCode() {
        return this.getSidString().hashCode();
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/mock/MockWindowsIdentity.java</td>
<td>waffle-tests-jakarta</td>
<td><a href="./xref/waffle/mock/MockWindowsIdentity.html#L38">38</a></td></tr>
<tr class="a">
<td>waffle/mock/MockWindowsIdentity.java</td>
<td>waffle-tests</td>
<td><a href="./xref/waffle/mock/MockWindowsIdentity.html#L38">38</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class MockWindowsIdentity implements IWindowsIdentity {

    /** The fqn. */
    private final String fqn;

    /** The groups. */
    private final List&lt;String&gt; groups;

    /**
     * Instantiates a new mock windows identity.
     *
     * @param newFqn
     *            the new fqn
     * @param newGroups
     *            the new groups
     */
    public MockWindowsIdentity(final String newFqn, final List&lt;String&gt; newGroups) {
        this.fqn = newFqn;
        this.groups = newGroups;
    }

    @Override
    public String getFqn() {
        return this.fqn;
    }

    @Override
    public IWindowsAccount[] getGroups() {
        final List&lt;MockWindowsAccount&gt; groupsList = new ArrayList&lt;&gt;();
        for (final String group : this.groups) {
            groupsList.add(new MockWindowsAccount(group));
        }
        return groupsList.toArray(new IWindowsAccount[0]);
    }

    @Override
    public byte[] getSid() {
        return new byte[0];
    }

    @Override
    public String getSidString() {
        return &quot;S-&quot; + this.fqn.hashCode();
    }

    @Override
    public void dispose() {
        // Do Nothing
    }

    @Override
    public boolean isGuest() {
        return &quot;Guest&quot;.equals(this.fqn);
    }

    @Override
    public IWindowsImpersonationContext impersonate() {
        return new MockWindowsImpersonationContext();
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat10</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L150">150</a></td></tr>
<tr class="a">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat10</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L98">98</a></td></tr>
<tr class="b">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat7</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L149">149</a></td></tr>
<tr class="a">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat7</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L100">100</a></td></tr>
<tr class="b">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat85</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L150">150</a></td></tr>
<tr class="a">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat85</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L98">98</a></td></tr>
<tr class="b">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat9</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L150">150</a></td></tr>
<tr class="a">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat9</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L98">98</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>final boolean ntlmPost = authorizationHeader.isNtlmType1PostAuthorizationHeader();

        if (ntlmPost) {
            // type 1 NTLM authentication message received
            this.auth.resetSecurityToken(connectionId);
        }

        final byte[] tokenBuffer = authorizationHeader.getTokenBytes();
        this.log.debug(&quot;token buffer: {} byte(s)&quot;, Integer.valueOf(tokenBuffer.length));

        // log the user in using the token
        IWindowsSecurityContext securityContext;
        try {
            securityContext = this.auth.acceptSecurityToken(connectionId, tokenBuffer, securityPackage);
        } catch (final Win32Exception e) {
            this.log.warn(&quot;error logging in user: {}&quot;, e.getMessage());
            this.log.trace(&quot;&quot;, e);
            this.sendUnauthorized(response);
            return false;
        }
        this.log.debug(&quot;continue required: {}&quot;, Boolean.valueOf(securityContext.isContinue()));

        final byte[] continueTokenBytes = securityContext.getToken();
        if (continueTokenBytes != null &amp;&amp; continueTokenBytes.length &gt; 0) {
            final String continueToken = Base64.getEncoder().encodeToString(continueTokenBytes);
            this.log.debug(&quot;continue token: {}&quot;, continueToken);
            response.addHeader(&quot;WWW-Authenticate&quot;, securityPackage + &quot; &quot; + continueToken);
        }

        try {
            if (securityContext.isContinue() || ntlmPost) {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/mock/MockWindowsSecurityContext.java</td>
<td>waffle-tests-jakarta</td>
<td><a href="./xref/waffle/mock/MockWindowsSecurityContext.html#L41">41</a></td></tr>
<tr class="a">
<td>waffle/mock/MockWindowsSecurityContext.java</td>
<td>waffle-tests</td>
<td><a href="./xref/waffle/mock/MockWindowsSecurityContext.html#L41">41</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class MockWindowsSecurityContext implements IWindowsSecurityContext {

    /** The identity. */
    private final IWindowsIdentity identity;

    /**
     * Instantiates a new mock windows security context.
     *
     * @param username
     *            the username
     */
    public MockWindowsSecurityContext(final String username) {
        final List&lt;String&gt; groups = new ArrayList&lt;&gt;();
        groups.add(&quot;Users&quot;);
        groups.add(&quot;Everyone&quot;);
        this.identity = new MockWindowsIdentity(username, groups);
    }

    @Override
    public void dispose() {
        // Do Nothing
    }

    @Override
    public boolean isContinue() {
        return false;
    }

    @Override
    public CtxtHandle getHandle() {
        return new CtxtHandle();
    }

    @Override
    public IWindowsIdentity getIdentity() {
        return this.identity;
    }

    @Override
    public String getPrincipalName() {
        return this.identity.getFqn();
    }

    @Override
    public String getSecurityPackage() {
        return &quot;Mock&quot;;
    }

    @Override
    public byte[] getToken() {
        return new byte[0];
    }

    @Override
    public IWindowsImpersonationContext impersonate() {
        return new MockWindowsImpersonationContext();
    }

    /**
     * Initialize.
     */
    public void initialize() {
        // Do Nothing
    }

    @Override
    public void initialize(final CtxtHandle continueCtx, final SecBufferDesc continueToken,
            final String targetPrincipalName) {
        // Do Nothing
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/servlet/WaffleInfoServlet.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/servlet/WaffleInfoServlet.html#L83">83</a></td></tr>
<tr class="a">
<td>waffle/servlet/WaffleInfoServlet.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/servlet/WaffleInfoServlet.html#L79">79</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>throws IOException, ServletException {
        final WaffleInfo info = new WaffleInfo();
        try {
            final Document doc = info.getWaffleInfo();
            final Element root = doc.getDocumentElement();

            // Add the Request Information Here
            final Element http = this.getRequestInfo(doc, request);
            root.insertBefore(http, root.getFirstChild());

            // Lookup Accounts By Name
            final String[] lookup = request.getParameterValues(&quot;lookup&quot;);
            if (lookup != null) {
                for (final String name : lookup) {
                    root.appendChild(info.getLookupInfo(doc, name));
                }
            }

            // Write the XML Response
            final TransformerFactory transfac = TransformerFactory.newInstance();
            transfac.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);
            transfac.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, &quot;&quot;);

            final Transformer trans = transfac.newTransformer();
            trans.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);

            final StreamResult result = new StreamResult(response.getWriter());
            final DOMSource source = new DOMSource(doc);
            trans.transform(source, result);
            response.setContentType(&quot;application/xml&quot;);
        } catch (final ParserConfigurationException | TransformerException e) {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/mock/MockWindowsAccount.java</td>
<td>waffle-tests-jakarta</td>
<td><a href="./xref/waffle/mock/MockWindowsAccount.html#L33">33</a></td></tr>
<tr class="a">
<td>waffle/mock/MockWindowsAccount.java</td>
<td>waffle-tests</td>
<td><a href="./xref/waffle/mock/MockWindowsAccount.html#L33">33</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class MockWindowsAccount implements IWindowsAccount {

    /** The Constant TEST_USER_NAME. */
    public static final String TEST_USER_NAME = &quot;WaffleTestUser&quot;;

    /** The Constant TEST_PASSWORD. */
    public static final String TEST_PASSWORD = &quot;!WAFFLEP$$Wrd0&quot;;

    /** The fqn. */
    private final String fqn;

    /** The name. */
    private String name;

    /** The domain. */
    private String domain;

    /** The sid. */
    private final String sid;

    /**
     * Instantiates a new mock windows account.
     *
     * @param newFqn
     *            the new fqn
     */
    public MockWindowsAccount(final String newFqn) {
        this(newFqn, &quot;S-&quot; + newFqn.hashCode());
    }

    /**
     * Instantiates a new mock windows account.
     *
     * @param newFqn
     *            the new fqn
     * @param newSid
     *            the new sid
     */
    public MockWindowsAccount(final String newFqn, final String newSid) {
        this.fqn = newFqn;
        this.sid = newSid;
        final String[] userNameDomain = newFqn.split(&quot;\\\\&quot;, 2);
        if (userNameDomain.length == 2) {
            this.name = userNameDomain[1];
            this.domain = userNameDomain[0];
        } else {
            this.name = newFqn;
        }
    }

    @Override
    public String getDomain() {
        return this.domain;
    }

    @Override
    public String getFqn() {
        return this.fqn;
    }

    @Override
    public String getName() {
        return this.name;
    }

    @Override
    public String getSidString() {
        return this.sid;
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat10</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L79">79</a></td></tr>
<tr class="a">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat7</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L80">80</a></td></tr>
<tr class="b">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat85</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L79">79</a></td></tr>
<tr class="a">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat9</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L79">79</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public boolean authenticate(final Request request, final HttpServletResponse response) {

        // realm: fail if no realm is configured
        if (this.context == null || this.context.getRealm() == null) {
            this.log.warn(&quot;missing context/realm&quot;);
            this.sendError(response, HttpServletResponse.SC_SERVICE_UNAVAILABLE);
            return false;
        }

        this.log.debug(&quot;{} {}, contentlength: {}&quot;, request.getMethod(), request.getRequestURI(),
                Integer.valueOf(request.getContentLength()));

        final boolean negotiateCheck = request.getParameter(&quot;j_negotiate_check&quot;) != null;
        this.log.debug(&quot;negotiateCheck: {}&quot;, Boolean.valueOf(negotiateCheck));
        final boolean securityCheck = request.getParameter(&quot;j_security_check&quot;) != null;
        this.log.debug(&quot;securityCheck: {}&quot;, Boolean.valueOf(securityCheck));

        final Principal principal = request.getUserPrincipal();

        final AuthorizationHeader authorizationHeader = new AuthorizationHeader(request);
        final boolean ntlmPost = authorizationHeader.isNtlmType1PostAuthorizationHeader();
        this.log.debug(&quot;authorization: {}, ntlm post: {}&quot;, authorizationHeader, Boolean.valueOf(ntlmPost));</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/mock/http/SimpleFilterConfig.java</td>
<td>waffle-tests-jakarta</td>
<td><a href="./xref/waffle/mock/http/SimpleFilterConfig.html#L41">41</a></td></tr>
<tr class="a">
<td>waffle/mock/http/SimpleFilterConfig.java</td>
<td>waffle-tests</td>
<td><a href="./xref/waffle/mock/http/SimpleFilterConfig.html#L41">41</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class SimpleFilterConfig implements FilterConfig {

    /** The filter name. */
    private String filterName = &quot;Simple Filter&quot;;

    /** The parameters. */
    private final Map&lt;String, String&gt; parameters = new TreeMap&lt;&gt;();

    @Override
    public String getFilterName() {
        return this.filterName;
    }

    /**
     * Sets the filter name.
     *
     * @param value
     *            the new filter name
     */
    public void setFilterName(final String value) {
        this.filterName = value;
    }

    @Override
    public String getInitParameter(final String s) {
        return this.parameters.get(s);
    }

    @Override
    public Enumeration&lt;String&gt; getInitParameterNames() {
        final List&lt;String&gt; keys = new ArrayList&lt;&gt;();
        keys.addAll(this.parameters.keySet());
        return Collections.enumeration(keys);
    }

    @Override
    public ServletContext getServletContext() {
        return null;
    }

    /**
     * Sets the parameter.
     *
     * @param parameterName
     *            the parameter name
     * @param parameterValue
     *            the parameter value
     */
    public void setParameter(final String parameterName, final String parameterValue) {
        this.parameters.put(parameterName, parameterValue);
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/util/cache/CaffeineCache.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/util/cache/CaffeineCache.html#L42">42</a></td></tr>
<tr class="a">
<td>waffle/util/cache/CaffeineCache.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/util/cache/CaffeineCache.html#L42">42</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class CaffeineCache&lt;K, V&gt; implements Cache&lt;K, V&gt; {

    private final com.github.benmanes.caffeine.cache.Cache&lt;K, V&gt; cache;

    public CaffeineCache(@NonNegative final long timeout) {
        cache = Caffeine.newBuilder().expireAfterWrite(Duration.ofSeconds(timeout)).build();
    }

    @Override
    public V get(K key) {
        return cache.asMap().get(key);
    }

    @Override
    public void put(K key, V value) {
        cache.put(key, value);
    }

    @Override
    public void remove(K key) {
        cache.asMap().remove(key);
    }

    @Override
    public int size() {
        return cache.asMap().size();
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/windows/auth/impl/WindowsAccountImpl.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/windows/auth/impl/WindowsAccountImpl.html#L38">38</a></td></tr>
<tr class="a">
<td>waffle/windows/auth/impl/WindowsAccountImpl.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/windows/auth/impl/WindowsAccountImpl.html#L38">38</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class WindowsAccountImpl implements IWindowsAccount {

    /** The account. */
    private final Account account;

    /**
     * Windows Account.
     *
     * @param newAccount
     *            Account.
     */
    public WindowsAccountImpl(final Account newAccount) {
        this.account = newAccount;
    }

    /**
     * Windows Account.
     *
     * @param userName
     *            Fully qualified username.
     */
    public WindowsAccountImpl(final String userName) {
        this(userName, null);
    }

    /**
     * Windows Account.
     *
     * @param accountName
     *            Username, without a domain or machine.
     * @param systemName
     *            Machine name.
     */
    public WindowsAccountImpl(final String accountName, final String systemName) {
        this(Advapi32Util.getAccountByName(systemName, accountName));
    }

    /**
     * Get the SAM-compatible username of the currently logged-on user.
     *
     * @return String.
     */
    public static String getCurrentUsername() {
        return Secur32Util.getUserNameEx(EXTENDED_NAME_FORMAT.NameSamCompatible);
    }

    /**
     * Account domain.
     *
     * @return String.
     */
    @Override
    public String getDomain() {
        return this.account.domain;
    }

    @Override
    public String getFqn() {
        return this.account.fqn;
    }

    /**
     * Account name.
     *
     * @return String.
     */
    @Override
    public String getName() {
        return this.account.name;
    }

    @Override
    public String getSidString() {
        return this.account.sidString;
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/spring/NegotiateSecurityFilter.java</td>
<td>waffle-spring-security5</td>
<td><a href="./xref/waffle/spring/NegotiateSecurityFilter.html#L214">214</a></td></tr>
<tr class="a">
<td>waffle/spring/WindowsAuthenticationProvider.java</td>
<td>waffle-spring-security5</td>
<td><a href="./xref/waffle/spring/WindowsAuthenticationProvider.html#L116">116</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>}

    /**
     * Gets the principal format.
     *
     * @return the principal format
     */
    public PrincipalFormat getPrincipalFormat() {
        return this.principalFormat;
    }

    /**
     * Sets the principal format enum.
     *
     * @param value
     *            the new principal format enum
     */
    public void setPrincipalFormatEnum(final PrincipalFormat value) {
        this.principalFormat = value;
    }

    /**
     * Sets the principal format.
     *
     * @param value
     *            the new principal format
     */
    public void setPrincipalFormat(final String value) {
        this.setPrincipalFormatEnum(PrincipalFormat.valueOf(value.toUpperCase(Locale.ENGLISH)));
    }

    /**
     * Gets the role format.
     *
     * @return the role format
     */
    public PrincipalFormat getRoleFormat() {
        return this.roleFormat;
    }

    /**
     * Sets the role format enum.
     *
     * @param value
     *            the new role format enum
     */
    public void setRoleFormatEnum(final PrincipalFormat value) {
        this.roleFormat = value;
    }

    /**
     * Sets the role format.
     *
     * @param value
     *            the new role format
     */
    public void setRoleFormat(final String value) {
        this.setRoleFormatEnum(PrincipalFormat.valueOf(value.toUpperCase(Locale.ENGLISH)));
    }

    /**
     * Checks if is allow guest login.
     *
     * @return true, if is allow guest login
     */
    public boolean isAllowGuestLogin() {
        return this.allowGuestLogin;
    }

    /**
     * Sets the allow guest login.
     *
     * @param value
     *            the new allow guest login
     */
    public void setAllowGuestLogin(final boolean value) {
        this.allowGuestLogin = value;
    }

    /**
     * Enable/Disable impersonation.
     *
     * @param value
     *            true to enable impersonation, false otherwise
     */
    public void setImpersonate(final boolean value) {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/util/NtlmMessage.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/util/NtlmMessage.html#L31">31</a></td></tr>
<tr class="a">
<td>waffle/util/NtlmMessage.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/util/NtlmMessage.html#L31">31</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public final class NtlmMessage {

    // NTLM messages start with 0x4e544c4d53535000, NTLMSSP signature
    /** The Constant NTLM_SSP_SIGNATURE. */
    private static final byte[] NTLM_SSP_SIGNATURE = { 0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00 };

    /**
     * Checks if is ntlm message.
     *
     * @param message
     *            the message
     * @return true, if is ntlm message
     */
    public static boolean isNtlmMessage(final byte[] message) {
        if (message == null || message.length &lt; NtlmMessage.NTLM_SSP_SIGNATURE.length) {
            return false;
        }

        for (int i = 0; i &lt; NtlmMessage.NTLM_SSP_SIGNATURE.length; i++) {
            if (NtlmMessage.NTLM_SSP_SIGNATURE[i] != message[i]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Get NTLM message type.
     *
     * @param message
     *            Assuming a valid NTLM message.
     * @return Message type.
     */
    public static int getMessageType(final byte[] message) {
        return message[NtlmMessage.NTLM_SSP_SIGNATURE.length];
    }

    /**
     * Instantiates a new ntlm message.
     */
    private NtlmMessage() {
        // Prevent Instantiation of object
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/apache/WaffleAuthenticatorBase.java</td>
<td>waffle-tomcat10</td>
<td><a href="./xref/waffle/apache/WaffleAuthenticatorBase.html#L52">52</a></td></tr>
<tr class="a">
<td>waffle/apache/WaffleAuthenticatorBase.java</td>
<td>waffle-tomcat7</td>
<td><a href="./xref/waffle/apache/WaffleAuthenticatorBase.html#L52">52</a></td></tr>
<tr class="b">
<td>waffle/apache/WaffleAuthenticatorBase.java</td>
<td>waffle-tomcat85</td>
<td><a href="./xref/waffle/apache/WaffleAuthenticatorBase.html#L52">52</a></td></tr>
<tr class="a">
<td>waffle/apache/WaffleAuthenticatorBase.java</td>
<td>waffle-tomcat9</td>
<td><a href="./xref/waffle/apache/WaffleAuthenticatorBase.html#L52">52</a></td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>abstract class WaffleAuthenticatorBase extends AuthenticatorBase {

    /** The Constant SUPPORTED_PROTOCOLS. */
    private static final Set&lt;String&gt; SUPPORTED_PROTOCOLS = new LinkedHashSet&lt;&gt;(Arrays.asList(&quot;Negotiate&quot;, &quot;NTLM&quot;));

    /** The info. */
    protected String info;

    /** The log. */
    protected Logger log;

    /** The principal format. */
    protected PrincipalFormat principalFormat = PrincipalFormat.FQN;

    /** The role format. */
    protected PrincipalFormat roleFormat = PrincipalFormat.FQN;

    /** The allow guest login. */
    protected boolean allowGuestLogin = true;

    /** The protocols. */
    protected Set&lt;String&gt; protocols = WaffleAuthenticatorBase.SUPPORTED_PROTOCOLS;

    /** The auth continueContextsTimeout configuration. */
    protected int continueContextsTimeout = WindowsAuthProviderImpl.CONTINUE_CONTEXT_TIMEOUT;

    /** The auth. */
    protected IWindowsAuthProvider auth;

    /**
     * Gets the continue context time out configuration.
     *
     * @return the continue contexts timeout
     */
    public int getContinueContextsTimeout() {
        return this.continueContextsTimeout;
    }

    /**
     * Sets the continue context time out configuration.
     *
     * @param continueContextsTimeout
     *            the new continue contexts timeout
     */
    public void setContinueContextsTimeout(final int continueContextsTimeout) {
        this.continueContextsTimeout = continueContextsTimeout;
    }

    /**
     * Windows authentication provider.
     *
     * @return IWindowsAuthProvider.
     */
    public IWindowsAuthProvider getAuth() {
        return this.auth;
    }

    /**
     * Set Windows auth provider.
     *
     * @param provider
     *            Class implements IWindowsAuthProvider.
     */
    public void setAuth(final IWindowsAuthProvider provider) {
        this.auth = provider;
    }</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>waffle/servlet/NegotiateSecurityFilter.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/servlet/NegotiateSecurityFilter.html#L181">181</a></td></tr>
<tr class="a">
<td>waffle/servlet/NegotiateSecurityFilter.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/servlet/NegotiateSecurityFilter.html#L180">180</a></td></tr>
<tr class="b">
<td>waffle/spring/NegotiateSecurityFilter.java</td>
<td>waffle-spring-security5</td>
<td><a href="./xref/waffle/spring/NegotiateSecurityFilter.html#L110">110</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>windowsIdentity = this.providers.doFilter(request, response);
                if (windowsIdentity == null) {
                    return;
                }
            } catch (final IOException e) {
                NegotiateSecurityFilter.LOGGER.warn(&quot;error logging in user: {}&quot;, e.getMessage());
                NegotiateSecurityFilter.LOGGER.trace(&quot;&quot;, e);
                this.sendUnauthorized(response, true);
                return;
            }

            IWindowsImpersonationContext ctx = null;
            try {
                if (!this.allowGuestLogin &amp;&amp; windowsIdentity.isGuest()) {
                    NegotiateSecurityFilter.LOGGER.warn(&quot;guest login disabled: {}&quot;, windowsIdentity.getFqn());
                    this.sendUnauthorized(response, true);
                    return;
                }

                NegotiateSecurityFilter.LOGGER.debug(&quot;logged in user: {} ({})&quot;, windowsIdentity.getFqn(),
                        windowsIdentity.getSidString());

                final HttpSession session = request.getSession(true);</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/jaas/RolePrincipal.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/jaas/RolePrincipal.html#L34">34</a></td></tr>
<tr class="b">
<td>waffle/jaas/RolePrincipal.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/jaas/RolePrincipal.html#L34">34</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>public class RolePrincipal implements Principal, Serializable {

    /** The Constant serialVersionUID. */
    private static final long serialVersionUID = 1L;

    /** The fqn. */
    private final String fqn;

    /**
     * A windows principal.
     *
     * @param newFqn
     *            Fully qualified name.
     */
    public RolePrincipal(final String newFqn) {
        this.fqn = newFqn;
    }

    /**
     * Role name (Windows Group).
     *
     * @return the name
     */
    @Override
    public String getName() {
        return this.fqn;
    }

    /**
     * Role Principal Equals for FQN.
     *
     * @param o
     *            Object used for Equality Check.
     * @return true, if successful
     */
    @Override
    public boolean equals(final Object o) {

        if (this == o) {
            return true;
        }

        if (o instanceof RolePrincipal) {
            return this.getName().equals(((RolePrincipal) o).getName());
        }

        return false;
    }

    /**
     * Role Principal HashCode for FQN.
     *
     * @return the int
     */
    @Override
    public int hashCode() {
        return this.getName().hashCode();
    }

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/jaas/UserPrincipal.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/jaas/UserPrincipal.html#L34">34</a></td></tr>
<tr class="b">
<td>waffle/jaas/UserPrincipal.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/jaas/UserPrincipal.html#L34">34</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>public class UserPrincipal implements Principal, Serializable {

    /** The Constant serialVersionUID. */
    private static final long serialVersionUID = 1L;

    /** The fqn. */
    private final String fqn;

    /**
     * A user principal.
     *
     * @param newFqn
     *            Fully qualified username.
     */
    public UserPrincipal(final String newFqn) {
        this.fqn = newFqn;
    }

    /**
     * Fully qualified username.
     *
     * @return the name
     */
    @Override
    public String getName() {
        return this.fqn;
    }

    @Override
    public boolean equals(final Object o) {

        if (this == o) {
            return true;
        }

        if (o instanceof UserPrincipal) {
            return this.getName().equals(((UserPrincipal) o).getName());
        }

        return false;
    }

    @Override
    public int hashCode() {
        return this.getName().hashCode();
    }
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/util/cache/Cache.java</td>
<td>waffle-jna-jakarta</td>
<td><a href="./xref/waffle/util/cache/Cache.html#L41">41</a></td></tr>
<tr class="b">
<td>waffle/util/cache/Cache.java</td>
<td>waffle-jna</td>
<td><a href="./xref/waffle/util/cache/Cache.html#L41">41</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>public interface Cache&lt;K, V&gt; {

    /**
     * Creates a new cache with the specified timeout.
     *
     * The cache implementation is obtained using {@link ServiceLoader}. To create your own implementation, implement
     * {@link CacheSupplier} and register it using the {@code /META-INF/services/waffle.util.cache.CacheSupplier} file
     * on your classpath.
     *
     * @param timeout
     *            timeout in seconds
     * @param &lt;K&gt;
     *            the type of keys maintained by this cache
     * @param &lt;V&gt;
     *            the type of mapped values
     * @return a new cache
     * @throws NoSuchElementException
     *             if no cache can be instantiated, use {@link Exception#getSuppressed()} to obtain details.
     */
    static &lt;K, V&gt; Cache&lt;K, V&gt; newCache(int timeout) throws NoSuchElementException {
        final NoSuchElementException exception = new NoSuchElementException();
        for (CacheSupplier cacheSupplier : ServiceLoader.load(CacheSupplier.class)) {
            try {
                return cacheSupplier.newCache(timeout);
            } catch (Exception e) {
                exception.addSuppressed(e);
            }
        }
        throw exception;
    }

    /**
     * Fetches the key from the cache
     *
     * @param key
     *            the key
     * @return the corresponding value
     * @see java.util.Map#get
     */
    V get(K key);

    /**
     * Stores a binding for the key and the value in the cache
     *
     * @param key
     *            the key
     * @param value
     *            the value
     * @see java.util.Map#put
     */
    void put(K key, V value);

    /**
     * Removes the binding for the key from the cache
     *
     * @param key
     *            the key
     * @see java.util.Map#remove(Object)
     */
    void remove(K key);

    /**
     * Returns the number of bindings in this cache
     *
     * @return the size
     * @see java.util.Map#size
     */
    int size();
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat10</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L54">54</a></td></tr>
<tr class="b">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat7</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L54">54</a></td></tr>
<tr class="a">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat85</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L54">54</a></td></tr>
<tr class="b">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat9</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L54">54</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>public class MixedAuthenticator extends WaffleAuthenticatorBase {

    /**
     * Instantiates a new mixed authenticator.
     */
    public MixedAuthenticator() {
        super();
        this.log = LoggerFactory.getLogger(MixedAuthenticator.class);
        this.info = &quot;waffle.apache.MixedAuthenticator/1.0&quot;;
        this.log.debug(&quot;[waffle.apache.MixedAuthenticator] loaded&quot;);
    }

    @Override
    public synchronized void startInternal() throws LifecycleException {
        this.log.info(&quot;[waffle.apache.MixedAuthenticator] started&quot;);
        super.startInternal();
    }

    @Override
    public synchronized void stopInternal() throws LifecycleException {
        super.stopInternal();
        this.log.info(&quot;[waffle.apache.MixedAuthenticator] stopped&quot;);
    }

    @Override
    public boolean authenticate(final Request request, final HttpServletResponse response) {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat10</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L189">189</a></td></tr>
<tr class="b">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat10</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L144">144</a></td></tr>
<tr class="a">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat7</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L188">188</a></td></tr>
<tr class="b">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat7</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L146">146</a></td></tr>
<tr class="a">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat85</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L189">189</a></td></tr>
<tr class="b">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat85</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L144">144</a></td></tr>
<tr class="a">
<td>waffle/apache/MixedAuthenticator.java</td>
<td>waffle-tomcat9</td>
<td><a href="./xref/waffle/apache/MixedAuthenticator.html#L189">189</a></td></tr>
<tr class="b">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat9</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L144">144</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>this.sendUnauthorized(response);
            return false;
        }

        // create and register the user principal with the session
        final IWindowsIdentity windowsIdentity = securityContext.getIdentity();

        // disable guest login
        if (!this.allowGuestLogin &amp;&amp; windowsIdentity.isGuest()) {
            this.log.warn(&quot;guest login disabled: {}&quot;, windowsIdentity.getFqn());
            this.sendUnauthorized(response);
            return false;
        }

        try {

            this.log.debug(&quot;logged in user: {} ({})&quot;, windowsIdentity.getFqn(), windowsIdentity.getSidString());

            final GenericPrincipal genericPrincipal = this.createPrincipal(windowsIdentity);

            this.log.debug(&quot;roles: {}&quot;, String.join(&quot;, &quot;, genericPrincipal.getRoles()));</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="a">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat10</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L50">50</a></td></tr>
<tr class="b">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat7</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L51">51</a></td></tr>
<tr class="a">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat85</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L50">50</a></td></tr>
<tr class="b">
<td>waffle/apache/NegotiateAuthenticator.java</td>
<td>waffle-tomcat9</td>
<td><a href="./xref/waffle/apache/NegotiateAuthenticator.html#L50">50</a></td></tr>
<tr class="a"><td colspan='3'>
<div>
<pre>public class NegotiateAuthenticator extends WaffleAuthenticatorBase {

    /**
     * Instantiates a new negotiate authenticator.
     */
    public NegotiateAuthenticator() {
        super();
        this.log = LoggerFactory.getLogger(NegotiateAuthenticator.class);
        this.info = &quot;waffle.apache.NegotiateAuthenticator/1.0&quot;;
        this.log.debug(&quot;[waffle.apache.NegotiateAuthenticator] loaded&quot;);
    }

    @Override
    public synchronized void startInternal() throws LifecycleException {
        this.log.info(&quot;[waffle.apache.NegotiateAuthenticator] started&quot;);
        super.startInternal();
    }

    @Override
    public synchronized void stopInternal() throws LifecycleException {
        super.stopInternal();
        this.log.info(&quot;[waffle.apache.NegotiateAuthenticator] stopped&quot;);
    }

    @Override
    public boolean authenticate(final Request request, final HttpServletResponse response) {</pre></div></td></tr></table></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>&#169;      2010&#x2013;2022
<a href="https://github.com/waffle/">com.github.waffle</a>
</p>
        </div>
      </div>
    </footer>
<script>
	if(anchors) {
	  anchors.add();
	}
</script>
  </body>
</html>
