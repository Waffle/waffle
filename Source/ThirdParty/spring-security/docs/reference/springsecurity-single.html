<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Spring Security</title><link rel="stylesheet" href="css/manual.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><!--Begin Google Analytics code--><script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2728886-3");
pageTracker._setDomainName("none");
pageTracker._setAllowLinker(true);
pageTracker._trackPageview();
</script><!--End Google Analytics code--></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" title="Spring Security"><div class="titlepage"><div><div><h1 class="title"><a name="spring-security-reference-guide"></a>Spring Security</h1></div><div><h2 class="subtitle">Reference Documentation</h2></div><div><div class="authorgroup">
      <div class="author"><h3 class="author">Ben Alex</h3></div>
      <div class="author"><h3 class="author">Luke Taylor</h3></div>
    </div></div><div><p class="releaseinfo">3.0.3.RELEASE</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="part"><a href="#getting-started">I. Getting Started</a></span></dt><dd><dl><dt><span class="chapter"><a href="#introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#what-is-acegi-security">1.1. What is Spring Security?</a></span></dt><dt><span class="section"><a href="#history">1.2. History</a></span></dt><dt><span class="section"><a href="#release-numbering">1.3. Release Numbering</a></span></dt><dt><span class="section"><a href="#get-spring-security">1.4. Getting Spring Security</a></span></dt><dd><dl><dt><span class="section"><a href="#modules">1.4.1. Project Modules</a></span></dt><dt><span class="section"><a href="#get-source">1.4.2. Checking out the Source</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ns-config">2. Security Namespace Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e195">2.1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e210">2.1.1. Design of the Namespace</a></span></dt></dl></dd><dt><span class="section"><a href="#ns-getting-started">2.2. Getting Started with Security Namespace Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#ns-web-xml">2.2.1. <code class="literal">web.xml</code> Configuration</a></span></dt><dt><span class="section"><a href="#ns-minimal">2.2.2. A Minimal <code class="literal">&lt;http&gt;</code> Configuration</a></span></dt><dt><span class="section"><a href="#ns-auth-providers">2.2.3. Using other Authentication Providers</a></span></dt></dl></dd><dt><span class="section"><a href="#ns-web-advanced">2.3. Advanced Web Features</a></span></dt><dd><dl><dt><span class="section"><a href="#ns-remember-me">2.3.1. Remember-Me Authentication</a></span></dt><dt><span class="section"><a href="#ns-requires-channel">2.3.2. Adding HTTP/HTTPS Channel Security</a></span></dt><dt><span class="section"><a href="#ns-session-mgmt">2.3.3. Session Management</a></span></dt><dt><span class="section"><a href="#ns-openid">2.3.4. OpenID Support</a></span></dt><dt><span class="section"><a href="#ns-custom-filters">2.3.5. Adding in Your Own Filters</a></span></dt></dl></dd><dt><span class="section"><a href="#ns-method-security">2.4. Method Security</a></span></dt><dd><dl><dt><span class="section"><a href="#ns-global-method">2.4.1. The <code class="literal">&lt;global-method-security&gt;</code> Element</a></span></dt></dl></dd><dt><span class="section"><a href="#ns-access-manager">2.5. The Default AccessDecisionManager</a></span></dt><dd><dl><dt><span class="section"><a href="#ns-custom-access-mgr">2.5.1. Customizing the AccessDecisionManager</a></span></dt></dl></dd><dt><span class="section"><a href="#ns-auth-manager">2.6. The Authentication Manager and the Namespace</a></span></dt></dl></dd><dt><span class="chapter"><a href="#sample-apps">3. Sample Applications</a></span></dt><dd><dl><dt><span class="section"><a href="#tutorial-sample">3.1. Tutorial Sample</a></span></dt><dt><span class="section"><a href="#contacts-sample">3.2. Contacts</a></span></dt><dt><span class="section"><a href="#ldap-sample">3.3. LDAP Sample</a></span></dt><dt><span class="section"><a href="#cas-sample">3.4. CAS Sample</a></span></dt><dt><span class="section"><a href="#preauth-sample">3.5. Pre-Authentication Sample</a></span></dt></dl></dd><dt><span class="chapter"><a href="#community">4. Spring Security Community</a></span></dt><dd><dl><dt><span class="section"><a href="#jira">4.1. Issue Tracking</a></span></dt><dt><span class="section"><a href="#becoming-involved">4.2. Becoming Involved</a></span></dt><dt><span class="section"><a href="#further-info">4.3. Further Information</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#overall-architecture">II. Architecture and Implementation</a></span></dt><dd><dl><dt><span class="chapter"><a href="#technical-overview">5. Technical Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#runtime-environment">5.1. Runtime Environment</a></span></dt><dt><span class="section"><a href="#core-components">5.2. Core Components</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e733">5.2.1.  SecurityContextHolder, SecurityContext and Authentication Objects </a></span></dt><dt><span class="section"><a href="#d4e760">5.2.2. The UserDetailsService</a></span></dt><dt><span class="section"><a href="#tech-granted-authority">5.2.3. GrantedAuthority</a></span></dt><dt><span class="section"><a href="#d4e804">5.2.4. Summary</a></span></dt></dl></dd><dt><span class="section"><a href="#tech-intro-authentication">5.3. Authentication</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e836">5.3.1. What is authentication in Spring Security?</a></span></dt><dt><span class="section"><a href="#d4e871">5.3.2. Setting the SecurityContextHolder Contents Directly</a></span></dt></dl></dd><dt><span class="section"><a href="#tech-intro-web-authentication">5.4. Authentication in a Web Application</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e910">5.4.1. ExceptionTranslationFilter</a></span></dt><dt><span class="section"><a href="#tech-intro-auth-entry-point">5.4.2. AuthenticationEntryPoint</a></span></dt><dt><span class="section"><a href="#d4e923">5.4.3. Authentication Mechanism</a></span></dt><dt><span class="section"><a href="#tech-intro-sec-context-persistence">5.4.4. Storing the <code class="interfacename">SecurityContext</code> between requests</a></span></dt></dl></dd><dt><span class="section"><a href="#tech-intro-access-control">5.5. Access-Control (Authorization) in Spring Security</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e969">5.5.1. Security and AOP Advice</a></span></dt><dt><span class="section"><a href="#secure-objects">5.5.2. Secure Objects and the <code class="classname">AbstractSecurityInterceptor</code></a></span></dt></dl></dd><dt><span class="section"><a href="#localization">5.6. Localization</a></span></dt></dl></dd><dt><span class="chapter"><a href="#core-services">6. Core Services</a></span></dt><dd><dl><dt><span class="section"><a href="#core-services-authentication-manager">6.1. The <code class="interfacename">AuthenticationManager</code>,
                <code class="classname">ProviderManager</code> and
                <code class="classname">AuthenticationProvider</code>s</a></span></dt><dd><dl><dt><span class="section"><a href="#core-services-dao-provider">6.1.1. <code class="literal">DaoAuthenticationProvider</code></a></span></dt><dt><span class="section"><a href="#core-services-erasing-credentials">6.1.2. Erasing Credentials on Successful Authentication</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e1154">6.2. <code class="interfacename">UserDetailsService</code> Implementations</a></span></dt><dd><dl><dt><span class="section"><a href="#core-services-in-memory-service">6.2.1. In-Memory Authentication</a></span></dt><dt><span class="section"><a href="#core-services-jdbc-user-service">6.2.2. <code class="literal">JdbcDaoImpl</code></a></span></dt></dl></dd><dt><span class="section"><a href="#core-services-password-encoding">6.3. Password Encoding</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1203">6.3.1. What is a hash?</a></span></dt><dt><span class="section"><a href="#d4e1209">6.3.2. Adding Salt to a Hash</a></span></dt><dt><span class="section"><a href="#d4e1216">6.3.3.  Hashing and Authentication</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="#web-app-security">III. Web Application Security</a></span></dt><dd><dl><dt><span class="chapter"><a href="#security-filter-chain">7. The Security Filter Chain</a></span></dt><dd><dl><dt><span class="section"><a href="#delegating-filter-proxy">7.1. <code class="classname">DelegatingFilterProxy</code></a></span></dt><dt><span class="section"><a href="#filter-chain-proxy">7.2. <code class="classname">FilterChainProxy</code></a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1306">7.2.1. Bypassing the Filter Chain</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e1312">7.3. Filter Ordering</a></span></dt><dt><span class="section"><a href="#d4e1359">7.4. Use with other Filter-Based Frameworks</a></span></dt></dl></dd><dt><span class="chapter"><a href="#core-web-filters">8. Core Security Filters</a></span></dt><dd><dl><dt><span class="section"><a href="#filter-security-interceptor">8.1. <code class="classname">FilterSecurityInterceptor</code></a></span></dt><dt><span class="section"><a href="#exception-translation-filter">8.2. 
            <code class="classname">ExceptionTranslationFilter</code></a></span></dt><dd><dl><dt><span class="section"><a href="#auth-entry-point">8.2.1. <code class="interfacename">AuthenticationEntryPoint</code></a></span></dt><dt><span class="section"><a href="#access-denied-handler">8.2.2. <code class="interfacename">AccessDeniedHandler</code></a></span></dt></dl></dd><dt><span class="section"><a href="#security-context-persistence-filter">8.3. <code class="classname">SecurityContextPersistenceFilter</code></a></span></dt><dd><dl><dt><span class="section"><a href="#security-context-repository">8.3.1. <code class="interfacename">SecurityContextRepository</code></a></span></dt></dl></dd><dt><span class="section"><a href="#form-login-filter">8.4. <code class="classname">UsernamePasswordAuthenticationFilter</code></a></span></dt><dd><dl><dt><span class="section"><a href="#form-login-flow-handling">8.4.1. Application Flow on Authentication Success and Failure</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#basic">9. Basic and Digest Authentication</a></span></dt><dd><dl><dt><span class="section"><a href="#basic-processing-filter">9.1. <code class="classname">BasicAuthenticationFilter</code></a></span></dt><dd><dl><dt><span class="section"><a href="#basic-config">9.1.1. Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#digest-processing-filter">9.2. <code class="classname">DigestAuthenticationFilter</code></a></span></dt><dd><dl><dt><span class="section"><a href="#digest-config">9.2.1. Configuration</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#remember-me">10. Remember-Me Authentication</a></span></dt><dd><dl><dt><span class="section"><a href="#remember-me-overview">10.1. Overview</a></span></dt><dt><span class="section"><a href="#remember-me-hash-token">10.2. Simple Hash-Based Token Approach</a></span></dt><dt><span class="section"><a href="#remember-me-persistent-token">10.3. Persistent Token Approach</a></span></dt><dt><span class="section"><a href="#remember-me-impls">10.4. Remember-Me Interfaces and Implementations</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1647">10.4.1. TokenBasedRememberMeServices</a></span></dt><dt><span class="section"><a href="#d4e1671">10.4.2. PersistentTokenBasedRememberMeServices</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#session-mgmt">11. Session Management</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1691">11.1. SessionManagementFilter</a></span></dt><dt><span class="section"><a href="#d4e1706">11.2. <code class="interfacename">SessionAuthenticationStrategy</code></a></span></dt><dt><span class="section"><a href="#concurrent-sessions">11.3. Concurrency Control</a></span></dt></dl></dd><dt><span class="chapter"><a href="#anonymous">12. Anonymous Authentication</a></span></dt><dd><dl><dt><span class="section"><a href="#anonymous-overview">12.1. Overview</a></span></dt><dt><span class="section"><a href="#anonymous-config">12.2. Configuration</a></span></dt><dt><span class="section"><a href="#anonymous-auth-trust-resolver">12.3. <code class="interfacename">AuthenticationTrustResolver</code></a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#authorization">IV. Authorization</a></span></dt><dd><dl><dt><span class="chapter"><a href="#authz-arch">13. Authorization Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#authz-authorities">13.1. Authorities</a></span></dt><dt><span class="section"><a href="#authz-pre-invocation">13.2. Pre-Invocation Handling</a></span></dt><dd><dl><dt><span class="section"><a href="#authz-access-decision-manager">13.2.1. The AccessDecisionManager</a></span></dt><dt><span class="section"><a href="#authz-voting-based">13.2.2. Voting-Based AccessDecisionManager Implementations</a></span></dt></dl></dd><dt><span class="section"><a href="#authz-after-invocation-handling">13.3. After Invocation Handling</a></span></dt></dl></dd><dt><span class="chapter"><a href="#secure-object-impls">14. Secure Object Implementations</a></span></dt><dd><dl><dt><span class="section"><a href="#aop-alliance">14.1. AOP Alliance (MethodInvocation) Security Interceptor</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e2042">14.1.1. Explicit MethodSecurityInterceptor Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#aspectj">14.2. AspectJ (JoinPoint) Security Interceptor</a></span></dt></dl></dd><dt><span class="chapter"><a href="#el-access">15. Expression-Based Access Control</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e2086">15.1. Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#el-common-built-in">15.1.1. Common Built-In Expressions</a></span></dt></dl></dd><dt><span class="section"><a href="#el-access-web">15.2. Web Security Expressions</a></span></dt><dt><span class="section"><a href="#d4e2173">15.3. Method Security Expressions</a></span></dt><dd><dl><dt><span class="section"><a href="#el-pre-post-annotations">15.3.1. <code class="literal">@Pre</code> and <code class="literal">@Post</code> Annotations</a></span></dt><dt><span class="section"><a href="#el-method-built-in">15.3.2. Built-In Expressions</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="#advanced-topics">V. Additional Topics</a></span></dt><dd><dl><dt><span class="chapter"><a href="#domain-acls">16. Domain Object Security (ACLs)</a></span></dt><dd><dl><dt><span class="section"><a href="#domain-acls-overview">16.1. Overview</a></span></dt><dt><span class="section"><a href="#domain-acls-key-concepts">16.2. Key Concepts</a></span></dt><dt><span class="section"><a href="#domain-acls-getting-started">16.3. Getting Started</a></span></dt></dl></dd><dt><span class="chapter"><a href="#preauth">17. Pre-Authentication Scenarios</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e2413">17.1. Pre-Authentication Framework Classes</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e2418">17.1.1. AbstractPreAuthenticatedProcessingFilter</a></span></dt><dt><span class="section"><a href="#d4e2425">17.1.2. AbstractPreAuthenticatedAuthenticationDetailsSource</a></span></dt><dt><span class="section"><a href="#d4e2447">17.1.3. PreAuthenticatedAuthenticationProvider</a></span></dt><dt><span class="section"><a href="#d4e2459">17.1.4. Http403ForbiddenEntryPoint</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e2467">17.2. Concrete Implementations</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e2471">17.2.1. Request-Header Authentication (Siteminder)</a></span></dt><dt><span class="section"><a href="#d4e2490">17.2.2. J2EE Container Authentication</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ldap">18. LDAP Authentication</a></span></dt><dd><dl><dt><span class="section"><a href="#ldap-overview">18.1. Overview</a></span></dt><dt><span class="section"><a href="#d4e2511">18.2. Using LDAP with Spring Security</a></span></dt><dt><span class="section"><a href="#ldap-server">18.3. Configuring an LDAP Server</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e2534">18.3.1. Using an Embedded Test Server</a></span></dt><dt><span class="section"><a href="#d4e2545">18.3.2. Using Bind Authentication</a></span></dt><dt><span class="section"><a href="#d4e2555">18.3.3. Loading Authorities</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e2583">18.4. Implementation Classes</a></span></dt><dd><dl><dt><span class="section"><a href="#ldap-ldap-authenticators">18.4.1. LdapAuthenticator Implementations</a></span></dt><dt><span class="section"><a href="#ldap-context-source">18.4.2. Connecting to the LDAP Server</a></span></dt><dt><span class="section"><a href="#ldap-searchobjects">18.4.3. LDAP Search Objects</a></span></dt><dt><span class="section"><a href="#ldap-authorities">18.4.4. LdapAuthoritiesPopulator</a></span></dt><dt><span class="section"><a href="#ldap-bean-config">18.4.5. Spring Bean Configuration</a></span></dt><dt><span class="section"><a href="#ldap-custom-user-details">18.4.6. LDAP Attributes and Customized UserDetails</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#taglibs">19. JSP Tag Libraries</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e2705">19.1. Declaring the Taglib</a></span></dt><dt><span class="section"><a href="#d4e2709">19.2. The <code class="literal">authorize</code> Tag</a></span></dt><dt><span class="section"><a href="#d4e2727">19.3. The <code class="literal">authentication</code>Tag</a></span></dt><dt><span class="section"><a href="#d4e2739">19.4. The <code class="literal">accesscontrollist</code> Tag</a></span></dt></dl></dd><dt><span class="chapter"><a href="#jaas">20. Java Authentication and Authorization Service (JAAS) Provider</a></span></dt><dd><dl><dt><span class="section"><a href="#jaas-overview">20.1. Overview</a></span></dt><dt><span class="section"><a href="#jaas-config">20.2. Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#jaas-callbackhandler">20.2.1. JAAS CallbackHandler</a></span></dt><dt><span class="section"><a href="#jaas-authoritygranter">20.2.2. JAAS AuthorityGranter</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#cas">21. CAS Authentication</a></span></dt><dd><dl><dt><span class="section"><a href="#cas-overview">21.1. Overview</a></span></dt><dt><span class="section"><a href="#cas-how-it-works">21.2. How CAS Works</a></span></dt><dt><span class="section"><a href="#cas-client">21.3. Configuration of CAS Client</a></span></dt></dl></dd><dt><span class="chapter"><a href="#x509">22. X.509 Authentication</a></span></dt><dd><dl><dt><span class="section"><a href="#x509-overview">22.1. Overview</a></span></dt><dt><span class="section"><a href="#d4e2898">22.2. Adding X.509 Authentication to Your Web Application</a></span></dt><dt><span class="section"><a href="#x509-ssl-config">22.3. Setting up SSL in Tomcat</a></span></dt></dl></dd><dt><span class="chapter"><a href="#runas">23. Run-As Authentication Replacement</a></span></dt><dd><dl><dt><span class="section"><a href="#runas-overview">23.1. Overview</a></span></dt><dt><span class="section"><a href="#runas-config">23.2. Configuration</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#appendix-schema">A. Security Database Schema</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e3009">A.1. User Schema</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e3015">A.1.1. Group Authorities</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e3020">A.2. Persistent Login (Remember-Me) Schema</a></span></dt><dt><span class="section"><a href="#dbschema-acl">A.3. ACL Schema</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e3051">A.3.1. Hypersonic SQL</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#appendix-namespace">B. The Security Namespace</a></span></dt><dd><dl><dt><span class="section"><a href="#nsa-http">B.1. Web Application Security - the <code class="literal">&lt;http&gt;</code> Element</a></span></dt><dd><dl><dt><span class="section"><a href="#nsa-http-attributes">B.1.1. <code class="literal">&lt;http&gt;</code> Attributes</a></span></dt><dt><span class="section"><a href="#nsa-access-denied-handler">B.1.2. <code class="literal">&lt;access-denied-handler&gt;</code></a></span></dt><dt><span class="section"><a href="#d4e3175">B.1.3. The <code class="literal">&lt;intercept-url&gt;</code> Element</a></span></dt><dt><span class="section"><a href="#d4e3216">B.1.4. The <code class="literal">&lt;port-mappings&gt;</code> Element</a></span></dt><dt><span class="section"><a href="#nsa-form-login">B.1.5. The <code class="literal">&lt;form-login&gt;</code> Element</a></span></dt><dt><span class="section"><a href="#nsa-http-basic">B.1.6. The <code class="literal">&lt;http-basic&gt;</code> Element</a></span></dt><dt><span class="section"><a href="#nsa-remember-me">B.1.7. The <code class="literal">&lt;remember-me&gt;</code> Element</a></span></dt><dt><span class="section"><a href="#nsa-session-mgmt">B.1.8. The <code class="literal">&lt;session-management&gt;</code> Element</a></span></dt><dt><span class="section"><a href="#nsa-concurrent-session-control">B.1.9. The <code class="literal">&lt;concurrency-control&gt;</code> Element</a></span></dt><dt><span class="section"><a href="#nsa-anonymous">B.1.10. The <code class="literal">&lt;anonymous&gt;</code> Element</a></span></dt><dt><span class="section"><a href="#nsa-x509">B.1.11. The <code class="literal">&lt;x509&gt;</code> Element</a></span></dt><dt><span class="section"><a href="#nsa-openid-login">B.1.12. The <code class="literal">&lt;openid-login&gt;</code> Element</a></span></dt><dt><span class="section"><a href="#nsa-logout">B.1.13. The <code class="literal">&lt;logout&gt;</code> Element</a></span></dt><dt><span class="section"><a href="#d4e3434">B.1.14. The <code class="literal">&lt;custom-filter&gt;</code> Element</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e3439">B.2. Authentication Services</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e3447">B.2.1. The <code class="literal">&lt;authentication-manager&gt;</code> Element</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e3487">B.3. Method Security</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e3489">B.3.1. The <code class="literal">&lt;global-method-security&gt;</code> Element</a></span></dt><dt><span class="section"><a href="#d4e3527">B.3.2. LDAP Namespace Options</a></span></dt></dl></dd></dl></dd></dl></div>
  
  
  <div class="preface" title="Preface"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div></div>
    
    <p>Spring Security provides a comprehensive security solution for J2EE-based enterprise
      software applications. As you will discover as you venture through this reference guide, we
      have tried to provide you a useful and highly configurable security system.</p>
    <p>Security is an ever-moving target, and it's important to pursue a comprehensive,
      system-wide approach. In security circles we encourage you to adopt "layers of security", so
      that each layer tries to be as secure as possible in its own right, with successive layers
      providing additional security. The "tighter" the security of each layer, the more robust and
      safe your application will be. At the bottom level you'll need to deal with issues such as
      transport security and system identification, in order to mitigate man-in-the-middle attacks.
      Next you'll generally utilise firewalls, perhaps with VPNs or IP security to ensure only
      authorised systems can attempt to connect. In corporate environments you may deploy a DMZ to
      separate public-facing servers from backend database and application servers. Your operating
      system will also play a critical part, addressing issues such as running processes as
      non-privileged users and maximising file system security. An operating system will usually
      also be configured with its own firewall. Hopefully somewhere along the way you'll be trying
      to prevent denial of service and brute force attacks against the system. An intrusion
      detection system will also be especially useful for monitoring and responding to attacks, with
      such systems able to take protective action such as blocking offending TCP/IP addresses in
      real-time. Moving to the higher layers, your Java Virtual Machine will hopefully be configured
      to minimize the permissions granted to different Java types, and then your application will
      add its own problem domain-specific security configuration. Spring Security makes this latter
      area - application security - much easier. </p>
    <p>Of course, you will need to properly address all security layers mentioned above, together
      with managerial factors that encompass every layer. A non-exhaustive list of such managerial
      factors would include security bulletin monitoring, patching, personnel vetting, audits,
      change control, engineering management systems, data backup, disaster recovery, performance
      benchmarking, load monitoring, centralised logging, incident response procedures etc.</p>
    <p>With Spring Security being focused on helping you with the enterprise application security
      layer, you will find that there are as many different requirements as there are business
      problem domains. A banking application has different needs from an ecommerce application. An
      ecommerce application has different needs from a corporate sales force automation tool. These
      custom requirements make application security interesting, challenging and rewarding. </p>
    <p>Please read <a class="xref" href="#getting-started" title="Part&nbsp;I.&nbsp;Getting Started">Part&nbsp;I, &#8220;Getting Started&#8221;</a>, in its entirety to begin with. This will
      introduce you to the framework and the namespace-based configuration system with which you can
      get up and running quite quickly. To get more of an understanding of how Spring Security
      works, and some of the classes you might need to use, you should then read <a class="xref" href="#overall-architecture" title="Part&nbsp;II.&nbsp;Architecture and Implementation">Part&nbsp;II, &#8220;Architecture and Implementation&#8221;</a>. The remaining parts of this guide are structured in a more
      traditional reference style, designed to be read on an as-required basis. We'd also recommend
      that you read up as much as possible on application security issues in general. Spring
      Security is not a panacea which will solve all security issues. It is important that the
      application is designed with security in mind from the start. Attempting to retrofit it is not
      a good idea. In particular, if you are building a web application, you should be aware of the
      many potential vulnerabilities such as cross-site scripting, request-forgery and
      session-hijacking which you should be taking into account from the start. The OWASP web site
      (http://www.owasp.org/) maintains a top ten list of web application vulnerabilities as well as
      a lot of useful reference information. </p>
    <p>We hope that you find this reference guide useful, and we welcome your feedback and <a class="ulink" href="#jira" target="_top">suggestions</a>. </p>
    <p>Finally, welcome to the Spring Security <a class="ulink" href="#community" target="_top">community</a>.
    </p>
  </div>
  <div class="part" title="Part&nbsp;I.&nbsp;Getting Started"><div class="titlepage"><div><div><h1 class="title"><a name="getting-started"></a>Part&nbsp;I.&nbsp;Getting Started</h1></div></div></div>
    
    <div class="partintro" title="Getting Started"><div></div>
      <p>The later parts of this guide provide an in-depth discussion of the framework
        architecture and implementation classes, which you need to understand if you want to do any
        serious customization. In this part, we'll introduce Spring Security 3.0, give a brief
        overview of the project's history and take a slightly gentler look at how to get started
        using the framework. In particular, we'll look at namespace configuration which provides a
        much simpler way of securing your application compared to the traditional Spring bean
        approach where you have to wire up all the implementation classes individually. </p>
      <p> We'll also take a look at the sample applications that are available. It's worth trying
        to run these and experimenting with them a bit even before you read the later sections - you
        can dip back into them as your understanding of the framework increases. Please also check
        out the <a class="ulink" href="http://static.springsource.org/spring-security/site/index.html" target="_top">project website</a> as it has useful information on building the project, plus links
        to articles, videos and tutorials. </p>
    </div>
    <div class="chapter" title="1.&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title"><a name="introduction"></a>1.&nbsp;Introduction</h2></div></div></div>
    
    <div class="section" title="1.1&nbsp;What is Spring Security?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="what-is-acegi-security"></a>1.1&nbsp;What is Spring Security?</h2></div></div></div>
        
        <p>Spring Security provides comprehensive security services for J2EE-based enterprise
            software applications. There is a particular emphasis on supporting projects built using
            The Spring Framework, which is the leading J2EE solution for enterprise software
            development. If you're not using Spring for developing enterprise applications, we
            warmly encourage you to take a closer look at it. Some familiarity with Spring - and in
            particular dependency injection principles - will help you get up to speed with Spring
            Security more easily.</p>
        <p>People use Spring Security for many reasons, but most are drawn to the project after
            finding the security features of J2EE's Servlet Specification or EJB Specification lack
            the depth required for typical enterprise application scenarios. Whilst mentioning these
            standards, it's important to recognise that they are not portable at a WAR or EAR level.
            Therefore, if you switch server environments, it is typically a lot of work to
            reconfigure your application's security in the new target environment. Using Spring
            Security overcomes these problems, and also brings you dozens of other useful,
            customisable security features.</p>
        <p>As you probably know two major areas of application security are
                <span class="quote">&#8220;<span class="quote">authentication</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">authorization</span>&#8221;</span> (or
                <span class="quote">&#8220;<span class="quote">access-control</span>&#8221;</span>). These are the two main areas that Spring Security
            targets. <span class="quote">&#8220;<span class="quote">Authentication</span>&#8221;</span> is the process of establishing a principal is who
            they claim to be (a <span class="quote">&#8220;<span class="quote">principal</span>&#8221;</span> generally means a user, device or some
            other system which can perform an action in your application).
                <span class="quote">&#8220;<span class="quote">Authorization</span>&#8221;</span> refers to the process of deciding whether a principal
            is allowed to perform an action within your application. To arrive at the point where an
            authorization decision is needed, the identity of the principal has already been
            established by the authentication process. These concepts are common, and not at all
            specific to Spring Security. </p>
        <p>At an authentication level, Spring Security supports a wide range of authentication
            models. Most of these authentication models are either provided by third parties, or are
            developed by relevant standards bodies such as the Internet Engineering Task Force. In
            addition, Spring Security provides its own set of authentication features. Specifically,
            Spring Security currently supports authentication integration with all of these
            technologies:</p>
        <div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
                <p>HTTP BASIC authentication headers (an IEFT RFC-based standard)</p>
            </li><li class="listitem">
                <p>HTTP Digest authentication headers (an IEFT RFC-based standard)</p>
            </li><li class="listitem">
                <p>HTTP X.509 client certificate exchange (an IEFT RFC-based standard)</p>
            </li><li class="listitem">
                <p>LDAP (a very common approach to cross-platform authentication needs,
                    especially in large environments)</p>
            </li><li class="listitem">
                <p>Form-based authentication (for simple user interface needs)</p>
            </li><li class="listitem">
                <p>OpenID authentication</p>
            </li><li class="listitem">
                <p>Authentication based on pre-established request headers (such as Computer
                    Associates Siteminder)</p>
            </li><li class="listitem">
                <p>JA-SIG Central Authentication Service (otherwise known as CAS, which is a
                    popular open source single sign on system)</p>
            </li><li class="listitem">
                <p>Transparent authentication context propagation for Remote Method Invocation
                    (RMI) and HttpInvoker (a Spring remoting protocol)</p>
            </li><li class="listitem">
                <p>Automatic "remember-me" authentication (so you can tick a box to avoid
                    re-authentication for a predetermined period of time)</p>
            </li><li class="listitem">
                <p>Anonymous authentication (allowing every call to automatically assume a
                    particular security identity)</p>
            </li><li class="listitem">
                <p>Run-as authentication (which is useful if one call should proceed with a
                    different security identity)</p>
            </li><li class="listitem">
                <p>Java Authentication and Authorization Service (JAAS)</p>
            </li><li class="listitem">
                <p>JEE container autentication (so you can still use Container Managed
                    Authentication if desired)</p>
            </li><li class="listitem">
                <p>Kerberos</p>
            </li><li class="listitem">
                <p>Java Open Source Single Sign On (JOSSO) *</p>
            </li><li class="listitem">
                <p>OpenNMS Network Management Platform *</p>
            </li><li class="listitem">
                <p>AppFuse *</p>
            </li><li class="listitem">
                <p>AndroMDA *</p>
            </li><li class="listitem">
                <p>Mule ESB *</p>
            </li><li class="listitem">
                <p>Direct Web Request (DWR) *</p>
            </li><li class="listitem">
                <p>Grails *</p>
            </li><li class="listitem">
                <p>Tapestry *</p>
            </li><li class="listitem">
                <p>JTrac *</p>
            </li><li class="listitem">
                <p>Jasypt *</p>
            </li><li class="listitem">
                <p>Roller *</p>
            </li><li class="listitem">
                <p>Elastic Path *</p>
            </li><li class="listitem">
                <p>Atlassian Crowd *</p>
            </li><li class="listitem">
                <p>Your own authentication systems (see below)</p>
            </li></ul></div>
        <p>(* Denotes provided by a third party; check our <a class="ulink" href="http://acegisecurity.org/powering.html" target="_top">integration page</a> for
            links to the latest details)</p>
        <p>Many independent software vendors (ISVs) adopt Spring Security because of this
            significant choice of flexible authentication models. Doing so allows them to quickly
            integrate their solutions with whatever their end clients need, without undertaking a
            lot of engineering or requiring the client to change their environment. If none of the
            above authentication mechanisms suit your needs, Spring Security is an open platform and
            it is quite simple to write your own authentication mechanism. Many corporate users of
            Spring Security need to integrate with "legacy" systems that don't follow any particular
            security standards, and Spring Security is happy to "play nicely" with such
            systems.</p>
        <p>Sometimes the mere process of authentication isn't enough. Sometimes you need to also
            differentiate security based on the way a principal is interacting with your
            application. For example, you might want to ensure requests only arrive over HTTPS, in
            order to protect passwords from eavesdropping or end users from man-in-the-middle
            attacks. This is especially helpful to protect password recovery processes from brute
            force attacks, or simply to make it harder for people to duplicate your application's
            key content. To help you achieve these goals, Spring Security fully supports automatic
            "channel security", together with JCaptcha integration for human user detection.</p>
        <p>Irrespective of how authentication was undertaken, Spring Security provides a deep set
            of authorization capabilities. There are three main areas of interest in respect of
            authorization, these being authorizing web requests, authorizing whether methods can be
            invoked, and authorizing access to individual domain object instances. To help you
            understand the differences, consider the authorization capabilities found in the Servlet
            Specification web pattern security, EJB Container Managed Security and file system
            security respectively. Spring Security provides deep capabilities in all of these
            important areas, which we'll explore later in this reference guide.</p>
    </div>
    <div class="section" title="1.2&nbsp;History"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="history"></a>1.2&nbsp;History</h2></div></div></div>
        
        <p>Spring Security began in late 2003 as <span class="quote">&#8220;<span class="quote">The Acegi Security System for
                Spring</span>&#8221;</span>. A question was posed on the Spring Developers' mailing list asking
            whether there had been any consideration given to a Spring-based security
            implementation. At the time the Spring community was relatively small (especially
            compared with the size today!), and indeed Spring itself had only existed as a
            SourceForge project from early 2003. The response to the question was that it was a
            worthwhile area, although a lack of time currently prevented its exploration.</p>
        <p>With that in mind, a simple security implementation was built and not released. A few
            weeks later another member of the Spring community inquired about security, and at the
            time this code was offered to them. Several other requests followed, and by January 2004
            around twenty people were using the code. These pioneering users were joined by others
            who suggested a SourceForge project was in order, which was duly established in March
            2004.</p>
        <p>In those early days, the project didn't have any of its own authentication modules.
            Container Managed Security was relied upon for the authentication process, with Acegi
            Security instead focusing on authorization. This was suitable at first, but as more and
            more users requested additional container support, the fundamental limitation of
            container-specific authentication realm interfaces became clear. There was also a
            related issue of adding new JARs to the container's classpath, which was a common source
            of end user confusion and misconfiguration.</p>
        <p>Acegi Security-specific authentication services were subsequently introduced. Around a
            year later, Acegi Security became an official Spring Framework subproject. The 1.0.0
            final release was published in May 2006 - after more than two and a half years of active
            use in numerous production software projects and many hundreds of improvements and
            community contributions.</p>
        <p>Acegi Security became an official Spring Portfolio project towards the end of 2007 and
            was rebranded as <span class="quote">&#8220;<span class="quote">Spring Security</span>&#8221;</span>.</p>
        <p>Today Spring Security enjoys a strong and active open source community. There are
            thousands of messages about Spring Security on the support forums. There is an active
            core of developers who work on the code itself and an active community which also
            regularly share patches and support their peers.</p>
    </div>
    <div class="section" title="1.3&nbsp;Release Numbering"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="release-numbering"></a>1.3&nbsp;Release Numbering</h2></div></div></div>
        
        <p>It is useful to understand how Spring Security release numbers work, as it will help
            you identify the effort (or lack thereof) involved in migrating to future releases of
            the project. Officially, we use the Apache Portable Runtime Project versioning
            guidelines, which can be viewed at
                <code class="literal">http://apr.apache.org/versioning.html</code>. We quote the introduction
            contained on that page for your convenience:</p>
        <p><span class="quote">&#8220;<span class="quote">Versions are denoted using a standard triplet of integers: MAJOR.MINOR.PATCH.
                The basic intent is that MAJOR versions are incompatible, large-scale upgrades of
                the API. MINOR versions retain source and binary compatibility with older minor
                versions, and changes in the PATCH level are perfectly compatible, forwards and
                backwards.</span>&#8221;</span></p>
    </div>
    <div class="section" title="1.4&nbsp;Getting Spring Security"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="get-spring-security"></a>1.4&nbsp;Getting Spring Security</h2></div></div></div>
        
        <p>You can get hold of Spring Security in several ways. You can download a packaged
            distribution from the main Spring <a class="ulink" href="http://www.springsource.com/download/community?project=Spring%20Security" target="_top">download page</a>, download individual jars (and sample WAR files) from the
            Maven Central repository (or a SpringSource Maven repository for snapshot and milestone
            releases) or, alternatively, you can build the project from source yourself. See the
            project web site for more details. </p>
        <div class="section" title="1.4.1&nbsp;Project Modules"><div class="titlepage"><div><div><h3 class="title"><a name="modules"></a>1.4.1&nbsp;Project Modules</h3></div></div></div>
            
            <p>In Spring Security 3.0, the codebase has been sub-divided into separate jars which
                more clearly separate different functionaltiy areas and third-party dependencies. If
                you are using Maven to build your project, then these are the modules you will add
                to your <code class="filename">pom.xml</code>. Even if you're not using Maven, we'd recommend
                that you consult the <code class="filename">pom.xml</code> files to get an idea of
                third-party dependencies and versions. Alternatively, a good idea is to examine the
                libraries that are included in the sample applications.</p>
            <div class="section" title="Core - spring-security-core.jar"><div class="titlepage"><div><div><h4 class="title"><a name="spring-security-core"></a>Core - <code class="literal">spring-security-core.jar</code></h4></div></div></div>
                
                <p>Contains core authentication and access-contol classes and interfaces,
                    remoting support and basic provisioning APIs. Required by any application which
                    uses Spring Security. Supports standalone applications, remote clients, method
                    (service layer) security and JDBC user provisioning. Contains the top-level
                                    packages:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">org.springframework.security.core</code></p></li><li class="listitem"><p><code class="literal">org.springframework.security.access</code></p></li><li class="listitem"><p><code class="literal">org.springframework.security.authentication</code></p></li><li class="listitem"><p><code class="literal">org.springframework.security.provisioning</code></p></li><li class="listitem"><p><code class="literal">org.springframework.security.remoting</code></p></li></ul></div>
            </div>
            <div class="section" title="Web - spring-security-web.jar"><div class="titlepage"><div><div><h4 class="title"><a name="spring-security-web"></a>Web - <code class="literal">spring-security-web.jar</code></h4></div></div></div>
                
                <p>Contains filters and related web-security infrastructure code. Anything with a
                    servlet API dependency. You'll need it if you require Spring Security web
                    authentication services and URL-based access-control. The main package is
                        <code class="literal">org.springframework.security.web</code>.</p>
            </div>
            <div class="section" title="Config - spring-security-config.jar"><div class="titlepage"><div><div><h4 class="title"><a name="spring-security-config"></a>Config - <code class="literal">spring-security-config.jar</code></h4></div></div></div>
                
                <p>Contains the security namespace parsing code (and hence nothing that you are
                    likely yo use directly in your application). You need it if you are using the
                    Spring Security XML namespace for configuration. The main package is
                        <code class="literal">org.springframework.security.config</code>.</p>
            </div>
            <div class="section" title="LDAP - spring-security-ldap.jar"><div class="titlepage"><div><div><h4 class="title"><a name="spring-security-ldap"></a>LDAP - <code class="literal">spring-security-ldap.jar</code></h4></div></div></div>
                
                <p>LDAP authentication and provisioning code. Required if you need to use LDAP
                    authentication or manage LDAP user entries. The top-level package is
                        <code class="literal">org.springframework.security.ldap</code>.</p>
            </div>
            <div class="section" title="ACL - spring-security-acl.jar"><div class="titlepage"><div><div><h4 class="title"><a name="spring-security-acl"></a>ACL - <code class="literal">spring-security-acl.jar</code></h4></div></div></div>
                
                <p>Specialized domain object ACL implementation. Used to apply security to
                    specific domain object instances within your application. The top-level package
                    is <code class="literal">org.springframework.security.acls</code>.</p>
            </div>
            <div class="section" title="CAS - spring-security-cas-client.jar"><div class="titlepage"><div><div><h4 class="title"><a name="spring-security-cas"></a>CAS - <code class="literal">spring-security-cas-client.jar</code></h4></div></div></div>
                
                <p>Spring Security's CAS client integration. If you want to use Spring Security
                    web authentication with a CAS single sign-on server. The top-level package is
                        <code class="literal">org.springframework.security.cas</code>.</p>
            </div>
            <div class="section" title="OpenID - spring-security-openid.jar"><div class="titlepage"><div><div><h4 class="title"><a name="spring-security-openid"></a>OpenID - <code class="literal">spring-security-openid.jar</code></h4></div></div></div>
                
                <p>OpenID web authentication support. Used to authenticate users against an
                    external OpenID server. <code class="literal">org.springframework.security.openid</code>.
                    Requires OpenID4Java.</p>
            </div>
        </div>
        <div class="section" title="1.4.2&nbsp;Checking out the Source"><div class="titlepage"><div><div><h3 class="title"><a name="get-source"></a>1.4.2&nbsp;Checking out the Source</h3></div></div></div>
            
            <p> Since Spring Security is an Open Source project, we'd strongly encourage you to
                check out the source code using git. This will give you full access to all the
                sample applications and you can build the most up to date version of the project
                easily. Having the source for a project is also a huge help in debugging. Exception
                stack traces are no longer obscure black-box issues but you can get straight to the
                line that's causing the problem and work out what's happening. The source is the
                ultimate documentation for a project and often the simplest place to find out how
                something actually works. </p>
            <p>To obtain the source for the project trunk, use the following git command:
                </p><pre class="programlisting">
  git clone git://git.springsource.org/spring-security/spring-security.git
    </pre><p>
                You can checkout specific versions from
                    <code class="literal">https://src.springframework.org/svn/spring-security/tags/</code>.
            </p>
        </div>
    </div>
</div>
    <div class="chapter" title="2.&nbsp;Security Namespace Configuration"><div class="titlepage"><div><div><h2 class="title"><a name="ns-config"></a>2.&nbsp;Security Namespace Configuration</h2></div></div></div>
  
  <div class="section" title="2.1&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e195"></a>2.1&nbsp;Introduction</h2></div></div></div>
    
    <p> Namespace configuration has been available since version 2.0 of the Spring framework. It
      allows you to supplement the traditional Spring beans application context syntax with elements
      from additional XML schema. You can find more information in the Spring <a class="ulink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/apc.html" target="_top"> Reference Documentation</a>. A namespace element can be used simply to allow a more
      concise way of configuring an individual bean or, more powerfully, to define an alternative
      configuration syntax which more closely matches the problem domain and hides the underlying
      complexity from the user. A simple element may conceal the fact that multiple beans and
      processing steps are being added to the application context. For example, adding the following
      element from the security namespace to an application context will start up an embedded LDAP
      server for testing use within the application: </p><pre class="programlisting">
  <span class="hl-tag">&lt;security:ldap-server /&gt;</span>
</pre><p> This is much simpler than wiring up the equivalent Apache Directory Server
      beans. The most common alternative configuration requirements are supported by attributes on
      the <code class="literal">ldap-server</code> element and the user is isolated from worrying about which
      beans they need to create and what the bean property names are. <sup>[<a name="d4e201" href="#ftn.d4e201" class="footnote">1</a>]</sup>. Use of a good XML editor while
      editing the application context file should provide information on the attributes and elements
      that are available. We would recommend that you try out the <a class="ulink" href="http://www.springsource.com/products/sts" target="_top">SpringSource Tool Suite</a> as it
      has special features for working with standard Spring namespaces. </p>
    <p> To start using the security namespace in your application context, you first need to make
        sure that the <code class="literal">spring-security-config</code> jar is on your classpath. Then all you need to do is
      add the schema declaration to your application context file: </p><pre class="programlisting">
  
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
  <span class="hl-attribute">xmlns:security</span>=<span class="hl-value">"http://www.springframework.org/schema/security"</span>
  <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
  <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
          http://www.springframework.org/schema/security
          http://www.springframework.org/schema/security/spring-security-3.0.3.xsd"</span><span class="hl-tag">&gt;</span>
    ...
<span class="hl-tag">&lt;/beans&gt;</span>
  </pre><p> In many of the examples you will see (and in the sample) applications, we
      will often use "security" as the default namespace rather than "beans", which means we can
      omit the prefix on all the security namespace elements, making the content easier to read. You
      may also want to do this if you have your application context divided up into separate files
      and have most of your security configuration in one of them. Your security application context
      file would then start like this </p><pre class="programlisting">
<span class="hl-tag">&lt;beans:beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/security"</span>
  <span class="hl-attribute">xmlns:beans</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
  <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
  <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
           http://www.springframework.org/schema/security
           http://www.springframework.org/schema/security/spring-security-3.0.3.xsd"</span><span class="hl-tag">&gt;</span>
    ...
<span class="hl-tag">&lt;/beans:beans&gt;</span>
</pre><p> We'll assume this syntax is being used from now on in this chapter. </p>
    <div class="section" title="2.1.1&nbsp;Design of the Namespace"><div class="titlepage"><div><div><h3 class="title"><a name="d4e210"></a>2.1.1&nbsp;Design of the Namespace</h3></div></div></div>
      
      <p> The namespace is designed to capture the most common uses of the framework and provide
        a simplified and concise syntax for enabling them within an application. The design is based
        around the large-scale dependencies within the framework, and can be divided up into the
        following areas: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
              <span class="emphasis"><em>Web/HTTP Security</em></span> - the most complex part. Sets up the filters
              and related service beans used to apply the framework authentication mechanisms, to
              secure URLs, render login and error pages and much
              more.</p></li><li class="listitem"><p>
              <span class="emphasis"><em>Business Object (Method) Security</em></span> - options for securing the
              service layer.</p></li><li class="listitem"><p>
              <span class="emphasis"><em>AuthenticationManager</em></span> - handles authentication requests from
              other parts of the framework.</p></li><li class="listitem"><p>
              <span class="emphasis"><em>AccessDecisionManager</em></span> - provides access decisions for web and
              method security. A default one will be registered, but you can also choose to use a
              custom one, declared using normal Spring bean
              syntax.</p></li><li class="listitem"><p>
              <span class="emphasis"><em>AuthenticationProvider</em></span>s - mechanisms against which the
              authentication manager authenticates users. The namespace provides supports for
              several standard options and also a means of adding custom beans declared using a
              traditional syntax. </p></li><li class="listitem"><p>
              <span class="emphasis"><em>UserDetailsService</em></span> - closely related to authentication providers,
              but often also required by other beans.</p></li></ul></div>
      <p>We'll see how to configure these in the following sections.</p>
    </div>
  </div>
  <div class="section" title="2.2&nbsp;Getting Started with Security Namespace Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ns-getting-started"></a>2.2&nbsp;Getting Started with Security Namespace Configuration</h2></div></div></div>
    
    <p> In this section, we'll look at how you can build up a namespace configuration to use some
      of the main features of the framework. Let's assume you initially want to get up and running
      as quickly as possible and add authentication support and access control to an existing web
      application, with a few test logins. Then we'll look at how to change over to authenticating
      against a database or other security repository. In later sections we'll introduce more
      advanced namespace configuration options. </p>
    <div class="section" title="2.2.1&nbsp;web.xml Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="ns-web-xml"></a>2.2.1&nbsp;<code class="literal">web.xml</code> Configuration</h3></div></div></div>
      
      <p> The first thing you need to do is add the following filter declaration to your
          <code class="literal">web.xml</code> file: </p><pre class="programlisting">
<span class="hl-tag">&lt;filter&gt;</span>
  <span class="hl-tag">&lt;filter-name&gt;</span>springSecurityFilterChain<span class="hl-tag">&lt;/filter-name&gt;</span>
  <span class="hl-tag">&lt;filter-class&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="hl-tag">&lt;/filter-class&gt;</span>
<span class="hl-tag">&lt;/filter&gt;</span>

<span class="hl-tag">&lt;filter-mapping&gt;</span>
  <span class="hl-tag">&lt;filter-name&gt;</span>springSecurityFilterChain<span class="hl-tag">&lt;/filter-name&gt;</span>
  <span class="hl-tag">&lt;url-pattern&gt;</span>/*<span class="hl-tag">&lt;/url-pattern&gt;</span>
<span class="hl-tag">&lt;/filter-mapping&gt;</span>
      </pre><p> This provides a hook into the Spring Security web
        infrastructure. <code class="classname">DelegatingFilterProxy</code> is a Spring Framework class
        which delegates to a filter implementation which is defined as a Spring bean in your
        application context. In this case, the bean is named
          <span class="quote">&#8220;<span class="quote">springSecurityFilterChain</span>&#8221;</span>, which is an internal infrastructure bean created
        by the namespace to handle web security. Note that you should not use this bean name
        yourself. Once you've added this to your <code class="filename">web.xml</code>, you're ready to start
        editing your application context file. Web security services are configured using the
          <code class="literal">&lt;http&gt;</code> element. </p>
    </div>
    <div class="section" title="2.2.2&nbsp;A Minimal <http&gt; Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="ns-minimal"></a>2.2.2&nbsp;A Minimal <code class="literal">&lt;http&gt;</code> Configuration</h3></div></div></div>
      
      <p> All you need to enable web security to begin with is </p><pre class="programlisting">
  <span class="hl-tag">&lt;http</span> <span class="hl-attribute">auto-config</span>=<span class="hl-value">'true'</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/**"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_USER"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-tag">&lt;/http&gt;</span>
  
</pre><p> Which says that we want all URLs within our application to be secured,
        requiring the role <code class="literal">ROLE_USER</code> to access them. The
          <code class="literal">&lt;http&gt;</code> element is the parent for all web-related namespace
        functionality. The <code class="literal">&lt;intercept-url&gt;</code> element defines a
          <code class="literal">pattern</code> which is matched against the URLs of incoming requests using an
        ant path style syntax. The <code class="literal">access</code> attribute defines the access
        requirements for requests matching the given pattern. With the default configuration, this
        is typically a comma-separated list of roles, one of which a user must have to be allowed to
        make the request. The prefix <span class="quote">&#8220;<span class="quote">ROLE_</span>&#8221;</span> is a marker which indicates that a simple
        comparison with the user's authorities should be made. In other words, a normal role-based
        check should be used. Access-control in Spring Security is not limited to the use of simple
        roles (hence the use of the prefix to differentiate between different types of security
        attributes). We'll see later how the interpretation can vary<sup>[<a name="d4e257" href="#ftn.d4e257" class="footnote">2</a>]</sup>.</p>
      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>You can use multiple <code class="literal">&lt;intercept-url&gt;</code> elements to define
          different access requirements for different sets of URLs, but they will be evaluated in
          the order listed and the first match will be used. So you must put the most specific
          matches at the top. You can also add a <code class="literal">method</code> attribute to limit the
          match to a particular HTTP method (<code class="literal">GET</code>, <code class="literal">POST</code>,
            <code class="literal">PUT</code> etc.). If a request matches multiple patterns, the
          method-specific match will take precedence regardless of ordering.</p>
      </td></tr></table></div>
      <p> To add some users, you can define a set of test data directly in the namespace: </p><pre class="programlisting">
  <span class="hl-tag">&lt;authentication-manager&gt;</span>
    <span class="hl-tag">&lt;authentication-provider&gt;</span>
      <span class="hl-tag">&lt;user-service&gt;</span>
        <span class="hl-tag">&lt;user</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jimi"</span> <span class="hl-attribute">password</span>=<span class="hl-value">"jimispassword"</span> <span class="hl-attribute">authorities</span>=<span class="hl-value">"ROLE_USER, ROLE_ADMIN"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;user</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bob"</span> <span class="hl-attribute">password</span>=<span class="hl-value">"bobspassword"</span> <span class="hl-attribute">authorities</span>=<span class="hl-value">"ROLE_USER"</span><span class="hl-tag"> /&gt;</span>
      <span class="hl-tag">&lt;/user-service&gt;</span>
    <span class="hl-tag">&lt;/authentication-provider&gt;</span>
  <span class="hl-tag">&lt;/authentication-manager&gt;</span>
  
        </pre>
      <div class="sidebar"><p class="title"><b></b></p>
        <p>If you are familiar with pre-namespace versions of the framework, you can probably
          already guess roughly what's going on here. The <code class="literal">&lt;http&gt;</code> element is
          responsible for creating a <code class="classname">FilterChainProxy</code> and the filter beans
          which it uses. Common problems like incorrect filter ordering are no longer an issue as
          the filter positions are predefined.</p>
        <p>The <code class="literal">&lt;authentication-provider&gt;</code> element creates a
            <code class="classname">DaoAuthenticationProvider</code> bean and the
            <code class="literal">&lt;user-service&gt;</code> element creates an
            <code class="classname">InMemoryDaoImpl</code>. All <code class="literal">authentication-provider</code>
          elements must be children of the <code class="literal">&lt;authentication-manager&gt;</code> element,
          which creates a <code class="classname">ProviderManager</code> and registers the authentication
          providers with it. You can find more detailed information on the beans that are created in
          the <a class="ulink" href="#appendix-namespace" target="_top">namespace appendix</a>. It's worth
          cross-checking this if you want to start understanding what the important classes in the
          framework are and how they are used, particularly if you want to customise things
          later.</p>
      </div>
      <p> The configuration above defines two users, their passwords and their roles within the
        application (which will be used for access control). It is also possible to load user
        information from a standard properties file using the <code class="literal">properties</code>
        attribute on <code class="literal">user-service</code>. See the section on <a class="ulink" href="#core-services-in-memory-service" target="_top">in-memory authentication</a> for more
        details on the file format. Using the <code class="literal">&lt;authentication-provider&gt;</code>
        element means that the user information will be used by the authentication manager to
        process authentication requests. You can have multiple
          <code class="literal">&lt;authentication-provider&gt;</code> elements to define different
        authentication sources and each will be consulted in turn.</p>
      <p> At this point you should be able to start up your application and you will be required
        to log in to proceed. Try it out, or try experimenting with the <span class="quote">&#8220;<span class="quote">tutorial</span>&#8221;</span>
        sample application that comes with the project. The above configuration actually adds quite
        a few services to the application because we have used the <code class="literal">auto-config</code>
        attribute. For example, form-based login processing is automatically enabled. </p>
      <div class="section" title="What does auto-config Include?"><div class="titlepage"><div><div><h4 class="title"><a name="ns-auto-config"></a>What does <code class="literal">auto-config</code> Include?</h4></div></div></div>
        
        <p> The <code class="literal">auto-config</code> attribute, as we have used it above, is just a
          shorthand syntax for: </p><pre class="programlisting">
  <span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-tag">&lt;form-login /&gt;</span>
    <span class="hl-tag">&lt;http-basic /&gt;</span>
    <span class="hl-tag">&lt;logout /&gt;</span>
  <span class="hl-tag">&lt;/http&gt;</span>
  </pre><p> These other elements are responsible for setting up form-login, basic
          authentication and logout handling services respectively <sup>[<a name="d4e299" href="#ftn.d4e299" class="footnote">3</a>]</sup> . They each have attributes which can be used to alter
          their behaviour. </p>
      </div>
      <div class="section" title="Form and Basic Login Options"><div class="titlepage"><div><div><h4 class="title"><a name="ns-form-and-basic"></a>Form and Basic Login Options</h4></div></div></div>
        
        <p> You might be wondering where the login form came from when you were prompted to log
          in, since we made no mention of any HTML files or JSPs. In fact, since we didn't
          explicitly set a URL for the login page, Spring Security generates one automatically,
          based on the features that are enabled and using standard values for the URL which
          processes the submitted login, the default target URL the user will be sent to after
          loggin in and so on. However, the namespace offers plenty of support to allow you to
          customize these options. For example, if you want to supply your own login page, you could
          use: </p><pre class="programlisting">
  <span class="hl-tag">&lt;http</span> <span class="hl-attribute">auto-config</span>=<span class="hl-value">'true'</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/login.jsp*"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"IS_AUTHENTICATED_ANONYMOUSLY"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/**"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_USER"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;form-login</span> <span class="hl-attribute">login-page</span>=<span class="hl-value">'/login.jsp'</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/http&gt;</span>
  
        </pre><p> Note that you can still use <code class="literal">auto-config</code>. The
            <code class="literal">form-login</code> element just overrides the default settings. Also note
          that we've added an extra <code class="literal">intercept-url</code> element to say that any
          requests for the login page should be available to anonymous users <sup>[<a name="d4e312" href="#ftn.d4e312" class="footnote">4</a>]</sup>. Otherwise the request would be matched by the pattern
            <code class="literal">/**</code> and it wouldn't be possible to access the login page itself! This
          is a common configuration error and will result in an infinite loop in the application.
          Spring Security will emit a warning in the log if your login page appears to be secured.
          It is also possible to have all requests matching a particular pattern bypass the security
          filter chain completely: </p><pre class="programlisting">
  <span class="hl-tag">&lt;http</span> <span class="hl-attribute">auto-config</span>=<span class="hl-value">'true'</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/css/**"</span> <span class="hl-attribute">filters</span>=<span class="hl-value">"none"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/login.jsp*"</span> <span class="hl-attribute">filters</span>=<span class="hl-value">"none"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/**"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_USER"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;form-login</span> <span class="hl-attribute">login-page</span>=<span class="hl-value">'/login.jsp'</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/http&gt;</span>
  
          </pre><p>It's important to realise that these requests will be completely
          oblivious to any further Spring Security web-related configuration or additional
          attributes such as <code class="literal">requires-channel</code>, so you will not be able to access
          information on the current user or call secured methods during the request. Use
            <code class="literal">access='IS_AUTHENTICATED_ANONYMOUSLY'</code> as an alternative if you still
          want the security filter chain to be applied.</p>
        <p>If you want to use basic authentication instead of form login, then change the
          configuration to </p><pre class="programlisting">
  <span class="hl-tag">&lt;http</span> <span class="hl-attribute">auto-config</span>=<span class="hl-value">'true'</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/**"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_USER"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;http-basic /&gt;</span>
  <span class="hl-tag">&lt;/http&gt;</span>
  
        </pre><p> Basic authentication will then take precedence and will be used to
          prompt for a login when a user attempts to access a protected resource. Form login is
          still available in this configuration if you wish to use it, for example through a login
          form embedded in another web page. </p>
        <div class="section" title="Setting a Default Post-Login Destination"><div class="titlepage"><div><div><h5 class="title"><a name="ns-form-target"></a>Setting a Default Post-Login Destination</h5></div></div></div>
          
          <p> If a form login isn't prompted by an attempt to access a protected resource, the
              <code class="literal">default-target-url</code> option comes into play. This is the URL the user
            will be taken to after logging in, and defaults to "/". You can also configure things so
            that they user <span class="emphasis"><em>always</em></span> ends up at this page (regardless of whether
            the login was "on-demand" or they explicitly chose to log in) by setting the
              <code class="literal">always-use-default-target</code> attribute to "true". This is useful if
            your application always requires that the user starts at a "home" page, for example: </p><pre class="programlisting">
  <span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-tag">&lt;intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">'/login.htm*'</span> <span class="hl-attribute">filters</span>=<span class="hl-value">'none'</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">'/**'</span> <span class="hl-attribute">access</span>=<span class="hl-value">'ROLE_USER'</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;form-login</span> <span class="hl-attribute">login-page</span>=<span class="hl-value">'/login.htm'</span> <span class="hl-attribute">default-target-url</span>=<span class="hl-value">'/home.htm'</span>
            <span class="hl-attribute">always-use-default-target</span>=<span class="hl-value">'true'</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-tag">&lt;/http&gt;</span>
  
            </pre>
        </div>
      </div>
    </div>
    <div class="section" title="2.2.3&nbsp;Using other Authentication Providers"><div class="titlepage"><div><div><h3 class="title"><a name="ns-auth-providers"></a>2.2.3&nbsp;Using other Authentication Providers</h3></div></div></div>
      
      <p> In practice you will need a more scalable source of user information than a few names
        added to the application context file. Most likely you will want to store your user
        information in something like a database or an LDAP server. LDAP namespace configuration is
        dealt with in the <a class="ulink" href="#ldap" target="_top">LDAP chapter</a>, so we won't cover it here.
        If you have a custom implementation of Spring Security's
          <code class="classname">UserDetailsService</code>, called "myUserDetailsService" in your
        application context, then you can authenticate against this using </p><pre class="programlisting">
  <span class="hl-tag">&lt;authentication-manager&gt;</span>
    <span class="hl-tag">&lt;authentication-provider</span> <span class="hl-attribute">user-service-ref</span>=<span class="hl-value">'myUserDetailsService'</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/authentication-manager&gt;</span>
  
        </pre><p> If you want to use a database, then you can use </p><pre class="programlisting">
  <span class="hl-tag">&lt;authentication-manager&gt;</span>
    <span class="hl-tag">&lt;authentication-provider&gt;</span>
      <span class="hl-tag">&lt;jdbc-user-service</span> <span class="hl-attribute">data-source-ref</span>=<span class="hl-value">"securityDataSource"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/authentication-provider&gt;</span>
  <span class="hl-tag">&lt;/authentication-manager&gt;</span>
  
        </pre><p> Where <span class="quote">&#8220;<span class="quote">securityDataSource</span>&#8221;</span> is the name of a
          <code class="classname">DataSource</code> bean in the application context, pointing at a database
        containing the standard Spring Security <a class="ulink" href="#db_schema_users_authorities" target="_top">user
          data tables</a>. Alternatively, you could configure a Spring Security
          <code class="classname">JdbcDaoImpl</code> bean and point at that using the
          <code class="literal">user-service-ref</code> attribute: </p><pre class="programlisting">
  <span class="hl-tag">&lt;authentication-manager&gt;</span>
    <span class="hl-tag">&lt;authentication-provider</span> <span class="hl-attribute">user-service-ref</span>=<span class="hl-value">'myUserDetailsService'</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/authentication-manager&gt;</span>

  <span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myUserDetailsService"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;beans:property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"dataSource"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/beans:bean&gt;</span>
  
        </pre><p> You can also use standard
          <code class="interfacename">AuthenticationProvider</code> beans as follows </p><pre class="programlisting">
  <span class="hl-tag">&lt;authentication-manager&gt;</span>
    <span class="hl-tag">&lt;authentication-provider</span> <span class="hl-attribute">ref</span>=<span class="hl-value">'myAuthenticationProvider'</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/authentication-manager&gt;</span>
  
        </pre><p> where <code class="literal">myAuthenticationProvider</code> is the name of a
        bean in your application context which implements
          <code class="interfacename">AuthenticationProvider</code>. You can use multiple
          <code class="literal">authentication-provider</code> elements, in which case they will be checked
        in the order they are declared when attempting to authenticated a user. See <a class="xref" href="#ns-auth-manager" title="2.6&nbsp;The Authentication Manager and the Namespace">Section&nbsp;2.6, &#8220;The Authentication Manager and the Namespace&#8221;</a> for more on information on how the Spring Security
          <code class="interfacename">AuthenticationManager</code> is configured using the namespace. </p>
      <div class="section" title="Adding a Password Encoder"><div class="titlepage"><div><div><h4 class="title"><a name="ns-password-encoder"></a>Adding a Password Encoder</h4></div></div></div>
        
        <p> Often your password data will be encoded using a hashing algorithm. This is supported
          by the <code class="literal">&lt;password-encoder&gt;</code> element. With SHA encoded passwords,
          the original authentication provider configuration would look like this: </p><pre class="programlisting">
<span class="hl-tag">&lt;authentication-manager&gt;</span>
  <span class="hl-tag">&lt;authentication-provider&gt;</span>
    <span class="hl-tag">&lt;password-encoder</span> <span class="hl-attribute">hash</span>=<span class="hl-value">"sha"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;user-service&gt;</span>
      <span class="hl-tag">&lt;user</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jimi"</span> <span class="hl-attribute">password</span>=<span class="hl-value">"d7e6351eaa13189a5a3641bab846c8e8c69ba39f"</span>
            <span class="hl-attribute">authorities</span>=<span class="hl-value">"ROLE_USER, ROLE_ADMIN"</span><span class="hl-tag"> /&gt;</span>
      <span class="hl-tag">&lt;user</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bob"</span> <span class="hl-attribute">password</span>=<span class="hl-value">"4e7421b1b8765d8f9406d87e7cc6aa784c4ab97f"</span>
            <span class="hl-attribute">authorities</span>=<span class="hl-value">"ROLE_USER"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/user-service&gt;</span>
  <span class="hl-tag">&lt;/authentication-provider&gt;</span>
<span class="hl-tag">&lt;/authentication-manager&gt;</span>
  
          </pre>
        <p> When using hashed passwords, it's also a good idea to use a salt value to protect
          against dictionary attacks and Spring Security supports this too. Ideally you would want
          to use a randomly generated salt value for each user, but you can use any property of the
            <code class="classname">UserDetails</code> object which is loaded by your
            <code class="classname">UserDetailsService</code>. For example, to use the
            <code class="literal">username</code> property, you would use </p><pre class="programlisting">
  &lt;password-encoder hash="sha"&gt;
    &lt;salt-source user-property="username"/&gt;
  &lt;/password-encoder&gt;
    </pre><p> You can use a custom password encoder bean by using the
            <code class="literal">ref</code> attribute of <code class="literal">password-encoder</code>. This should
          contain the name of a bean in the application context which is an instance of Spring
          Security's <code class="interfacename">PasswordEncoder</code> interface. </p>
      </div>
    </div>
  </div>
  <div class="section" title="2.3&nbsp;Advanced Web Features"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ns-web-advanced"></a>2.3&nbsp;Advanced Web Features</h2></div></div></div>
    
    <div class="section" title="2.3.1&nbsp;Remember-Me Authentication"><div class="titlepage"><div><div><h3 class="title"><a name="ns-remember-me"></a>2.3.1&nbsp;Remember-Me Authentication</h3></div></div></div>
      
      <p>See the separate <a class="ulink" href="#remember-me" target="_top">Remember-Me chapter</a> for
        information on remember-me namespace configuration.</p>
    </div>
    <div class="section" title="2.3.2&nbsp;Adding HTTP/HTTPS Channel Security"><div class="titlepage"><div><div><h3 class="title"><a name="ns-requires-channel"></a>2.3.2&nbsp;Adding HTTP/HTTPS Channel Security</h3></div></div></div>
      
      <p>If your application supports both HTTP and HTTPS, and you require that particular URLs
        can only be accessed over HTTPS, then this is directly supported using the
          <code class="literal">requires-channel</code> attribute on <code class="literal">&lt;intercept-url&gt;</code>: </p><pre class="programlisting">
  <span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-tag">&lt;intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/secure/**"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_USER"</span> <span class="hl-attribute">requires-channel</span>=<span class="hl-value">"https"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/**"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_USER"</span> <span class="hl-attribute">requires-channel</span>=<span class="hl-value">"any"</span><span class="hl-tag">/&gt;</span>
    ...
  <span class="hl-tag">&lt;/http&gt;</span>
        </pre><p>With this configuration in place, if a user attempts to access
        anything matching the "/secure/**" pattern using HTTP, they will first be redirected to an
        HTTPS URL. The available options are "http", "https" or "any". Using the value "any" means
        that either HTTP or HTTPS can be used. </p>
      <p>If your application uses non-standard ports for HTTP and/or HTTPS, you can specify a
        list of port mappings as follows: </p><pre class="programlisting">
  &lt;http&gt;
    ...
    &lt;port-mappings&gt;
      &lt;port-mapping http="9080" https="9443"/&gt;
    &lt;/port-mappings&gt;
  &lt;/http&gt;
        </pre>
    </div>
    <div class="section" title="2.3.3&nbsp;Session Management"><div class="titlepage"><div><div><h3 class="title"><a name="ns-session-mgmt"></a>2.3.3&nbsp;Session Management</h3></div></div></div>
      
      <div class="section" title="Detecting Timeouts"><div class="titlepage"><div><div><h4 class="title"><a name="d4e379"></a>Detecting Timeouts</h4></div></div></div>
        
        <p> You can configure Spring Security to detect the submission of an invalid session ID
          and redirect the user to an appropriate URL. This is achieved through the
            <code class="literal">session-management</code> element: </p><pre class="programlisting">
  <span class="hl-tag">&lt;http&gt;</span>
    ...
    <span class="hl-tag">&lt;session-management</span> <span class="hl-attribute">invalid-session-url</span>=<span class="hl-value">"/sessionTimeout.htm"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-tag">&lt;/http&gt;</span></pre>
      </div>
      <div class="section" title="Concurrent Session Control"><div class="titlepage"><div><div><h4 class="title"><a name="ns-concurrent-sessions"></a>Concurrent Session Control</h4></div></div></div>
        
        <p>If you wish to place constraints on a single user's ability to log in to your
          application, Spring Security supports this out of the box with the following simple
          additions. First you need to add the following listener to your
            <code class="filename">web.xml</code> file to keep Spring Security updated about session
          lifecycle events: </p><pre class="programlisting">
  <span class="hl-tag">&lt;listener&gt;</span>
    <span class="hl-tag">&lt;listener-class&gt;</span>
      org.springframework.security.web.session.HttpSessionEventPublisher
    <span class="hl-tag">&lt;/listener-class&gt;</span>
  <span class="hl-tag">&lt;/listener&gt;</span>
</pre><p> Then add the following lines to your application context: </p><pre class="programlisting">
  <span class="hl-tag">&lt;http&gt;</span>
    ...
    <span class="hl-tag">&lt;session-management&gt;</span>
        <span class="hl-tag">&lt;concurrency-control</span> <span class="hl-attribute">max-sessions</span>=<span class="hl-value">"1"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/session-management&gt;</span>
  <span class="hl-tag">&lt;/http&gt;</span>
        </pre><p> This will prevent a user from logging in multiple times - a
          second login will cause the first to be invalidated. Often you would prefer to prevent a
          second login, in which case you can use </p><pre class="programlisting">
  <span class="hl-tag">&lt;http&gt;</span>
    ...
    <span class="hl-tag">&lt;session-management&gt;</span>
        <span class="hl-tag">&lt;concurrency-control</span> <span class="hl-attribute">max-sessions</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">error-if-maximum-exceeded</span>=<span class="hl-value">"true"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/session-management&gt;</span>
  <span class="hl-tag">&lt;/http&gt;</span>
        </pre><p>The second login will then be rejected. By
            <span class="quote">&#8220;<span class="quote">rejected</span>&#8221;</span>, we mean that the user will be sent to the
            <code class="literal">authentication-failure-url</code> if form-based login is being used. If the
          second authentication takes place through another non-interactive mechanism, such as
            <span class="quote">&#8220;<span class="quote">remember-me</span>&#8221;</span>, an <span class="quote">&#8220;<span class="quote">unauthorized</span>&#8221;</span> (402) error will be sent to
          the client. If instead you want to use an error page, you can add the attribute
            <code class="literal">session-authentication-error-url</code> to the
            <code class="literal">session-management</code> element. </p>
        <p>If you are using a customized authentication filter for form-based login, then you
          have to configure concurrent session control support explicitly. More details can be found
          in the <a class="ulink" href="#session-mgmt" target="_top">Session Management chapter</a>. </p>
      </div>
      <div class="section" title="Session Fixation Attack Protection"><div class="titlepage"><div><div><h4 class="title"><a name="ns-session-fixation"></a>Session Fixation Attack Protection</h4></div></div></div>
        
        <p>
          <a class="ulink" href="http://en.wikipedia.org/wiki/Session_fixation" target="_top">Session fixation</a>
          attacks are a potential risk where it is possible for a malicious attacker to create a
          session by accessing a site, then persuade another user to log in with the same session
          (by sending them a link containing the session identifier as a parameter, for example).
          Spring Security protects against this automatically by creating a new session when a user
          logs in. If you don't require this protection, or it conflicts with some other
          requirement, you can control the behaviour using the
            <code class="literal">session-fixation-protection</code> attribute on
            <code class="literal">&lt;session-management&gt;</code>, which has three options
                  </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">migrateSession</code> - creates a new
                session and copies the existing session attributes to the new session. This is the
                default.</p></li><li class="listitem"><p><code class="literal">none</code> - Don't do
                anything. The original session will be
                  retained.</p></li><li class="listitem"><p><code class="literal">newSession</code> - Create
                a new "clean" session, without copying the existing session
            data.</p></li></ul></div>
      </div>
    </div>
    <div class="section" title="2.3.4&nbsp;OpenID Support"><div class="titlepage"><div><div><h3 class="title"><a name="ns-openid"></a>2.3.4&nbsp;OpenID Support</h3></div></div></div>
      
      <p>The namespace supports <a class="ulink" href="http://openid.net/" target="_top">OpenID</a> login either
        instead of, or in addition to normal form-based login, with a simple change: </p><pre class="programlisting">
  <span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-tag">&lt;intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/**"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_USER"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;openid-login /&gt;</span>
  <span class="hl-tag">&lt;/http&gt;</span>
</pre><p>You should then register yourself with an OpenID provider (such as
        myopenid.com), and add the user information to your in-memory
          <code class="literal">&lt;user-service&gt;</code> : </p><pre class="programlisting">
  <span class="hl-tag">&lt;user</span> <span class="hl-attribute">name</span>=<span class="hl-value">"http://jimi.hendrix.myopenid.com/"</span> <span class="hl-attribute">authorities</span>=<span class="hl-value">"ROLE_USER"</span><span class="hl-tag"> /&gt;</span>
</pre><p> You should be able to login using the <code class="literal">myopenid.com</code> site to
        authenticate. It is also possible to select a specific
          <code class="interfacename">UserDetailsService</code> bean for use OpenID by setting the
          <code class="literal">user-service-ref</code> attribute on the <code class="literal">openid-login</code>
        element. See the previous section on <a class="ulink" href="#ns-auth-providers" target="_top">authentication
          providers</a> for more information. Note that we have omitted the password attribute
        from the above user configuration, since this set of user data is only being used to load
        the authorities for the user. A random password will be generate internally, preventing you
        from accidentally using this user data as an authentication source elsewhere in your
        configuration.</p>
      <div class="section" title="Attribute Exchange"><div class="titlepage"><div><div><h4 class="title"><a name="d4e427"></a>Attribute Exchange</h4></div></div></div>
        
        <p>Support for OpenID <a class="ulink" href="http://openid.net/specs/openid-attribute-exchange-1_0.html" target="_top">attribute
            exchange</a>. As an example, the following configuration would attempt to retrieve
          the email and full name from the OpenID provider, for use by the application:</p><pre class="programlisting">
  <span class="hl-tag">&lt;openid-login&gt;</span>
    <span class="hl-tag">&lt;attribute-exchange&gt;</span>
      <span class="hl-tag">&lt;openid-attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"email"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"http://axschema.org/contact/email"</span> <span class="hl-attribute">required</span>=<span class="hl-value">"true"</span><span class="hl-tag"> /&gt;</span>
      <span class="hl-tag">&lt;openid-attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"http://axschema.org/namePerson"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/attribute-exchange&gt;</span>
  <span class="hl-tag">&lt;/openid-login&gt;</span></pre><p>The <span class="quote">&#8220;<span class="quote">type</span>&#8221;</span> of each OpenID attribute is a URI,
          determined by a particular schema, in this case <a class="ulink" href="http://axschema.org/" target="_top">http://axschema.org/</a>. If an attribute must be retrieved for successful
          authentication, the <code class="literal">required</code> attribute can be set. The exact schema and
          attributes supported will depend on your OpenID provider. The attribute values are
          returned as part of the authentication process and can be accessed afterwards using the
          following
          code:</p><pre class="programlisting">OpenIDAuthenticationToken token = (OpenIDAuthenticationToken)SecurityContextHolder.getContext().getAuthentication();
List&lt;OpenIDAttribute&gt; attributes = token.getAttributes();</pre><p>The
            <code class="classname">OpenIDAttribute</code> contains the attribute type and the retrieved
          value (or values in the case of multi-valued attributes). We'll see more about how the
            <code class="classname">SecurityContextHolder</code> class is used when we look at core Spring
          Security components in the <a class="ulink" href="#core-components" target="_top">technical overview</a>
          chapter.</p>
      </div>
    </div>
    <div class="section" title="2.3.5&nbsp;Adding in Your Own Filters"><div class="titlepage"><div><div><h3 class="title"><a name="ns-custom-filters"></a>2.3.5&nbsp;Adding in Your Own Filters</h3></div></div></div>
      
      <p>If you've used Spring Security before, you'll know that the framework maintains a chain
        of filters in order to apply its services. You may want to add your own filters to the stack
        at particular locations or use a Spring Security filter for which there isn't currently a
        namespace configuration option (CAS, for example). Or you might want to use a customized
        version of a standard namespace filter, such as the
          <code class="literal">UsernamePasswordAuthenticationFilter</code> which is created by the
          <code class="literal">&lt;form-login&gt;</code> element, taking advantage of some of the extra
        configuration options which are available by using the bean explicitly. How can you do this
        with namespace configuration, since the filter chain is not directly exposed? </p>
      <p>The order of the filters is always strictly enforced when using the namespace. When the
        application context is being created, the filter beans are sorted by the namespace handling
        code and the standard Spring Security filters each have an alias in the namespace and a
        well-known position.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>In previous versions, the sorting took place after the
            filter instances had been created, during post-processing of the application context. In
            version 3.0+ the sorting is now done at the bean metadata level, before the classes have
            been instantiated. This has implications for how you add your own filters to the stack
            as the entire filter list must be known during the parsing of the
              <code class="literal">&lt;http&gt;</code> element, so the syntax has changed slightly in
            3.0.</p></td></tr></table></div><p>The filters, aliases and namespace elements/attributes which create
        the filters are shown in <a class="xref" href="#filter-stack" title="Table&nbsp;2.1.&nbsp;Standard Filter Aliases and Ordering">Table&nbsp;2.1, &#8220;Standard Filter
            Aliases and Ordering&#8221;</a>. The filters are listed in the order
        in which they occur in the filter chain. </p><div class="table"><a name="filter-stack"></a><p class="title"><b>Table&nbsp;2.1.&nbsp;Standard Filter
            Aliases and Ordering</b></p><div class="table-contents"><table summary="Standard Filter&#xA;            Aliases and Ordering" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Alias</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Filter Class</th><th style="border-bottom: 0.5pt solid ; " align="center">Namespace Element or
                  Attribute</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">
                    CHANNEL_FILTER</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="literal">ChannelProcessingFilter</code></td><td style="border-bottom: 0.5pt solid ; " align="left"><code class="literal">http/intercept-url@requires-channel</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">
                  CONCURRENT_SESSION_FILTER</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="literal">ConcurrentSessionFilter</code>
                </td><td style="border-bottom: 0.5pt solid ; " align="left"><code class="literal">session-management/concurrency-control</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">
                  SECURITY_CONTEXT_FILTER</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="classname">SecurityContextPersistenceFilter</code></td><td style="border-bottom: 0.5pt solid ; " align="left"><code class="literal">http</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">
                  LOGOUT_FILTER
                    </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="literal">LogoutFilter</code></td><td style="border-bottom: 0.5pt solid ; " align="left"><code class="literal">http/logout</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">
                  X509_FILTER
                    </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="literal">X509AuthenticationFilter</code></td><td style="border-bottom: 0.5pt solid ; " align="left"><code class="literal">http/x509</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">
                  PRE_AUTH_FILTER
                    </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="literal">AstractPreAuthenticatedProcessingFilter</code>
                  Subclasses</td><td style="border-bottom: 0.5pt solid ; " align="left">N/A</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"> CAS_FILTER
                    </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="literal">CasAuthenticationFilter</code></td><td style="border-bottom: 0.5pt solid ; " align="left">N/A</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">
                  FORM_LOGIN_FILTER
                    </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="literal">UsernamePasswordAuthenticationFilter</code></td><td style="border-bottom: 0.5pt solid ; " align="left"><code class="literal">http/form-login</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">
                  BASIC_AUTH_FILTER
                  </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="literal">BasicAuthenticationFilter</code></td><td style="border-bottom: 0.5pt solid ; " align="left"><code class="literal">http/http-basic</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">
                  SERVLET_API_SUPPORT_FILTER</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="literal">SecurityContextHolderAwareFilter</code></td><td style="border-bottom: 0.5pt solid ; " align="left"><code class="literal">http/@servlet-api-provision</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">
                  REMEMBER_ME_FILTER
                    </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="classname">RememberMeAuthenticationFilter</code></td><td style="border-bottom: 0.5pt solid ; " align="left"><code class="literal">http/remember-me</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">
                  ANONYMOUS_FILTER
                  </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="literal">AnonymousAuthenticationFilter</code></td><td style="border-bottom: 0.5pt solid ; " align="left"><code class="literal">http/anonymous</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">
                  SESSION_MANAGEMENT_FILTER</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="literal">SessionManagementFilter</code></td><td style="border-bottom: 0.5pt solid ; " align="left"><code class="literal">session-management</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">EXCEPTION_TRANSLATION_FILTER
                    </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="classname">ExceptionTranslationFilter</code></td><td style="border-bottom: 0.5pt solid ; " align="left"><code class="literal">http</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">
                  FILTER_SECURITY_INTERCEPTOR
                    </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="classname">FilterSecurityInterceptor</code></td><td style="border-bottom: 0.5pt solid ; " align="left"><code class="literal">http</code></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left">
                  SWITCH_USER_FILTER
                  </td><td style="border-right: 0.5pt solid ; " align="left"><code class="literal">SwitchUserFilter</code></td><td style="" align="left">N/A</td></tr></tbody></table></div></div><p><br class="table-break">
        You can add your own filter to the stack, using the <code class="literal">custom-filter</code> element
        and one of these names to specify the position your filter should appear at: </p><pre class="programlisting">
  <span class="hl-tag">&lt;http&gt;</span>
     <span class="hl-tag">&lt;custom-filter</span> <span class="hl-attribute">position</span>=<span class="hl-value">"FORM_LOGIN_FILTER"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myFilter"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-tag">&lt;/http&gt;</span>

  <span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myFilter"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.mycompany.MySpecialAuthenticationFilter"</span><span class="hl-tag">/&gt;</span>
  
  </pre><p> You can also use the <code class="literal">after</code> or <code class="literal">before</code>
        attributes if you want your filter to be inserted before or after another filter in the
        stack. The names "FIRST" and "LAST" can be used with the <code class="literal">position</code>
        attribute to indicate that you want your filter to appear before or after the entire stack,
        respectively. </p>
      <div class="tip" title="Avoiding filter position conflicts" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: Avoiding filter position conflicts"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Avoiding filter position conflicts</th></tr><tr><td align="left" valign="top">
        
        <p> If you are inserting a custom filter which may occupy the same position as one of the
          standard filters created by the namespace then it's important that you don't include the
          namespace versions by mistake. Avoid using the <code class="literal">auto-config</code> attribute
          and remove any elements which create filters whose functionality you want to replace. </p>
        <p> Note that you can't replace filters which are created by the use of the
            <code class="literal">&lt;http&gt;</code> element itself -
            <code class="classname">SecurityContextPersistenceFilter</code>,
            <code class="classname">ExceptionTranslationFilter</code> or
            <code class="classname">FilterSecurityInterceptor</code>. </p>
      </td></tr></table></div>
      <p> If you're replacing a namespace filter which requires an authentication entry point
        (i.e. where the authentication process is triggered by an attempt by an unauthenticated user
        to access to a secured resource), you will need to add a custom entry point bean too. </p>
      <div class="section" title="Setting a Custom AuthenticationEntryPoint"><div class="titlepage"><div><div><h4 class="title"><a name="ns-entry-point-ref"></a>Setting a Custom <code class="interfacename">AuthenticationEntryPoint</code></h4></div></div></div>
        
        <p> If you aren't using form login, OpenID or basic authentication through the namespace,
          you may want to define an authentication filter and entry point using a traditional bean
          syntax and link them into the namespace, as we've just seen. The corresponding
            <code class="interfacename">AuthenticationEntryPoint</code> can be set using the
            <code class="literal">entry-point-ref</code> attribute on the <code class="literal">&lt;http&gt;</code>
          element. </p>
        <p> The CAS sample application is a good example of the use of custom beans with the
          namespace, including this syntax. If you aren't familiar with authentication entry points,
          they are discussed in the <a class="ulink" href="#tech-intro-auth-entry-point" target="_top">technical
            overview</a> chapter. </p>
      </div>
    </div>
  </div>
  <div class="section" title="2.4&nbsp;Method Security"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ns-method-security"></a>2.4&nbsp;Method Security</h2></div></div></div>
    
    <p>From version 2.0 onwards Spring Security has improved support substantially for adding
      security to your service layer methods. It provides support for JSR-250 annotation security as
      well as the framework's original <code class="literal">@Secured</code> annotation. From 3.0 you can also
      make use of new <a class="ulink" href="#el-access" target="_top">expression-based annotations</a>. You can
      apply security to a single bean, using the <code class="literal">intercept-methods</code> element to
      decorate the bean declaration, or you can secure multiple beans across the entire service
      layer using the AspectJ style pointcuts. </p>
    <div class="section" title="2.4.1&nbsp;The <global-method-security&gt; Element"><div class="titlepage"><div><div><h3 class="title"><a name="ns-global-method"></a>2.4.1&nbsp;The <code class="literal">&lt;global-method-security&gt;</code> Element</h3></div></div></div>
      
      <p> This element is used to enable annotation-based security in your application (by
        setting the appropriate attributes on the element), and also to group together security
        pointcut declarations which will be applied across your entire application context. You
        should only declare one <code class="literal">&lt;global-method-security&gt;</code> element. The
        following declaration would enable support for Spring Security's
        <code class="literal">@Secured</code>: </p><pre class="programlisting">
  &lt;global-method-security secured-annotations="enabled" /&gt;
  
</pre><p> Adding an annotation to a method (on an class or interface) would then limit
        the access to that method accordingly. Spring Security's native annotation support defines a
        set of attributes for the method. These will be passed to the
          <code class="interfacename">AccessDecisionManager</code> for it to make the actual decision:
        </p><pre class="programlisting">
  <span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> BankService {

    <i><span class="hl-annotation" style="color: gray">@Secured("IS_AUTHENTICATED_ANONYMOUSLY")</span></i>
    <span class="hl-keyword">public</span> Account readAccount(Long id);

    <i><span class="hl-annotation" style="color: gray">@Secured("IS_AUTHENTICATED_ANONYMOUSLY")</span></i>
    <span class="hl-keyword">public</span> Account[] findAccounts();

    <i><span class="hl-annotation" style="color: gray">@Secured("ROLE_TELLER")</span></i>
    <span class="hl-keyword">public</span> Account post(Account account, <span class="hl-keyword">double</span> amount);
  }
</pre><p>Support
        for JSR-250 annotations can be enabled using </p><pre class="programlisting">
  &lt;global-method-security jsr250-annotations="enabled" /&gt;
  
        </pre><p>These are standards-based and allow simple role-based constraints to be
        applied but do not have the power Spring Security's native annotations.
        To use the new expression-based syntax, you would use
</p><pre class="programlisting">
  &lt;global-method-security pre-post-annotations="enabled" /&gt;
  </pre><p>and the equivalent Java code would
        be</p><pre class="programlisting">
   <span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> BankService {

     <i><span class="hl-annotation" style="color: gray">@PreAuthorize("isAnonymous()")</span></i>
     <span class="hl-keyword">public</span> Account readAccount(Long id);

     <i><span class="hl-annotation" style="color: gray">@PreAuthorize("isAnonymous()")</span></i>
     <span class="hl-keyword">public</span> Account[] findAccounts();

     <i><span class="hl-annotation" style="color: gray">@PreAuthorize("hasAuthority('ROLE_TELLER')")</span></i>
     <span class="hl-keyword">public</span> Account post(Account account, <span class="hl-keyword">double</span> amount);
   }
        </pre><p>Expression-based
        annotations are a good choice if you need to define simple rules that go beyond checking the
        role names against the user's list of authorities. You can enable more than one type of
        annotation in the same application, but you should avoid mixing annotations types in the
        same interface or class to avoid confusion.</p>
      <div class="section" title="Adding Security Pointcuts using protect-pointcut"><div class="titlepage"><div><div><h4 class="title"><a name="ns-protect-pointcut"></a>Adding Security Pointcuts using <code class="literal">protect-pointcut</code></h4></div></div></div>
        
        <p> The use of <code class="literal">protect-pointcut</code> is particularly powerful, as it allows
          you to apply security to many beans with only a simple declaration. Consider the following
          example: </p><pre class="programlisting">
  <span class="hl-tag">&lt;global-method-security&gt;</span>
    <span class="hl-tag">&lt;protect-pointcut</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* com.mycompany.*Service.*(..))"</span>
         <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_USER"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/global-method-security&gt;</span>

          </pre><p> This will protect all methods on beans declared in the application
          context whose classes are in the <code class="literal">com.mycompany</code> package and whose class
          names end in "Service". Only users with the <code class="literal">ROLE_USER</code> role will be able
          to invoke these methods. As with URL matching, the most specific matches must come first
          in the list of pointcuts, as the first matching expression will be used. </p>
      </div>
    </div>
  </div>
  <div class="section" title="2.5&nbsp;The Default AccessDecisionManager"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ns-access-manager"></a>2.5&nbsp;The Default AccessDecisionManager</h2></div></div></div>
    
    <p> This section assumes you have some knowledge of the underlying architecture for
      access-control within Spring Security. If you don't you can skip it and come back to it later,
      as this section is only really relevant for people who need to do some customization in order
      to use more than simple role-based security. </p>
    <p> When you use a namespace configuration, a default instance of
        <code class="interfacename">AccessDecisionManager</code> is automatically registered for you and
      will be used for making access decisions for method invocations and web URL access, based on
      the access attributes you specify in your <code class="literal">intercept-url</code> and
        <code class="literal">protect-pointcut</code> declarations (and in annotations if you are using
      annotation secured methods). </p>
    <p> The default strategy is to use an <code class="classname">AffirmativeBased</code>
      <code class="interfacename">AccessDecisionManager</code> with a <code class="classname">RoleVoter</code>
      and an <code class="classname">AuthenticatedVoter</code>. You can find out more about these in the
      chapter on <a class="ulink" href="authorization" target="_top">authorization</a>.</p>
    <div class="section" title="2.5.1&nbsp;Customizing the AccessDecisionManager"><div class="titlepage"><div><div><h3 class="title"><a name="ns-custom-access-mgr"></a>2.5.1&nbsp;Customizing the AccessDecisionManager</h3></div></div></div>
      
      <p> If you need to use a more complicated access control strategy then it is easy to set an
        alternative for both method and web security. </p>
      <p> For method security, you do this by setting the
          <code class="literal">access-decision-manager-ref</code> attribute on
          <code class="literal">global-method-security</code> to the Id of the appropriate
          <code class="interfacename">AccessDecisionManager</code> bean in the application context: </p><pre class="programlisting">
  <span class="hl-tag">&lt;global-method-security</span> <span class="hl-attribute">access-decision-manager-ref</span>=<span class="hl-value">"myAccessDecisionManagerBean"</span><span class="hl-tag">&gt;</span>
    ...
  <span class="hl-tag">&lt;/global-method-security&gt;</span>
  </pre>
      <p> The syntax for web security is the same, but on the <code class="literal">http</code> element: </p><pre class="programlisting">
  <span class="hl-tag">&lt;http</span> <span class="hl-attribute">access-decision-manager-ref</span>=<span class="hl-value">"myAccessDecisionManagerBean"</span><span class="hl-tag">&gt;</span>
    ...
  <span class="hl-tag">&lt;/http&gt;</span>
  </pre>
    </div>
  </div>
  <div class="section" title="2.6&nbsp;The Authentication Manager and the Namespace"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ns-auth-manager"></a>2.6&nbsp;The Authentication Manager and the Namespace</h2></div></div></div>
    
    <p> The main interface which provides authentication services in Spring Security is the
        <code class="interfacename">AuthenticationManager</code>. This is usually an instance of Spring
      Security's <code class="classname">ProviderManager</code> class, which you may already be familiar
      with if you've used the framework before. If not, it will be covered later, in the <a class="ulink" href="#tech-intro-authentication" target="_top">technical overview chapter</a>. The bean instance
      is registered using the <code class="literal">authentication-manager</code> namespace element. You can't
      use a custom <code class="classname">AuthenticationManager</code> if you are using either HTTP or
      method security through the namespace, but this should not be a problem as you have full
      control over the <code class="classname">AuthenticationProvider</code>s that are used.</p>
    <p> You may want to register additional <code class="classname">AuthenticationProvider</code> beans
      with the <code class="classname">ProviderManager</code> and you can do this using the
        <code class="literal">&lt;authentication-provider&gt;</code> element with the <code class="literal">ref</code>
      attribute, where the value of the attribute is the name of the provider bean you want to add.
      For example: </p><pre class="programlisting">
  <span class="hl-tag">&lt;authentication-manager&gt;</span>
    <span class="hl-tag">&lt;authentication-provider</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"casAuthenticationProvider"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/authentication-manager&gt;</span>

  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"casAuthenticationProvider"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.cas.authentication.CasAuthenticationProvider"</span><span class="hl-tag">&gt;</span>
    ...
  <span class="hl-tag">&lt;/bean&gt;</span>
  </pre>
    <p> Another common requirement is that another bean in the context may require a reference to
      the <code class="interfacename">AuthenticationManager</code>. You can easily register an alias for
      the <code class="interfacename">AuthenticationManager</code> and use this name elsewhere in your
      application context. </p><pre class="programlisting">
  <span class="hl-tag">&lt;security:authentication-manager</span> <span class="hl-attribute">alias</span>=<span class="hl-value">"authenticationManager"</span><span class="hl-tag">&gt;</span>
     ...
  <span class="hl-tag">&lt;/security:authentication-manager&gt;</span>

  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"customizedFormLoginFilter"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"com.somecompany.security.web.CustomFormLoginFilter"</span><span class="hl-tag">&gt;</span>
     <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"authenticationManager"</span><span class="hl-tag">/&gt;</span>
     ...
  <span class="hl-tag">&lt;/bean&gt;</span>
  </pre>
  </div>
<div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d4e201" href="#d4e201" class="para">1</a>] </sup>You can find
          out more about the use of the <code class="literal">ldap-server</code> element in the chapter on
            <a class="ulink" href="#ldap" target="_top">LDAP</a>.</p></div><div class="footnote"><p><sup>[<a name="ftn.d4e257" href="#d4e257" class="para">2</a>] </sup>The
            interpretation of the comma-separated values in the <code class="literal">access</code> attribute
            depends on the implementation of the <a class="ulink" href="#ns-access-manager" target="_top">AccessDecisionManager</a> which is used. In Spring Security 3.0, the attribute can
            also be populated with an <a class="ulink" href="#el-access" target="_top">EL
          expression</a>.</p></div><div class="footnote"><p><sup>[<a name="ftn.d4e299" href="#d4e299" class="para">3</a>] </sup>In versions prior
              to 3.0, this list also included remember-me functionality. This could cause some
              confusing errors with some configurations and was removed in 3.0. In 3.0, the addition
              of an <code class="classname">AnonymousAuthenticationFilter</code> is part of the default
                <code class="literal">&lt;http&gt;</code> configuration, so the <code class="literal">&lt;anonymous
                /&gt;</code> element is added regardless of whether <code class="literal">auto-config</code>
              is enabled.</p></div><div class="footnote"><p><sup>[<a name="ftn.d4e312" href="#d4e312" class="para">4</a>] </sup>See the
              chapter on <a class="ulink" href="#anonymous" target="_top">anonymous authentication</a> and also the
                <a class="ulink" href="#authz-authenticated-voter" target="_top">AuthenticatedVoter</a> class for
              more details on how the value <code class="literal">IS_AUTHENTICATED_ANONYMOUSLY</code> is
              processed.</p></div></div></div>
    <div class="chapter" title="3.&nbsp;Sample Applications"><div class="titlepage"><div><div><h2 class="title"><a name="sample-apps"></a>3.&nbsp;Sample Applications</h2></div></div></div>
    
    <p> There are several sample web applications that are available with the project. To avoid
        an overly large download, only the "tutorial" and "contacts" samples are included in the
        distribution zip file. You can either build the others yourself, or you can obtain the war
        files individually from the central Maven repository. We'd recommend the former. You can get
        the source as described in <a class="ulink" href="#get-source" target="_top">the introduction</a> and it's
        easy to build the project using Maven. There is more information on the project web site at
            <a class="ulink" href="http://www.springsource.org/security/" target="_top">
            http://www.springsource.org/security/ </a> if you need it. All paths referred to in
        this chapter are relative to the project source directory. </p>
    <div class="section" title="3.1&nbsp;Tutorial Sample"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-sample"></a>3.1&nbsp;Tutorial Sample</h2></div></div></div>
        
        <p> The tutorial sample is a nice basic example to get you started. It uses simple
            namespace configuration throughout. The compiled application is included in the
            distribution zip file, ready to be deployed into your web container
                (<code class="filename">spring-security-samples-tutorial-3.0.x.war</code>). The <a class="ulink" href="#ns-form-and-basic" target="_top">form-based</a> authentication mechanism is used
            in combination with the commonly-used <a class="ulink" href="#remember-me" target="_top">remember-me</a>
            authentication provider to automatically remember the login using cookies.</p>
        <p>We recommend you start with the tutorial sample, as the XML is minimal and easy to
            follow. Most importantly, you can easily add this one XML file (and its corresponding
                <code class="literal">web.xml</code> entries) to your existing application. Only when this
            basic integration is achieved do we suggest you attempt adding in method authorization
            or domain object security.</p>
    </div>
    <div class="section" title="3.2&nbsp;Contacts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="contacts-sample"></a>3.2&nbsp;Contacts</h2></div></div></div>
        
        <p> The Contacts Sample is an advanced example in that it illustrates the more powerful
            features of domain object access control lists (ACLs) in addition to basic application
            security. The application provides an interface with which the users are able to
            administer a simple database of contacts (the domain objects).</p>
        <p>To deploy, simply copy the WAR file from Spring Security distribution into your
            container&#8217;s <code class="literal">webapps</code> directory. The war should be called
                <code class="filename">spring-security-samples-contacts-3.0.x.war</code> (the appended
            version number will vary depending on what release you are using). </p>
        <p>After starting your container, check the application can load. Visit
                <code class="literal">http://localhost:8080/contacts</code> (or whichever URL is appropriate
            for your web container and the WAR you deployed). </p>
        <p>Next, click "Debug". You will be prompted to authenticate, and a series of usernames
            and passwords are suggested on that page. Simply authenticate with any of these and view
            the resulting page. It should contain a success message similar to the following:
            </p><div class="literallayout"><p><br>
Security&nbsp;Debug&nbsp;Information<br>
<br>
Authentication&nbsp;object&nbsp;is&nbsp;of&nbsp;type:<br>
org.springframework.security.authentication.UsernamePasswordAuthenticationToken<br>
<br>
Authentication&nbsp;object&nbsp;as&nbsp;a&nbsp;String:<br>
<br>
org.springframework.security.authentication.UsernamePasswordAuthenticationToken@1f127853:<br>
Principal:&nbsp;org.springframework.security.core.userdetails.User@b07ed00:&nbsp;Username:&nbsp;rod;&nbsp;\<br>
Password:&nbsp;[PROTECTED];&nbsp;Enabled:&nbsp;true;&nbsp;AccountNonExpired:&nbsp;true;<br>
credentialsNonExpired:&nbsp;true;&nbsp;AccountNonLocked:&nbsp;true;&nbsp;\<br>
Granted&nbsp;Authorities:&nbsp;ROLE_SUPERVISOR,&nbsp;ROLE_USER;&nbsp;\<br>
Password:&nbsp;[PROTECTED];&nbsp;Authenticated:&nbsp;true;&nbsp;\<br>
Details:&nbsp;org.springframework.security.web.authentication.WebAuthenticationDetails@0:&nbsp;\<br>
RemoteIpAddress:&nbsp;127.0.0.1;&nbsp;SessionId:&nbsp;8fkp8t83ohar;&nbsp;\<br>
Granted&nbsp;Authorities:&nbsp;ROLE_SUPERVISOR,&nbsp;ROLE_USER<br>
<br>
Authentication&nbsp;object&nbsp;holds&nbsp;the&nbsp;following&nbsp;granted&nbsp;authorities:<br>
<br>
ROLE_SUPERVISOR&nbsp;(getAuthority():&nbsp;ROLE_SUPERVISOR)<br>
ROLE_USER&nbsp;(getAuthority():&nbsp;ROLE_USER)<br>
<br>
Success!&nbsp;Your&nbsp;web&nbsp;filters&nbsp;appear&nbsp;to&nbsp;be&nbsp;properly&nbsp;configured!<br>
&nbsp;&nbsp;&nbsp;&nbsp;</p></div>
        <p>Once you successfully receive the above message, return to the sample application's
            home page and click "Manage". You can then try out the application. Notice that only the
            contacts available to the currently logged on user are displayed, and only users with
                <code class="literal">ROLE_SUPERVISOR</code> are granted access to delete their contacts.
            Behind the scenes, the <code class="classname">MethodSecurityInterceptor</code> is securing the
            business objects. </p>
        <p>The application allows you to modify the access control lists associated with
            different contacts. Be sure to give this a try and understand how it works by reviewing
            the application context XML files.</p>
        
    </div>
    <div class="section" title="3.3&nbsp;LDAP Sample"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ldap-sample"></a>3.3&nbsp;LDAP Sample</h2></div></div></div>
        
        <p> The LDAP sample application provides a basic configuration and sets up both a
            namespace configuration and an equivalent configuration using traditional beans, both in
            the same application context file. This means there are actually two identical
            authentication providers configured in this application. </p>
    </div>
    <div class="section" title="3.4&nbsp;CAS Sample"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cas-sample"></a>3.4&nbsp;CAS Sample</h2></div></div></div>
        
        <p> The CAS sample requires that you run both a CAS server and CAS client. It isn't
            included in the distribution so you should check out the project code as described in
                <a class="ulink" href="#get-source" target="_top">the introduction</a>. You'll find the relevant
            files under the <code class="filename">sample/cas</code> directory. There's also a
                <code class="filename">Readme.txt</code> file in there which explains how to run both the
            server and the client directly from the source tree, complete with SSL support. You have
            to download the CAS Server web application (a war file) from the CAS site and drop it
            into the <code class="filename">samples/cas/server</code> directory. </p>
    </div>
    <div class="section" title="3.5&nbsp;Pre-Authentication Sample"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="preauth-sample"></a>3.5&nbsp;Pre-Authentication Sample</h2></div></div></div>
        
        <p> This sample application demonstrates how to wire up beans from the <a class="ulink" href="#preauth" target="_top">pre-authentication</a> framework to make use of login
            information from a J2EE container. The user name and roles are those setup by the
            container. </p>
        <p> The code is in <code class="filename">samples/preauth</code>. </p>
    </div>
</div>
    <div class="chapter" title="4.&nbsp;Spring Security Community"><div class="titlepage"><div><div><h2 class="title"><a name="community"></a>4.&nbsp;Spring Security Community</h2></div></div></div>
    
    <div class="section" title="4.1&nbsp;Issue Tracking"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jira"></a>4.1&nbsp;Issue Tracking</h2></div></div></div>
        
        <p>Spring Security uses JIRA to manage bug reports and enhancement requests. If you find
            a bug, please log a report using JIRA. Do not log it on the support forum, mailing list
            or by emailing the project's developers. Such approaches are ad-hoc and we prefer to
            manage bugs using a more formal process.</p>
        <p>If possible, in your issue report please provide a JUnit test that demonstrates any
            incorrect behaviour. Or, better yet, provide a patch that corrects the issue. Similarly,
            enhancements are welcome to be logged in the issue tracker, although we only accept
            enhancement requests if you include corresponding unit tests. This is necessary to
            ensure project test coverage is adequately maintained.</p>
        <p>You can access the issue tracker at <a class="ulink" href="http://jira.springsource.org/browse/SEC" target="_top">http://jira.springsource.org/browse/SEC</a>. </p>
    </div>
    <div class="section" title="4.2&nbsp;Becoming Involved"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="becoming-involved"></a>4.2&nbsp;Becoming Involved</h2></div></div></div>
        
        <p>We welcome your involvement in the Spring Security project. There are many ways of
            contributing, including reading the forum and responding to questions from other people,
            writing new code, improving existing code, assisting with documentation, developing
            samples or tutorials, or simply making suggestions.</p>
        
    </div>
    <div class="section" title="4.3&nbsp;Further Information"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="further-info"></a>4.3&nbsp;Further Information</h2></div></div></div>
        
        <p>Questions and comments on Spring Security are welcome. You can use the Spring
            Community Forum web site at <code class="uri"><a class="uri" href="http://forum.springsource.org" target="_top">http://forum.springsource.org</a></code> to discuss Spring Security with other users of
            the framework. Remember to use JIRA for bug reports, as explained above.</p>
    </div>
</div>
  </div>
  <div class="part" title="Part&nbsp;II.&nbsp;Architecture and Implementation"><div class="titlepage"><div><div><h1 class="title"><a name="overall-architecture"></a>Part&nbsp;II.&nbsp;Architecture and Implementation</h1></div></div></div>
    
    <div class="partintro" title="Architecture and Implementation"><div></div>
      <p>Once you are familiar with setting up and running some namespace-configuration based
        applications, you may wish to develop more of an understanding of how the framework actually
        works behind the namespace facade. Like most software, Spring Security has certain central
        interfaces, classes and conceptual abstractions that are commonly used throughout the
        framework. In this part of the reference guide we will look at some of these and see how
        they work together to support authentication and access-control within Spring
        Security.</p>
    </div>
    <div class="chapter" title="5.&nbsp;Technical Overview"><div class="titlepage"><div><div><h2 class="title"><a name="technical-overview"></a>5.&nbsp;Technical Overview</h2></div></div></div>
  
  <div class="section" title="5.1&nbsp;Runtime Environment"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="runtime-environment"></a>5.1&nbsp;Runtime Environment</h2></div></div></div>
    
    <p>Spring Security 3.0 requires a Java 5.0 Runtime Environment or higher. As Spring Security
      aims to operate in a self-contained manner, there is no need to place any special
      configuration files into your Java Runtime Environment. In particular, there is no need to
      configure a special Java Authentication and Authorization Service (JAAS) policy file or place
      Spring Security into common classpath locations.</p>
    <p>Similarly, if you are using an EJB Container or Servlet Container there is no need to put
      any special configuration files anywhere, nor include Spring Security in a server classloader.
      All the required files will be contained within your application.</p>
    <p>This design offers maximum deployment time flexibility, as you can simply copy your target
      artifact (be it a JAR, WAR or EAR) from one system to another and it will immediately
      work.</p>
  </div>
  <div class="section" title="5.2&nbsp;Core Components"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core-components"></a>5.2&nbsp;Core Components</h2></div></div></div>
    
    <p>In Spring Security 3.0, the contents of the <code class="filename">spring-security-core</code> jar
      were stripped down to the bare minimum. It no longer contains any code related to
      web-application security, LDAP or namespace configuration. We'll take a look here at some of
      the Java types that you'll find in the core module. They represent the building blocks of the
      the framework, so if you ever need to go beyond a simple namespace configuration then it's
      important that you understand what they are, even if you don't actually need to interact with
      them directly.</p>
    <div class="section" title="5.2.1&nbsp; SecurityContextHolder, SecurityContext and Authentication Objects"><div class="titlepage"><div><div><h3 class="title"><a name="d4e733"></a>5.2.1&nbsp; SecurityContextHolder, SecurityContext and Authentication Objects </h3></div></div></div>
      
      <p>The most fundamental object is <code class="classname">SecurityContextHolder</code>. This is
        where we store details of the present security context of the application, which includes
        details of the principal currently using the application. By default the
          <code class="classname">SecurityContextHolder</code> uses a <code class="literal">ThreadLocal</code> to
        store these details, which means that the security context is always available to methods in
        the same thread of execution, even if the security context is not explicitly passed around
        as an argument to those methods. Using a <code class="literal">ThreadLocal</code> in this way is quite
        safe if care is taken to clear the thread after the present principal's request is
        processed. Of course, Spring Security takes care of this for you automatically so there is
        no need to worry about it.</p>
      <p>Some applications aren't entirely suitable for using a <code class="literal">ThreadLocal</code>,
        because of the specific way they work with threads. For example, a Swing client might want
        all threads in a Java Virtual Machine to use the same security context.
          <code class="classname">SecurityContextHolder</code> can be configured with a strategy on startup
        to specify how you would like the context to be stored. For a standalone application you
        would use the <code class="literal">SecurityContextHolder.MODE_GLOBAL</code> strategy. Other
        applications might want to have threads spawned by the secure thread also assume the same
        security identity. This is achieved by using
          <code class="literal">SecurityContextHolder.MODE_INHERITABLETHREADLOCAL</code>. You can change the
        mode from the default <code class="literal">SecurityContextHolder.MODE_THREADLOCAL</code> in two ways.
        The first is to set a system property, the second is to call a static method on
          <code class="classname">SecurityContextHolder</code>. Most applications won't need to change from
        the default, but if you do, take a look at the JavaDocs for
          <code class="classname">SecurityContextHolder</code> to learn more.</p>
      <div class="section" title="Obtaining information about the current user"><div class="titlepage"><div><div><h4 class="title"><a name="d4e748"></a>Obtaining information about the current user</h4></div></div></div>
        
        <p>Inside the <code class="classname">SecurityContextHolder</code> we store details of the
          principal currently interacting with the application. Spring Security uses an
            <code class="interfacename">Authentication</code> object to represent this information. You
          won't normally need to create an <code class="interfacename">Authentication</code> object
          yourself, but it is fairly common for users to query the
            <code class="interfacename">Authentication</code> object. You can use the following code
          block - from anywhere in your application - to obtain the name of the currently
          authenticated user, for example:</p>
        <pre class="programlisting">
Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();

<span class="hl-keyword">if</span> (principal <span class="hl-keyword">instanceof</span> UserDetails) {
  String username = ((UserDetails)principal).getUsername();
} <span class="hl-keyword">else</span> {
  String username = principal.toString();
}</pre>
        <p>The object returned by the call to <code class="methodname">getContext()</code> is an
          instance of the <code class="interfacename">SecurityContext</code> interface. This is the
          object that is kept in thread-local storage. As we'll see below, most authentication
          mechanisms withing Spring Security return an instance of
            <code class="interfacename">UserDetails</code> as the principal. </p>
      </div>
    </div>
    <div class="section" title="5.2.2&nbsp;The UserDetailsService"><div class="titlepage"><div><div><h3 class="title"><a name="d4e760"></a>5.2.2&nbsp;The UserDetailsService</h3></div></div></div>
      
      <p>Another item to note from the above code fragment is that you can obtain a principal
        from the <code class="interfacename">Authentication</code> object. The principal is just an
          <code class="literal">Object</code>. Most of the time this can be cast into a
          <code class="interfacename">UserDetails</code> object.
          <code class="interfacename">UserDetails</code> is a central interface in Spring Security. It
        represents a principal, but in an extensible and application-specific way. Think of
          <code class="interfacename">UserDetails</code> as the adapter between your own user database
        and what Spring Security needs inside the <code class="classname">SecurityContextHolder</code>.
        Being a representation of something from your own user database, quite often you will cast
        the <code class="interfacename">UserDetails</code> to the original object that your application
        provided, so you can call business-specific methods (like <code class="literal">getEmail()</code>,
          <code class="literal">getEmployeeNumber()</code> and so on).</p>
      <p>By now you're probably wondering, so when do I provide a
          <code class="interfacename">UserDetails</code> object? How do I do that? I thought you said
        this thing was declarative and I didn't need to write any Java code - what gives? The short
        answer is that there is a special interface called
          <code class="interfacename">UserDetailsService</code>. The only method on this interface
        accepts a <code class="literal">String</code>-based username argument and returns a
          <code class="interfacename">UserDetails</code>:
        </p><pre class="programlisting">
  UserDetails loadUserByUsername(String username) <span class="hl-keyword">throws</span> UsernameNotFoundException;
</pre><p>
        This is the most common approach to loading information for a user within Spring Security
        and you will see it used throughout the framework whenever information on a user is
        required.</p>
      <p> On successful authentication, <code class="interfacename">UserDetails</code> is used to
        build the <code class="interfacename">Authentication</code> object that is stored in the
          <code class="classname">SecurityContextHolder</code> (more on this <a class="ulink" href="#tech-intro-authentication" target="_top">below</a>). The good news is that we provide a
        number of <code class="interfacename">UserDetailsService</code> implementations, including one
        that uses an in-memory map (<code class="classname">InMemoryDaoImpl</code>) and another that uses
        JDBC (<code class="classname">JdbcDaoImpl</code>). Most users tend to write their own, though, with
        their implementations often simply sitting on top of an existing Data Access Object (DAO)
        that represents their employees, customers, or other users of the application. Remember the
        advantage that whatever your <code class="interfacename">UserDetailsService</code> returns can
        always be obtained from the <code class="classname">SecurityContextHolder</code> using the above
        code fragment. </p>
    </div>
    <div class="section" title="5.2.3&nbsp;GrantedAuthority"><div class="titlepage"><div><div><h3 class="title"><a name="tech-granted-authority"></a>5.2.3&nbsp;GrantedAuthority</h3></div></div></div>
      
      <p>Besides the principal, another important method provided by
          <code class="interfacename">Authentication</code> is <code class="literal">getAuthorities(</code>). This
        method provides an array of <code class="interfacename">GrantedAuthority</code> objects. A
          <code class="interfacename">GrantedAuthority</code> is, not surprisingly, an authority that is
        granted to the principal. Such authorities are usually <span class="quote">&#8220;<span class="quote">roles</span>&#8221;</span>, such as
          <code class="literal">ROLE_ADMINISTRATOR</code> or <code class="literal">ROLE_HR_SUPERVISOR</code>. These
        roles are later on configured for web authorization, method authorization and domain object
        authorization. Other parts of Spring Security are capable of interpreting these authorities,
        and expect them to be present. <code class="interfacename">GrantedAuthority</code> objects are
        usually loaded by the <code class="interfacename">UserDetailsService</code>.</p>
      <p>Usually the <code class="interfacename">GrantedAuthority</code> objects are application-wide
        permissions. They are not specific to a given domain object. Thus, you wouldn't likely have
        a <code class="interfacename">GrantedAuthority</code> to represent a permission to
          <code class="literal">Employee</code> object number 54, because if there are thousands of such
        authorities you would quickly run out of memory (or, at the very least, cause the
        application to take a long time to authenticate a user). Of course, Spring Security is
        expressly designed to handle this common requirement, but you'd instead use the project's
        domain object security capabilities for this purpose.</p>
    </div>
    <div class="section" title="5.2.4&nbsp;Summary"><div class="titlepage"><div><div><h3 class="title"><a name="d4e804"></a>5.2.4&nbsp;Summary</h3></div></div></div>
      
      <p>Just to recap, the major building blocks of Spring Security that we've seen so far
        are:</p>
      <div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
          <p><code class="classname">SecurityContextHolder</code>, to provide access to the
              <code class="interfacename">SecurityContext</code>.</p>
        </li><li class="listitem">
          <p><code class="interfacename">SecurityContext</code>, to hold the
              <code class="interfacename">Authentication</code> and possibly request-specific security
            information.</p>
        </li><li class="listitem">
          <p><code class="interfacename">Authentication</code>, to represent the principal in a
            Spring Security-specific manner.</p>
        </li><li class="listitem">
          <p><code class="interfacename">GrantedAuthority</code>, to reflect the application-wide
            permissions granted to a principal.</p>
        </li><li class="listitem">
          <p><code class="interfacename">UserDetails</code>, to provide the necessary information to
            build an Authentication object from your application's DAOs or other source source of
            security data.</p>
        </li><li class="listitem">
          <p><code class="interfacename">UserDetailsService</code>, to create a
              <code class="interfacename">UserDetails</code> when passed in a
            <code class="literal">String</code>-based username (or certificate ID or the like).</p>
        </li></ul></div>
      <p>Now that you've gained an understanding of these repeatedly-used components, let's take
        a closer look at the process of authentication.</p>
    </div>
  </div>
  <div class="section" title="5.3&nbsp;Authentication"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tech-intro-authentication"></a>5.3&nbsp;Authentication</h2></div></div></div>
    
    <p>Spring Security can participate in many different authentication environments. While we
      recommend people use Spring Security for authentication and not integrate with existing
      Container Managed Authentication, it is nevertheless supported - as is integrating with your
      own proprietary authentication system. </p>
    <div class="section" title="5.3.1&nbsp;What is authentication in Spring Security?"><div class="titlepage"><div><div><h3 class="title"><a name="d4e836"></a>5.3.1&nbsp;What is authentication in Spring Security?</h3></div></div></div>
      
      <p> Let's consider a standard authentication scenario that everyone is familiar with.
              </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A user is prompted to log in with a username and
              password.</p></li><li class="listitem"><p>The system (successfully) verifies that the
              password is correct for the username.</p></li><li class="listitem"><p>The context
              information for that user is obtained (their list of roles and so
            on).</p></li><li class="listitem"><p>A security context is established for the
              user</p></li><li class="listitem"><p>The user proceeds, potentially to perform some
              operation which is potentially protected by an access control mechanism which checks
              the required permissions for the operation against the current security context
              information. </p></li></ol></div><p> The first three items constitute the
        authentication process so we'll take a look at how these take place within Spring
              Security.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The username and password are obtained and
              combined into an instance of
                <code class="classname">UsernamePasswordAuthenticationToken</code> (an instance of the
                <code class="interfacename">Authentication</code> interface, which we saw
              earlier).</p></li><li class="listitem"><p>The token is passed to an instance of
                <code class="interfacename">AuthenticationManager</code> for
            validation.</p></li><li class="listitem"><p>The
                <code class="interfacename">AuthenticationManager</code> returns a fully populated
                <code class="interfacename">Authentication</code> instance on successful
              authentication.</p></li><li class="listitem"><p>The security context is established
              by calling <code class="code">SecurityContextHolder.getContext().setAuthentication(...)</code>,
              passing in the returned authentication object.</p></li></ol></div><p>From
        that point on, the user is considered to be authenticated. Let's look at some code as an
        example.
        </p><pre class="programlisting"><span class="hl-keyword">import</span> org.springframework.security.authentication.*;
<span class="hl-keyword">import</span> org.springframework.security.core.*;
<span class="hl-keyword">import</span> org.springframework.security.core.authority.GrantedAuthorityImpl;
<span class="hl-keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AuthenticationExample {
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> AuthenticationManager am = <span class="hl-keyword">new</span> SampleAuthenticationManager();

  <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) <span class="hl-keyword">throws</span> Exception {
    BufferedReader in = <span class="hl-keyword">new</span> BufferedReader(<span class="hl-keyword">new</span> InputStreamReader(System.in));

    <span class="hl-keyword">while</span>(true) {
      System.out.println(<span class="hl-string">"Please enter your username:"</span>);
      String name = in.readLine();
      System.out.println(<span class="hl-string">"Please enter your password:"</span>);
      String password = in.readLine();
      <span class="hl-keyword">try</span> {
        Authentication request = <span class="hl-keyword">new</span> UsernamePasswordAuthenticationToken(name, password);
        Authentication result = am.authenticate(request);
        SecurityContextHolder.getContext().setAuthentication(result);
        <span class="hl-keyword">break</span>;
      } <span class="hl-keyword">catch</span>(AuthenticationException e) {
        System.out.println(<span class="hl-string">"Authentication failed: "</span> + e.getMessage());
      }
    }
    System.out.println(<span class="hl-string">"Successfully authenticated. Security context contains: "</span> +
              SecurityContextHolder.getContext().getAuthentication());
  }
}

<span class="hl-keyword">class</span> SampleAuthenticationManager <span class="hl-keyword">implements</span> AuthenticationManager {
  <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> List&lt;GrantedAuthority&gt; AUTHORITIES = <span class="hl-keyword">new</span> ArrayList&lt;GrantedAuthority&gt;();

  <span class="hl-keyword">static</span> {
    AUTHORITIES.add(<span class="hl-keyword">new</span> GrantedAuthorityImpl(<span class="hl-string">"ROLE_USER"</span>));
  }

  <span class="hl-keyword">public</span> Authentication authenticate(Authentication auth) <span class="hl-keyword">throws</span> AuthenticationException {
    <span class="hl-keyword">if</span> (auth.getName().equals(auth.getCredentials())) {
      <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> UsernamePasswordAuthenticationToken(auth.getName(),
        auth.getCredentials(), AUTHORITIES);
      }
      <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> BadCredentialsException(<span class="hl-string">"Bad Credentials"</span>);
  }
}</pre><p>Here
        we have written a little program that asks the user to enter a username and password and
        performs the above sequence. The <code class="interfacename">AuthenticationManager</code> which
        we've implemented here will authenticate any user whose username and password are the same.
        It assigns a single role to every user. The output from the above will be something
        like:</p><pre class="programlisting">
Please enter your username:
bob
Please enter your password:
password
Authentication failed: Bad Credentials
Please enter your username:
bob
Please enter your password:
bob
Successfully authenticated. Security context contains: \
 org.springframework.security.authentication.UsernamePasswordAuthenticationToken@441d0230: \
 Principal: bob; Password: [PROTECTED]; \
 Authenticated: true; Details: null; \
 Granted Authorities: ROLE_USER
        </pre>
      <p>Note that you don't normally need to write any code like this. The process will normally
        occur internally, in a web authentication filter for example. We've just included the code
        here to show that the question of what actually constitutes authentication in Spring
        Security has quite a simple answer. A user is authenticated when the
          <code class="classname">SecurityContextHolder</code> contains a fully populated
          <code class="interfacename">Authentication</code> object.</p>
    </div>
    <div class="section" title="5.3.2&nbsp;Setting the SecurityContextHolder Contents Directly"><div class="titlepage"><div><div><h3 class="title"><a name="d4e871"></a>5.3.2&nbsp;Setting the SecurityContextHolder Contents Directly</h3></div></div></div>
      
      <p>In fact, Spring Security doesn't mind how you put the
          <code class="interfacename">Authentication</code> object inside the
          <code class="classname">SecurityContextHolder</code>. The only critical requirement is that the
          <code class="classname">SecurityContextHolder</code> contains an
          <code class="interfacename">Authentication</code> which represents a principal before the
          <code class="classname">AbstractSecurityInterceptor</code> (which we'll see more about later)
        needs to authorize a user operation.</p>
      <p>You can (and many users do) write their own filters or MVC controllers to provide
        interoperability with authentication systems that are not based on Spring Security. For
        example, you might be using Container-Managed Authentication which makes the current user
        available from a ThreadLocal or JNDI location. Or you might work for a company that has a
        legacy proprietary authentication system, which is a corporate "standard" over which you
        have little control. In situations like this it's quite easy to get Spring Security to work,
        and still provide authorization capabilities. All you need to do is write a filter (or
        equivalent) that reads the third-party user information from a location, build a Spring
        Security-specific <code class="interfacename">Authentication</code> object, and put it into the
          <code class="classname">SecurityContextHolder</code>.</p>
      <p> If you're wondering how the <code class="interfacename">AuthenticationManager</code>
        manager is implemented in a real world example, we'll look at that in the <a class="ulink" href="#core-services-authentication-manager" target="_top">core services chapter</a>.</p>
    </div>
  </div>
  <div class="section" title="5.4&nbsp;Authentication in a Web Application"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tech-intro-web-authentication"></a>5.4&nbsp;Authentication in a Web Application</h2></div></div></div>
    
    <p> Now let's explore the situation where you are using Spring Security in a web application
      (without <code class="filename">web.xml</code> security enabled). How is a user authenticated and the
      security context established?</p>
    <p>Consider a typical web application's authentication process:</p>
    <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
        <p>You visit the home page, and click on a link.</p>
      </li><li class="listitem">
        <p>A request goes to the server, and the server decides that you've asked for a protected
          resource.</p>
      </li><li class="listitem">
        <p>As you're not presently authenticated, the server sends back a response indicating
          that you must authenticate. The response will either be an HTTP response code, or a
          redirect to a particular web page.</p>
      </li><li class="listitem">
        <p>Depending on the authentication mechanism, your browser will either redirect to the
          specific web page so that you can fill out the form, or the browser will somehow retrieve
          your identity (via a BASIC authentication dialogue box, a cookie, a X.509 certificate
          etc.).</p>
      </li><li class="listitem">
        <p>The browser will send back a response to the server. This will either be an HTTP POST
          containing the contents of the form that you filled out, or an HTTP header containing your
          authentication details.</p>
      </li><li class="listitem">
        <p>Next the server will decide whether or not the presented credentials are valid. If
          they're valid, the next step will happen. If they're invalid, usually your browser will be
          asked to try again (so you return to step two above).</p>
      </li><li class="listitem">
        <p>The original request that you made to cause the authentication process will be
          retried. Hopefully you've authenticated with sufficient granted authorities to access the
          protected resource. If you have sufficient access, the request will be successful.
          Otherwise, you'll receive back an HTTP error code 403, which means "forbidden".</p>
      </li></ol></div>
    <p>Spring Security has distinct classes responsible for most of the steps described above.
      The main participants (in the order that they are used) are the
        <code class="classname">ExceptionTranslationFilter</code>, an
        <code class="interfacename">AuthenticationEntryPoint</code> and an <span class="quote">&#8220;<span class="quote">authentication
        mechanism</span>&#8221;</span>, which is responsible for calling the
        <code class="classname">AuthenticationManager</code> which we saw in the previous section.</p>
    <div class="section" title="5.4.1&nbsp;ExceptionTranslationFilter"><div class="titlepage"><div><div><h3 class="title"><a name="d4e910"></a>5.4.1&nbsp;ExceptionTranslationFilter</h3></div></div></div>
      
      <p><code class="classname">ExceptionTranslationFilter</code> is a Spring Security filter that has
        responsibility for detecting any Spring Security exceptions that are thrown. Such exceptions
        will generally be thrown by an <code class="classname">AbstractSecurityInterceptor</code>, which is
        the main provider of authorization services. We will discuss
          <code class="classname">AbstractSecurityInterceptor</code> in the next section, but for now we
        just need to know that it produces Java exceptions and knows nothing about HTTP or how to go
        about authenticating a principal. Instead the
          <code class="classname">ExceptionTranslationFilter</code> offers this service, with specific
        responsibility for either returning error code 403 (if the principal has been authenticated
        and therefore simply lacks sufficient access - as per step seven above), or launching an
          <code class="interfacename">AuthenticationEntryPoint</code> (if the principal has not been
        authenticated and therefore we need to go commence step three).</p>
    </div>
    <div class="section" title="5.4.2&nbsp;AuthenticationEntryPoint"><div class="titlepage"><div><div><h3 class="title"><a name="tech-intro-auth-entry-point"></a>5.4.2&nbsp;AuthenticationEntryPoint</h3></div></div></div>
      
      <p>The <code class="interfacename">AuthenticationEntryPoint</code> is responsible for step
        three in the above list. As you can imagine, each web application will have a default
        authentication strategy (well, this can be configured like nearly everything else in Spring
        Security, but let's keep it simple for now). Each major authentication system will have its
        own <code class="interfacename">AuthenticationEntryPoint</code> implementation, which typically
        performs one of the actions described in step 3.</p>
    </div>
    <div class="section" title="5.4.3&nbsp;Authentication Mechanism"><div class="titlepage"><div><div><h3 class="title"><a name="d4e923"></a>5.4.3&nbsp;Authentication Mechanism</h3></div></div></div>
      
      <p>Once your browser submits your authentication credentials (either as an HTTP form post
        or HTTP header) there needs to be something on the server that <span class="quote">&#8220;<span class="quote">collects</span>&#8221;</span> these
        authentication details. By now we're at step six in the above list. In Spring Security we
        have a special name for the function of collecting authentication details from a user agent
        (usually a web browser), referring to it as the <span class="quote">&#8220;<span class="quote">authentication mechanism</span>&#8221;</span>.
        Examples are form-base login and Basic authentication. Once the authentication details have
        been collected from the user agent, an <code class="interfacename">Authentication</code>
        <span class="quote">&#8220;<span class="quote">request</span>&#8221;</span> object is built and then presented to the
          <code class="interfacename">AuthenticationManager</code>.</p>
      <p>After the authentication mechanism receives back the fully-populated
          <code class="interfacename">Authentication</code> object, it will deem the request valid, put
        the <code class="interfacename">Authentication</code> into the
          <code class="classname">SecurityContextHolder</code>, and cause the original request to be retried
        (step seven above). If, on the other hand, the <code class="classname">AuthenticationManager</code>
        rejected the request, the authentication mechanism will ask the user agent to retry (step
        two above).</p>
    </div>
    <div class="section" title="5.4.4&nbsp;Storing the SecurityContext between requests"><div class="titlepage"><div><div><h3 class="title"><a name="tech-intro-sec-context-persistence"></a>5.4.4&nbsp;Storing the <code class="interfacename">SecurityContext</code> between requests</h3></div></div></div>
      
      <p>Depending on the type of application, there may need to be a strategy in place to store
        the security context between user operations. In a typical web application, a user logs in
        once and is subsequently identified by their session Id. The server caches the principal
        information for the duration session. In Spring Security, the responsibility for storing the
          <code class="interfacename">SecurityContext</code> between requests falls to the
          <code class="classname">SecurityContextPersistenceFilter</code>, which by default stores the
        context as an <code class="literal">HttpSession</code> attribute between HTTP requests. It restores
        the context to the <code class="classname">SecurityContextHolder</code> for each request and,
        crucially, clears the <code class="classname">SecurityContextHolder</code> when the request
        completes. You shouldn't interact directly with the <code class="literal">HttpSession</code> for
        security purposes. There is simply no justification for doing so - always use the
          <code class="classname">SecurityContextHolder</code> instead. </p>
      <p> Many other types of application (for example, a stateless RESTful web service) do not
        use HTTP sessions and will re-authenticate on every request. However, it is still important
        that the <code class="classname">SecurityContextPersistenceFilter</code> is included in the chain to
        make sure that the <code class="classname">SecurityContextHolder</code> is cleared after each
        request.</p>
      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>In an application which receives concurrent requests in a single session, the same
            <code class="interfacename">SecurityContext</code> instance will be shared between threads.
          Even though a <code class="classname">ThreadLocal</code> is being used, it is the same instance
          that is retrieved from the <code class="interfacename">HttpSession</code> for each thread.
          This has implications if you wish to temporarily change the context under which a thread
          is running. If you just use
            <code class="code">SecurityContextHolder.getContext().setAuthentication(anAuthentication)</code>,
          then the <code class="interfacename">Authentication</code> object will change in
            <span class="emphasis"><em>all</em></span> concurrent threads which share the same
            <code class="interfacename">SecurityContext</code> instance. You can customize the behaviour
          of <code class="classname">SecurityContextPersistenceFilter</code> to create a completely new
            <code class="interfacename">SecurityContext</code> for each request, preventing changes in
          one thread from affecting another. Alternatively you can create a new instance just at the
          point where you temporarily change the context. The method
            <code class="code">SecurityContextHolder.createEmptyContext()</code> always returns a new context
          instance.</p>
      </td></tr></table></div>
    </div>
  </div>
  <div class="section" title="5.5&nbsp;Access-Control (Authorization) in Spring Security"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tech-intro-access-control"></a>5.5&nbsp;Access-Control (Authorization) in Spring Security</h2></div></div></div>
    
    <p> The main interface responsible for making access-control decisions in Spring Security is
      the <code class="interfacename">AccessDecisionManager</code>. It has a
        <code class="methodname">decide</code> method which takes an
        <code class="interfacename">Authentication</code> object representing the principal requesting
      access, a <span class="quote">&#8220;<span class="quote">secure object</span>&#8221;</span> (see below) and a list of security metadata attributes
      which apply for the object (such as a list of roles which are required for access to be
      granted). </p>
    <div class="section" title="5.5.1&nbsp;Security and AOP Advice"><div class="titlepage"><div><div><h3 class="title"><a name="d4e969"></a>5.5.1&nbsp;Security and AOP Advice</h3></div></div></div>
      
      <p>If you're familiar with AOP, you'd be aware there are different types of advice
        available: before, after, throws and around. An around advice is very useful, because an
        advisor can elect whether or not to proceed with a method invocation, whether or not to
        modify the response, and whether or not to throw an exception. Spring Security provides an
        around advice for method invocations as well as web requests. We achieve an around advice
        for method invocations using Spring's standard AOP support and we achieve an around advice
        for web requests using a standard Filter.</p>
      <p>For those not familiar with AOP, the key point to understand is that Spring Security can
        help you protect method invocations as well as web requests. Most people are interested in
        securing method invocations on their services layer. This is because the services layer is
        where most business logic resides in current-generation J2EE applications. If you just need
        to secure method invocations in the services layer, Spring's standard AOP will be adequate.
        If you need to secure domain objects directly, you will likely find that AspectJ is worth
        considering.</p>
      <p>You can elect to perform method authorization using AspectJ or Spring AOP, or you can
        elect to perform web request authorization using filters. You can use zero, one, two or
        three of these approaches together. The mainstream usage pattern is to perform some web
        request authorization, coupled with some Spring AOP method invocation authorization on the
        services layer.</p>
    </div>
    <div class="section" title="5.5.2&nbsp;Secure Objects and the AbstractSecurityInterceptor"><div class="titlepage"><div><div><h3 class="title"><a name="secure-objects"></a>5.5.2&nbsp;Secure Objects and the <code class="classname">AbstractSecurityInterceptor</code></h3></div></div></div>
      
      <p>So what <span class="emphasis"><em>is</em></span> a <span class="quote">&#8220;<span class="quote">secure object</span>&#8221;</span> anyway? Spring Security
        uses the term to refer to any object that can have security (such as an authorization
        decision) applied to it. The most common examples are method invocations and web
        requests.</p>
      <p>Each supported secure object type has its own interceptor class, which is a subclass of
          <code class="classname">AbstractSecurityInterceptor</code>. Importantly, by the time the
          <code class="classname">AbstractSecurityInterceptor</code> is called, the
          <code class="classname">SecurityContextHolder</code> will contain a valid
          <code class="interfacename">Authentication</code> if the principal has been
        authenticated.</p>
      <p><code class="classname">AbstractSecurityInterceptor</code> provides a consistent workflow for
        handling secure object requests, typically: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Look up the
                <span class="quote">&#8220;<span class="quote">configuration attributes</span>&#8221;</span> associated with the present
            request</p></li><li class="listitem"><p>Submitting the secure object, current
                <code class="interfacename">Authentication</code> and configuration attributes to the
                <code class="interfacename">AccessDecisionManager</code> for an authorization
              decision</p></li><li class="listitem"><p>Optionally change the
                <code class="interfacename">Authentication</code> under which the invocation takes
              place</p></li><li class="listitem"><p>Allow the secure object invocation to proceed
              (assuming access was granted)</p></li><li class="listitem"><p>Call the
                <code class="interfacename">AfterInvocationManager</code> if configured, once the
              invocation has returned.</p></li></ol></div>
      <div class="section" title="What are Configuration Attributes?"><div class="titlepage"><div><div><h4 class="title"><a name="tech-intro-config-attributes"></a>What are Configuration Attributes?</h4></div></div></div>
        
        <p> A <span class="quote">&#8220;<span class="quote">configuration attribute</span>&#8221;</span> can be thought of as a String that has
          special meaning to the classes used by <code class="classname">AbstractSecurityInterceptor</code>.
          They are represented by the interface <code class="interfacename">ConfigAttribute</code>
          within the framework. They may be simple role names or have more complex meaning,
          depending on the how sophisticated the
            <code class="interfacename">AccessDecisionManager</code> implementation is. The
            <code class="classname">AbstractSecurityInterceptor</code> is configured with a
            <code class="interfacename">SecurityMetadataSource</code> which it uses to look up the
          attributes for a secure object. Usually this configuration will be hidden from the user.
          Configuration attributes will be entered as annotations on secured methods or as access
          attributes on secured URLs. For example, when we saw something like
            <code class="literal">&lt;intercept-url pattern='/secure/**' access='ROLE_A,ROLE_B'/&gt;</code> in
          the namespace introduction, this is saying that the configuration attributes
            <code class="literal">ROLE_A</code> and <code class="literal">ROLE_B</code> apply to web requests matching
          the given pattern. In practice, with the default
            <code class="interfacename">AccessDecisionManager</code> configuration, this means that
          anyone who has a <code class="interfacename">GrantedAuthority</code> matching either of these
          two attributes will be allowed access. Strictly speaking though, they are just attributes
          and the interpretation is dependent on the
            <code class="interfacename">AccessDecisionManager</code> implementation. The use of the
          prefix <code class="literal">ROLE_</code> is a marker to indicate that these attributes are roles
          and should be consumed by Spring Security's <code class="classname">RoleVoter</code>. This is only
          relevant when a voter-based <code class="interfacename">AccessDecisionManager</code> is in
          use. We'll see how the <code class="interfacename">AccessDecisionManager</code> is implemented
          in the <a class="ulink" href="#authz-arch" target="_top">authorization chapter</a>.</p>
      </div>
      <div class="section" title="RunAsManager"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1023"></a>RunAsManager</h4></div></div></div>
        
        <p>Assuming <code class="interfacename">AccessDecisionManager</code> decides to allow the
          request, the <code class="classname">AbstractSecurityInterceptor</code> will normally just proceed
          with the request. Having said that, on rare occasions users may want to replace the
            <code class="interfacename">Authentication</code> inside the
            <code class="interfacename">SecurityContext</code> with a different
            <code class="interfacename">Authentication</code>, which is handled by the
            <code class="interfacename">AccessDecisionManager</code> calling a
            <code class="literal">RunAsManager</code>. This might be useful in reasonably unusual situations,
          such as if a services layer method needs to call a remote system and present a different
          identity. Because Spring Security automatically propagates security identity from one
          server to another (assuming you're using a properly-configured RMI or HttpInvoker remoting
          protocol client), this may be useful.</p>
      </div>
      <div class="section" title="AfterInvocationManager"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1033"></a>AfterInvocationManager</h4></div></div></div>
        
        <p>Following the secure object proceeding and then returning - which may mean a method
          invocation completing or a filter chain proceeding - the
            <code class="classname">AbstractSecurityInterceptor</code> gets one final chance to handle the
          invocation. At this stage the <code class="classname">AbstractSecurityInterceptor</code> is
          interested in possibly modifying the return object. We might want this to happen because
          an authorization decision couldn't be made <span class="quote">&#8220;<span class="quote">on the way in</span>&#8221;</span> to a secure object
          invocation. Being highly pluggable, <code class="classname">AbstractSecurityInterceptor</code>
          will pass control to an <code class="literal">AfterInvocationManager</code> to actually modify the
          object if needed. This class can even entirely replace the object, or throw an exception,
          or not change it in any way as it chooses.</p>
        <p><code class="classname">AbstractSecurityInterceptor</code> and its related objects are shown
          in <a class="xref" href="#abstract-security-interceptor" title="Figure&nbsp;5.1.&nbsp;Security interceptors and the &#8220;secure object&#8221; model">Figure&nbsp;5.1, &#8220;Security interceptors and the
                <span class="quote">&#8220;<span class="quote">secure object</span>&#8221;</span> model&#8221;</a>. </p><div class="figure"><a name="abstract-security-interceptor"></a><p class="title"><b>Figure&nbsp;5.1.&nbsp;Security interceptors and the
                <span class="quote">&#8220;<span class="quote">secure object</span>&#8221;</span> model</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/security-interception.png" align="middle" alt="Security interceptors and the secure object model"></div></div></div><p><br class="figure-break"></p>
      </div>
      <div class="section" title="Extending the Secure Object Model"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1050"></a>Extending the Secure Object Model</h4></div></div></div>
        
        <p>Only developers contemplating an entirely new way of intercepting and authorizing
          requests would need to use secure objects directly. For example, it would be possible to
          build a new secure object to secure calls to a messaging system. Anything that requires
          security and also provides a way of intercepting a call (like the AOP around advice
          semantics) is capable of being made into a secure object. Having said that, most Spring
          applications will simply use the three currently supported secure object types (AOP
          Alliance <code class="classname">MethodInvocation</code>, AspectJ <code class="classname">JoinPoint</code>
          and web request <code class="classname">FilterInvocation</code>) with complete
          transparency.</p>
      </div>
    </div>
  </div>
  <div class="section" title="5.6&nbsp;Localization"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="localization"></a>5.6&nbsp;Localization</h2></div></div></div>
    
    <p>Spring Security supports localization of exception messages that end users are likely to
      see. If your application is designed for English-speaking users, you don't need to do anything
      as by default all Security Security messages are in English. If you need to support other
      locales, everything you need to know is contained in this section.</p>
    <p>All exception messages can be localized, including messages related to authentication
      failures and access being denied (authorization failures). Exceptions and logging that is
      focused on developers or system deployers (including incorrect attributes, interface contract
      violations, using incorrect constructors, startup time validation, debug-level logging) etc
      are not localized and instead are hard-coded in English within Spring Security's code.</p>
    <p>Shipping in the <code class="literal">spring-security-core-xx.jar</code> you will find an
        <code class="literal">org.springframework.security</code> package that in turn contains a
        <code class="literal">messages.properties</code> file. This should be referred to by your
        <code class="literal">ApplicationContext</code>, as Spring Security classes implement Spring's
        <code class="literal">MessageSourceAware</code> interface and expect the message resolver to be
      dependency injected at application context startup time. Usually all you need to do is
      register a bean inside your application context to refer to the messages. An example is shown
      below:</p>
    <p>
      </p><pre class="programlisting">
&lt;bean id="messageSource"
    class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt;
  &lt;property name="basename" value="org/springframework/security/messages"/&gt;
&lt;/bean&gt;
</pre><p>
    </p>
    <p>The <code class="literal">messages.properties</code> is named in accordance with standard resource
      bundles and represents the default language supported by Spring Security messages. This
      default file is in English. If you do not register a message source, Spring Security will
      still work correctly and fallback to hard-coded English versions of the messages.</p>
    <p>If you wish to customize the <code class="literal">messages.properties</code> file, or support other
      languages, you should copy the file, rename it accordingly, and register it inside the above
      bean definition. There are not a large number of message keys inside this file, so
      localization should not be considered a major initiative. If you do perform localization of
      this file, please consider sharing your work with the community by logging a JIRA task and
      attaching your appropriately-named localized version of
      <code class="literal">messages.properties</code>.</p>
    <p>Rounding out the discussion on localization is the Spring <code class="literal">ThreadLocal</code>
      known as <code class="classname">org.springframework.context.i18n.LocaleContextHolder</code>. You
      should set the <code class="classname">LocaleContextHolder</code> to represent the preferred
        <code class="literal">Locale</code> of each user. Spring Security will attempt to locate a message
      from the message source using the <code class="literal">Locale</code> obtained from this
        <code class="literal">ThreadLocal</code>. Please refer to the Spring Framework documentation for
      further details on using <code class="literal">LocaleContextHolder</code>.</p>
  </div>
</div>
    <div class="chapter" title="6.&nbsp;Core Services"><div class="titlepage"><div><div><h2 class="title"><a name="core-services"></a>6.&nbsp;Core Services</h2></div></div></div>
    
    <p> Now that we have a high-level overview of the Spring Security architecture and its core
        classes, let's take a closer look at one or two of the core interfaces and their
        implementations, in particular the <code class="interfacename">AuthenticationManager</code>,
            <code class="interfacename">UserDetailsService</code> and the
            <code class="interfacename">AccessDecisionManager</code>. These crop up regularly throughout
        the remainder of this document so it's important you know how they are configured and how
        they operate. </p>
    <div class="section" title="6.1&nbsp;The AuthenticationManager, ProviderManager and AuthenticationProviders"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core-services-authentication-manager"></a>6.1&nbsp;The <code class="interfacename">AuthenticationManager</code>,
                <code class="classname">ProviderManager</code> and
                <code class="classname">AuthenticationProvider</code>s</h2></div></div></div>
        
        <p>The <code class="interfacename">AuthenticationManager</code> is just an interface, so the
            implementation can be anything we choose, but how does it work in practice? What if we
            need to check multiple authentication databases or a combination of different
            authentication services such as a database and an LDAP server?</p>
        <p>The default implementation in Spring Security is called
                <code class="classname">ProviderManager</code> and rather than handling the authentication
            request itself, it delegates to a list of configured
                <code class="classname">AuthenticationProvider</code>s, each of which is queried in turn to
            see if it can perform the authentication. Each provider will either throw an exception
            or return a fully populated <code class="interfacename">Authentication</code> object.
            Remember our good friends, <code class="interfacename">UserDetails</code> and
                <code class="interfacename">UserDetailsService</code>? If not, head back to the previous
            chapter and refresh your memory. The most common approach to verifying an authentication
            request is to load the corresponding <code class="interfacename">UserDetails</code> and
            check the loaded password against the one that has been entered by the user. This is the
            approach used by the <code class="classname">DaoAuthenticationProvider</code> (see below). The
            loaded <code class="interfacename">UserDetails</code> object - and particularly the
                <code class="literal">GrantedAuthority</code>s it contains - will be used when building the
            fully populated <code class="interfacename">Authentication</code> object which is returned
            from a successful authentication and stored in the
                <code class="classname">SecurityContext</code>. </p>
        <p> If you are using the namespace, an instance of
                <code class="classname">ProviderManager</code> is created and maintained internally, and
            you add providers to it by using the namespace authentication provider elements
            (see <a class="ulink" href="#ns-auth-manager" target="_top">the namespace chapter</a>). In this
            case, you should not declare a <code class="classname">ProviderManager</code> bean in your
            application context. However, if you are not using the namespace then you would declare
            it like so: </p><pre class="programlisting">
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"authenticationManager"</span>
     <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.authentication.ProviderManager"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"providers"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;list&gt;</span>
      <span class="hl-tag">&lt;ref</span> <span class="hl-attribute">local</span>=<span class="hl-value">"daoAuthenticationProvider"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;ref</span> <span class="hl-attribute">local</span>=<span class="hl-value">"anonymousAuthenticationProvider"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;ref</span> <span class="hl-attribute">local</span>=<span class="hl-value">"ldapAuthenticationProvider"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/list&gt;</span>
  <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
        <p>In the above example we have three providers. They are tried in the order shown (which
            is implied by the use of a <code class="literal">List</code>), with each provider able to attempt
            authentication, or skip authentication by simply returning <code class="literal">null</code>. If
            all implementations return null, the <code class="literal">ProviderManager</code> will throw a
                <code class="exceptionname">ProviderNotFoundException</code>. If you're interested in
            learning more about chaining providers, please refer to the
                <code class="literal">ProviderManager</code> JavaDocs.</p>
        <p> Authentication mechanisms such as a web form-login processing filter are injected
            with a reference to the <code class="interfacename">ProviderManager</code> and will call it
            to handle their authentication requests. The providers you require will sometimes be
            interchangeable with the authentication mechanisms, while at other times they will
            depend on a specific authentication mechanism. For example,
                <code class="classname">DaoAuthenticationProvider</code> and
                <code class="classname">LdapAuthenticationProvider</code> are compatible with any mechanism
            which submits a simple username/password authentication request and so will work with
            form-based logins or HTTP Basic authentication. On the other hand, some authentication
            mechanisms create an authentication request object which can only be interpreted by a
            single type of <code class="classname">AuthenticationProvider</code>. An example of this would
            be JA-SIG CAS, which uses the notion of a service ticket and so can therefore only be
            authenticated by a <code class="classname">CasAuthenticationProvider</code>. You needn't be too
            concerned about this, because if you forget to register a suitable provider, you'll
            simply receive a <code class="literal">ProviderNotFoundException</code> when an attempt to
            authenticate is made.</p>
        <div class="section" title="6.1.1&nbsp;DaoAuthenticationProvider"><div class="titlepage"><div><div><h3 class="title"><a name="core-services-dao-provider"></a>6.1.1&nbsp;<code class="literal">DaoAuthenticationProvider</code></h3></div></div></div>
            
            <p>The simplest <code class="interfacename">AuthenticationProvider</code> implemented by
                Spring Security is <code class="literal">DaoAuthenticationProvider</code>, which is also one
                of the earliest supported by the framework. It leverages a
                    <code class="interfacename">UserDetailsService</code> (as a DAO) in order to lookup
                the username, password and <code class="interfacename">GrantedAuthority</code>s. It
                authenticates the user simply by comparing the password submitted in a
                    <code class="classname">UsernamePasswordAuthenticationToken</code> against the one
                loaded by the <code class="interfacename">UserDetailsService</code>. Configuring the
                provider is quite simple: </p><pre class="programlisting">
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"daoAuthenticationProvider"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.authentication.dao.DaoAuthenticationProvider"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"userDetailsService"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"inMemoryDaoImpl"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"saltSource"</span> <span class="hl-attribute">ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"saltSource"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"passwordEncoder"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"passwordEncoder"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre><p> The <code class="interfacename">PasswordEncoder</code> and
                    <code class="interfacename">SaltSource</code> are optional. A
                    <code class="interfacename">PasswordEncoder</code> provides encoding and decoding of
                passwords presented in the <code class="interfacename">UserDetails</code> object that is
                returned from the configured <code class="interfacename">UserDetailsService</code>. A
                    <code class="interfacename">SaltSource</code> enables the passwords to be populated
                with a "salt", which enhances the security of the passwords in the authentication
                repository. These will be discussed in more detail <a class="ulink" href="#core-services-password-encoding" target="_top">below</a>. </p>
        </div>
        <div class="section" title="6.1.2&nbsp;Erasing Credentials on Successful Authentication"><div class="titlepage"><div><div><h3 class="title"><a name="core-services-erasing-credentials"></a>6.1.2&nbsp;Erasing Credentials on Successful Authentication</h3></div></div></div>
            
            <p>
                From Spring Security 3.0.3, you can configure the <code class="classname">ProviderManager</code>
                will attempt to clear any sensitive credentials information from the
                <code class="interfacename">Authentication</code> object which is returned by a successful
                authentication request, to prevent information like passwords being retained longer
                than necessary. This feature is controlled by the <code class="literal">eraseCredentialsAfterAuthentication</code>
                property on <code class="classname">ProviderManager</code>. It is off by default.
                See the Javadoc for more information.
            </p>
            <p>
                This may cause issues when you are using a cache of user objects, for example, to
                improve performance in a stateless application. If the <code class="interfacename">Authentication</code>
                contains a reference to an object in the cache (such as a <code class="interfacename">UserDetails</code>
                instance) and this has its credentials removed, then it will no longer be possible to authenticate
                against the cached value. You need to take this into account if you are using a cache. An obvious
                solution is to make a copy of the object first, either in the cache implementation or in
                the <code class="interfacename">AuthenticationProvider</code> which creates the returned
                <code class="interfacename">Authentication</code> object.
            </p>
        </div>
    </div>
    <div class="section" title="6.2&nbsp;UserDetailsService Implementations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1154"></a>6.2&nbsp;<code class="interfacename">UserDetailsService</code> Implementations</h2></div></div></div>
        
        <p>As mentioned in the earlier in this reference guide, most authentication providers
            take advantage of the <code class="interfacename">UserDetails</code> and
                <code class="interfacename">UserDetailsService</code> interfaces. Recall that the
            contract for <code class="interfacename">UserDetailsService</code> is a single
            method:</p>
        <p>
            </p><pre class="programlisting">
  UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
            </pre><p>
        </p>
        <p>The returned <code class="interfacename">UserDetails</code> is an interface that provides
            getters that guarantee non-null provision of authentication information such as the
            username, password, granted authorities and whether the user account is enabled or
            disabled. Most authentication providers will use a
                <code class="interfacename">UserDetailsService</code>, even if the username and password
            are not actually used as part of the authentication decision. They may use the returned
                <code class="interfacename">UserDetails</code> object just for its
                <code class="literal">GrantedAuthority</code> information, because some other system (like
            LDAP or X.509 or CAS etc) has undertaken the responsibility of actually validating the
            credentials.</p>
        <p>Given <code class="interfacename">UserDetailsService</code> is so simple to implement, it
            should be easy for users to retrieve authentication information using a persistence
            strategy of their choice. Having said that, Spring Security does include a couple of
            useful base implementations, which we'll look at below.</p>
        <div class="section" title="6.2.1&nbsp;In-Memory Authentication"><div class="titlepage"><div><div><h3 class="title"><a name="core-services-in-memory-service"></a>6.2.1&nbsp;In-Memory Authentication</h3></div></div></div>
            
            <p>Is easy to use create a custom <code class="interfacename">UserDetailsService</code>
                implementation that extracts information from a persistence engine of choice, but
                many applications do not require such complexity. This is particularly true if
                you're building a prototype application or just starting integrating Spring
                Security, when you don't really want to spend time configuring databases or writing
                    <code class="interfacename">UserDetailsService</code> implementations. For this sort
                of situation, a simple option is to use the <code class="literal">user-service</code> element
                from the security <a class="ulink" href="#ns-minimal" target="_top">namespace</a>: </p><pre class="programlisting">
  &lt;user-service id="userDetailsService"&gt;
    &lt;user name="jimi" password="jimispassword" authorities="ROLE_USER, ROLE_ADMIN" /&gt;
    &lt;user name="bob" password="bobspassword" authorities="ROLE_USER" /&gt;
  &lt;/user-service&gt;
  
                    </pre><p> This also supports the use of an external properties
                file: </p><pre class="programlisting">
  &lt;user-service id="userDetailsService" properties="users.properties"/&gt;
  </pre><p> The properties file should contain entries in the form
                </p><pre class="programlisting">username=password,grantedAuthority[,grantedAuthority][,enabled|disabled]</pre><p>
                For example
                </p><pre class="programlisting">
 jimi=jimispassword,ROLE_USER,ROLE_ADMIN,enabled
 bob=bobspassword,ROLE_USER,enabled</pre>
        </div>
        <div class="section" title="6.2.2&nbsp;JdbcDaoImpl"><div class="titlepage"><div><div><h3 class="title"><a name="core-services-jdbc-user-service"></a>6.2.2&nbsp;<code class="literal">JdbcDaoImpl</code></h3></div></div></div>
            
            <p>Spring Security also includes a <code class="interfacename">UserDetailsService</code>
                that can obtain authentication information from a JDBC data source. Internally
                Spring JDBC is used, so it avoids the complexity of a fully-featured object
                relational mapper (ORM) just to store user details. If your application does use an
                ORM tool, you might prefer to write a custom
                    <code class="interfacename">UserDetailsService</code> to reuse the mapping files
                you've probably already created. Returning to <code class="literal">JdbcDaoImpl</code>, an
                example configuration is shown below:</p>
            <p>
                </p><pre class="programlisting">
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"driverClassName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"org.hsqldb.jdbcDriver"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"url"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"jdbc:hsqldb:hsql://localhost:9001"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"username"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"sa"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"userDetailsService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"dataSource"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>        </pre><p>
            </p>
            <p>You can use different relational database management systems by modifying the
                    <code class="literal">DriverManagerDataSource</code> shown above. You can also use a
                global data source obtained from JNDI, as with any other Spring
                configuration.</p>
            <div class="section" title="Authority Groups"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1192"></a>Authority Groups</h4></div></div></div>
                
                <p>By default, <code class="classname">JdbcDaoImpl</code> loads the authorities for a
                    single user with the assumption that the authorities are mapped directly to
                    users (see the <a class="ulink" href="#appendix-schema" target="_top">database schema
                        appendix</a>). An alternative approach is to partition the authorities
                    into groups and assign groups to the user. Some people prefer this approach as a
                    means of administering user rights. See the <code class="classname">JdbcDaoImpl</code>
                    Javadoc for more information on how to enable the use of group authorities. The
                    group schema is also included in the appendix.</p>
            </div>
            
        </div>
    </div>
    <div class="section" title="6.3&nbsp;Password Encoding"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core-services-password-encoding"></a>6.3&nbsp;Password Encoding</h2></div></div></div>
        
        <p>Spring Security's <code class="interfacename">PasswordEncoder</code> interface is used to
            support the use of passwords which are encoded in some way in persistent storage. This
            will normally mean that the passwords are <span class="quote">&#8220;<span class="quote">hashed</span>&#8221;</span> using a digest algorithm
            such as MD5 or SHA.</p>
        <div class="section" title="6.3.1&nbsp;What is a hash?"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1203"></a>6.3.1&nbsp;What is a hash?</h3></div></div></div>
            
            <p>Password hashing is not unique to Spring Security but is a common source of
                confusion for users who are not familiar with the concept. A hash (or digest)
                algorithm is a one-way function which produces a piece of fixed-length output data
                (the hash) from some input data, such as a password. As an example, the MD5 hash of
                the string <span class="quote">&#8220;<span class="quote">password</span>&#8221;</span> (in hexadecimal) is
                </p><pre class="programlisting">
    5f4dcc3b5aa765d61d8327deb882cf99
</pre><p> A hash is
                    <span class="quote">&#8220;<span class="quote">one-way</span>&#8221;</span> in the sense that it is very difficult (effectively
                impossible) to obtain the original input given the hash value, or indeed any
                possible input which would produce that hash value. This property makes hash values
                very useful for authentication purposes. They can be stored in your user database as
                an alternative to plaintext passwords and even if the values are compromised they do
                not immediately reveal a password which can be used to login. Note that this also
                means you have no way of recovering the password once it is encoded.</p>
        </div>
        <div class="section" title="6.3.2&nbsp;Adding Salt to a Hash"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1209"></a>6.3.2&nbsp;Adding Salt to a Hash</h3></div></div></div>
            
            <p> One potential problem with the use of password hashes that it is relatively easy
                to get round the one-way property of the hash if a common word is used for the
                input. For example, if you search for the hash value
                    <code class="literal">5f4dcc3b5aa765d61d8327deb882cf99</code> using google, you will
                quickly find the original word <span class="quote">&#8220;<span class="quote">password</span>&#8221;</span>. In a similar way, an
                attacker can build a dictionary of hashes from a standard word list and use this to
                lookup the original password. One way to help prevent this is to have a suitably
                strong password policy to try to prevent common words from being used. Another is to
                use a <span class="quote">&#8220;<span class="quote">salt</span>&#8221;</span> when calculating the hashes. This is an additional string
                of known data for each user which is combined with the password before calculating
                the hash. Ideally the data should be as random as possible, but in practice any salt
                value is usually preferable to none. Spring Security has a
                    <code class="interfacename">SaltSource</code> interface which can be used by an
                authentication provider to generate a salt value for a particular user. Using a salt
                means that an attacker has to build a separate dictionary of hashes for each salt
                value, making the attack more complicated (but not impossible).</p>
        </div>
        <div class="section" title="6.3.3&nbsp; Hashing and Authentication"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1216"></a>6.3.3&nbsp; Hashing and Authentication</h3></div></div></div>
            
            <p>When an authentication provider (such as Spring Security's
                    <code class="classname">DaoAuthenticationProvider</code> needs to check the password in
                a submitted authentication request against the known value for a user, and the
                stored password is encoded in some way, then the submitted value must be encoded
                using exactly the same algorithm. It's up to you to check that these are compatible
                as Spring Security has no control over the persistent values. If you add password
                hashing to your authentication configuration in Spring Security, and your database
                contains plaintext passwords, then there is no way authentication can succeed. Even
                if you are aware that your database is using MD5 to encode the passwords, for
                example, and your application is configured to use Spring Security's
                    <code class="classname">Md5PasswordEncoder</code>, there are still things that can go
                wrong. The database may have the passwords encoded in Base 64, for example while the
                enocoder is using hexadecimal strings (the default)<sup>[<a name="d4e1221" href="#ftn.d4e1221" class="footnote">5</a>]</sup>. Alternatively your database
                may be using upper-case while the output from the encoder is lower-case. Make sure
                you write a test to check the output from your configured password encoder with a
                known password and salt combination and check that it matches the database value
                before going further and attempting to authenticate through your application. For
                more information on the default method for merging salt and password, see the
                Javadoc for <code class="classname">BasePasswordEncoder</code>. If you want to generate
                encoded passwords directly in Java for storage in your user database, then you can
                use the <code class="methodname">encodePassword</code> method on the
                    <code class="interfacename">PasswordEncoder</code>.</p>
        </div>
    </div>
<div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d4e1221" href="#d4e1221" class="para">5</a>] </sup>You can configure
                        the encoder to use Base 64 instead of hex by setting the
                            <code class="literal">encodeHashAsBase64</code> property to
                            <code class="literal">true</code>. Check the Javadoc for
                            <code class="classname">MessageDigestPasswordEncoder</code> and its parent
                        classes for more information.</p></div></div></div>
  </div>
  <div class="part" title="Part&nbsp;III.&nbsp;Web Application Security"><div class="titlepage"><div><div><h1 class="title"><a name="web-app-security"></a>Part&nbsp;III.&nbsp;Web Application Security</h1></div></div></div>
    
    <div class="partintro" title="Web Application Security"><div></div>
      <p> Most Spring Security users will be using the framework in applications which make user
        of HTTP and the Servlet API. In this part, we'll take a look at how Spring Security provides
        authentication and access-control features for the web layer of an application. We'll look
        behind the facade of the namespace and see which classes and interfaces are actually
        assembled to provide web-layer security. In some situations it is necessary to use
        traditional bean configuration to provide full control over the configuration, so we'll also
        see how to configure these classes directly without the namespace.</p>
    </div>
    <div class="chapter" title="7.&nbsp;The Security Filter Chain"><div class="titlepage"><div><div><h2 class="title"><a name="security-filter-chain"></a>7.&nbsp;The Security Filter Chain</h2></div></div></div>
  
  <p>Spring Security's web infrastructure is based entirely on standard servlet filters. It
    doesn't use servlets or any other servlet-based frameworks (such as Spring MVC) internally, so
    it has no strong links to any particular web technology. It deals in
      <code class="classname">HttpServletRequest</code>s and <code class="classname">HttpServletResponse</code>s and
    doesn't care whether the requests come from a browser, a web service client, an
      <code class="classname">HttpInvoker</code> or an AJAX application. </p>
  <p> Spring Security maintains a filter chain internally where each of the filters has a
    particular responsibility and filters are added or removed from the configuration depending on
    which services are required. The ordering of the filters is important as there are dependencies
    between them. If you have been using <a class="ulink" href="#ns-config" target="_top">namespace
      configuration</a>, then the filters are automatically configured for you and you don't have
    to define any Spring beans explicitly but here may be times when you want full control over the
    security filter chain, either because you are using features which aren't supported in the
    namespace, or you are using your own customized versions of classes.</p>
  <div class="section" title="7.1&nbsp;DelegatingFilterProxy"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="delegating-filter-proxy"></a>7.1&nbsp;<code class="classname">DelegatingFilterProxy</code></h2></div></div></div>
    
    <p> When using servlet filters, you obviously need to declare them in your
        <code class="filename">web.xml</code>, or they will be ignored by the servlet container. In Spring
      Security, the filter classes are also Spring beans defined in the application context and thus
      able to take advantage of Spring's rich dependency-injection facilities and lifecycle
      interfaces. Spring's <code class="classname">DelegatingFilterProxy</code> provides the link between
        <code class="filename">web.xml</code> and the application context. </p>
    <p>When using <code class="classname">DelegatingFilterProxy</code>, you will see something like this
      in the <code class="filename">web.xml</code> file: </p><pre class="programlisting">
  &lt;filter&gt;
    &lt;filter-name&gt;myFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
  &lt;/filter&gt;

  &lt;filter-mapping&gt;
    &lt;filter-name&gt;myFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
      </pre><p> Notice that the filter is actually a
        <code class="literal">DelegatingFilterProxy</code>, and not the class that will actually implement the
      logic of the filter. What <code class="classname">DelegatingFilterProxy</code> does is delegate the
        <code class="interfacename">Filter</code>'s methods through to a bean which is obtained from the
      Spring application context. This enables the bean to benefit from the Spring web application
      context lifecycle support and configuration flexibility. The bean must implement
        <code class="interfacename">javax.servlet.Filter</code> and it must have the same name as that
      in the <code class="literal">filter-name</code> element. Read the Javadoc for
        <code class="classname">DelegatingFilterProxy</code> for more information</p>
  </div>
  <div class="section" title="7.2&nbsp;FilterChainProxy"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="filter-chain-proxy"></a>7.2&nbsp;<code class="classname">FilterChainProxy</code></h2></div></div></div>
    
    <p> It should now be clear that you can declare each Spring Security filter bean that you
      require in your application context file and add a corresponding
        <code class="classname">DelegatingFilterProxy</code> entry to <code class="filename">web.xml</code> for each
      filter, making sure that they are ordered correctly. This is a cumbersome approach and
      clutters up the <code class="filename">web.xml</code> file quickly if we have a lot of filters. We
      would prefer to just add a single entry to <code class="filename">web.xml</code> and deal entirely with
      the application context file for managing our web security beans. This is where Spring
      Secuiryt's <code class="classname">FilterChainProxy</code> comes in. It is wired using a
        <code class="literal">DelegatingFilterProxy</code>, just like in the example above, but with the
        <code class="literal">filter-name</code> set to the bean name <span class="quote">&#8220;<span class="quote">filterChainProxy</span>&#8221;</span>. The
      filter chain is then declared in the application context with the same bean name. Here's an
      example: </p><pre class="programlisting">
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"filterChainProxy"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.FilterChainProxy"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;sec:filter-chain-map</span> <span class="hl-attribute">path-type</span>=<span class="hl-value">"ant"</span><span class="hl-tag">&gt;</span>
     <span class="hl-tag">&lt;sec:filter-chain</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/webServices/**"</span> <span class="hl-attribute">filters</span>=<span class="hl-value">"
           securityContextPersistenceFilterWithASCFalse,
           basicAuthenticationFilter,
           exceptionTranslationFilter,
           filterSecurityInterceptor"</span><span class="hl-tag"> /&gt;</span>
     <span class="hl-tag">&lt;sec:filter-chain</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/**"</span> <span class="hl-attribute">filters</span>=<span class="hl-value">"
           securityContextPersistenceFilterWithASCTrue,
           formLoginFilter,
           exceptionTranslationFilter,
           filterSecurityInterceptor"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-tag">&lt;/sec:filter-chain-map&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

    </pre><p> The namespace element <code class="literal">filter-chain-map</code> is used
      to set up the security filter chain(s) which are required within the
          application<sup>[<a name="d4e1274" href="#ftn.d4e1274" class="footnote">6</a>]</sup>. It maps a
      particular URL pattern to a chain of filters built up from the bean names specified in the
        <code class="literal">filters</code> element. Both regular expressions and Ant Paths are supported,
      and the most specific URIs appear first. At runtime the
        <code class="classname">FilterChainProxy</code> will locate the first URI pattern that matches the
      current web request and the list of filter beans specified by the <code class="literal">filters</code>
      attribute will be applied to that request. The filters will be invoked in the order they are
      defined, so you have complete control over the filter chain which is applied to a particular
      URL.</p>
    <p>You may have noticed we have declared two
        <code class="classname">SecurityContextPersistenceFilter</code>s in the filter chain
        (<code class="literal">ASC</code> is short for <code class="literal">allowSessionCreation</code>, a property of
        <code class="classname">SecurityContextPersistenceFilter</code>). As web services will never present
      a <code class="literal">jsessionid</code> on future requests, creating <code class="literal">HttpSession</code>s
      for such user agents would be wasteful. If you had a high-volume application which required
      maximum scalability, we recommend you use the approach shown above. For smaller applications,
      using a single <code class="classname">SecurityContextPersistenceFilter</code> (with its default
        <code class="literal">allowSessionCreation</code> as <code class="literal">true</code>) would likely be
      sufficient.</p>
    <p>In relation to lifecycle issues, the <code class="classname">FilterChainProxy</code> will always
      delegate <code class="methodname">init(FilterConfig)</code> and <code class="methodname">destroy()</code>
      methods through to the underlaying <code class="interfacename">Filter</code>s if such methods are
      called against <code class="classname">FilterChainProxy</code> itself. In this case,
        <code class="classname">FilterChainProxy</code> guarantees to only initialize and destroy each
        <code class="literal">Filter</code> bean once, no matter how many times it is declared in the filter
      chain(s). You control the overall choice as to whether these methods are called or not via the
        <code class="literal">targetFilterLifecycle</code> initialization parameter of
        <code class="literal">DelegatingFilterProxy</code>. By default this property is
        <code class="literal">false</code> and servlet container lifecycle invocations are not delegated
      through <code class="literal">DelegatingFilterProxy</code>.</p>
    <p> When we looked at how to set up web security using <a class="ulink" href="#ns-web-xml" target="_top">namespace configuration</a>, we used a <code class="literal">DelegatingFilterProxy</code> with the
      name <span class="quote">&#8220;<span class="quote">springSecurityFilterChain</span>&#8221;</span>. You should now be able to see that this is the
      name of the <code class="classname">FilterChainProxy</code> which is created by the namespace. </p>
    <div class="section" title="7.2.1&nbsp;Bypassing the Filter Chain"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1306"></a>7.2.1&nbsp;Bypassing the Filter Chain</h3></div></div></div>
      
      <p> As with the namespace, you can use the attribute <code class="literal">filters = "none"</code> as
        an alternative to supplying a filter bean list. This will omit the request pattern from the
        security filter chain entirely. Note that anything matching this path will then have no
        authentication or authorization services applied and will be freely accessible. If you want
        to make use of the contents of the <code class="classname">SecurityContext</code> contents during a
        request, then it must have passed through the security filter chain. Otherwise the
          <code class="classname">SecurityContextHolder</code> will not have been populated and the contents
        will be null.</p>
    </div>
  </div>
  <div class="section" title="7.3&nbsp;Filter Ordering"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1312"></a>7.3&nbsp;Filter Ordering</h2></div></div></div>
    
    <p>The order that filters are defined in the chain is very important. Irrespective of which
      filters you are actually using, the order should be as follows:
              </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><code class="classname">ChannelProcessingFilter</code>, because
            it might need to redirect to a different
              protocol</p></li><li class="listitem"><p><code class="classname">ConcurrentSessionFilter</code>,
            because it doesn't use any <code class="classname">SecurityContextHolder</code> functionality
            but needs to update the <code class="interfacename">SessionRegistry</code> to reflect
            ongoing requests from the
              principal</p></li><li class="listitem"><p><code class="classname">SecurityContextPersistenceFilter</code>,
            so a <code class="interfacename">SecurityContext</code> can be set up in the
              <code class="classname">SecurityContextHolder</code> at the beginning of a web request, and
            any changes to the <code class="interfacename">SecurityContext</code> can be copied to the
              <code class="literal">HttpSession</code> when the web request ends (ready for use with the next
            web request)</p></li><li class="listitem"><p>Authentication processing mechanisms -
              <code class="classname">UsernamePasswordAuthenticationFilter</code>,
              <code class="classname">CasAuthenticationFilter</code>,
              <code class="classname">BasicAuthenticationFilter</code> etc - so that the
              <code class="classname">SecurityContextHolder</code> can be modified to contain a valid
              <code class="interfacename">Authentication</code> request
            token</p></li><li class="listitem"><p>The
              <code class="literal">SecurityContextHolderAwareRequestFilter</code>, if you are using it to
            install a Spring Security aware <code class="literal">HttpServletRequestWrapper</code> into your
            servlet
              container</p></li><li class="listitem"><p><code class="classname">RememberMeAuthenticationFilter</code>,
            so that if no earlier authentication processing mechanism updated the
              <code class="classname">SecurityContextHolder</code>, and the request presents a cookie that
            enables remember-me services to take place, a suitable remembered
              <code class="interfacename">Authentication</code> object will be put
          there</p></li><li class="listitem"><p><code class="classname">AnonymousAuthenticationFilter</code>,
            so that if no earlier authentication processing mechanism updated the
              <code class="classname">SecurityContextHolder</code>, an anonymous
              <code class="interfacename">Authentication</code> object will be put
          there</p></li><li class="listitem"><p><code class="classname">ExceptionTranslationFilter</code>,
            to catch any Spring Security exceptions so that either an HTTP error response can be
            returned or an appropriate <code class="interfacename">AuthenticationEntryPoint</code> can
            be
              launched</p></li><li class="listitem"><p><code class="classname">FilterSecurityInterceptor</code>,
            to protect web URIs and raise exceptions when access is
        denied</p></li></ol></div>
  </div>
  <div class="section" title="7.4&nbsp;Use with other Filter-Based Frameworks"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1359"></a>7.4&nbsp;Use with other Filter-Based Frameworks</h2></div></div></div>
    
    <p>If you're using some other framework that is also filter-based, then you need to make sure
      that the Spring Security filters come first. This enables the
        <code class="classname">SecurityContextHolder</code> to be populated in time for use by the other
      filters. Examples are the use of SiteMesh to decorate your web pages or a web framework like
      Wicket which uses a filter to handle its requests. </p>
  </div>
  
<div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d4e1274" href="#d4e1274" class="para">6</a>] </sup>Note that you'll need to include the security namespace in your
          application context XML file in order to use this syntax.</p></div></div></div>
    <div class="chapter" title="8.&nbsp;Core Security Filters"><div class="titlepage"><div><div><h2 class="title"><a name="core-web-filters"></a>8.&nbsp;Core Security Filters</h2></div></div></div>
    
    <p> There are some key filters which will always be used in a web application which uses
        Spring Security, so we'll look at these and their supporting classes and interfaces first.
        We won't cover every feature, so be sure to look at the Javadoc for them if you want to get
        the complete picture.</p>
    <div class="section" title="8.1&nbsp;FilterSecurityInterceptor"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="filter-security-interceptor"></a>8.1&nbsp;<code class="classname">FilterSecurityInterceptor</code></h2></div></div></div>
        
        <p>We've already seen <code class="classname">FilterSecurityInterceptor</code> briefly when
            discussing <a class="ulink" href="#tech-intro-access-control" target="_top">access-control in
                general</a>, and we've already used it with the namespace where the
                <code class="literal">&lt;intercept-url&gt;</code> elements are combined to configure it
            internally. Now we'll see how to explicitly configure it for use with a
                <code class="classname">FilterChainProxy</code>, along with its companion filter
                <code class="classname">ExceptionTranslationFilter</code>. A typical configuration example
            is shown below: </p><pre class="programlisting">
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"filterSecurityInterceptor"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.access.intercept.FilterSecurityInterceptor"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"authenticationManager"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"accessDecisionManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"accessDecisionManager"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"securityMetadataSource"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;security:filter-security-metadata-source&gt;</span>
      <span class="hl-tag">&lt;security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/secure/super/**"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_WE_DONT_HAVE"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/secure/**"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_SUPERVISOR,ROLE_TELLER"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/security:filter-security-metadata-source&gt;</span>
  <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
        <p><code class="classname">FilterSecurityInterceptor</code> is responsible for handling the
            security of HTTP resources. It requires a reference to an
                <code class="interfacename">AuthenticationManager</code> and an
                <code class="interfacename">AccessDecisionManager</code>. It is also supplied with
            configuration attributes that apply to different HTTP URL requests. Refer back to <a class="ulink" href="#tech-intro-config-attributes" target="_top">the original discussion on these</a>
            in the technical introduction.</p>
        <p>The <code class="classname">FilterSecurityInterceptor</code> can be configured with
            configuration attributes in two ways. The first, which is shown above, is using the
                <code class="literal">&lt;filter-security-metadata-source&gt;</code> namespace element. This
            is similar to the <code class="literal">&lt;filter-chain-map&gt;</code> used to configure a
                <code class="classname">FilterChainProxy</code> but the
                <code class="literal">&lt;intercept-url&gt;</code> child elements only use the
                <code class="literal">pattern</code> and <code class="literal">access</code> attributes. Commas are used
            to delimit the different configuration attributes that apply to each HTTP URL. The
            second option is to write your own
            <code class="interfacename">SecurityMetadataSource</code>, but this is beyond the scope of
            this document. Irrespective of the approach used, the
                <code class="interfacename">SecurityMetadataSource</code> is responsible for returning a
                <code class="literal">List&lt;ConfigAttribute&gt;</code> containing all of the configuration
            attributes associated with a single secure HTTP URL.</p>
        <p>It should be noted that the
                <code class="literal">FilterSecurityInterceptor.setSecurityMetadataSource()</code> method
            actually expects an instance of
                <code class="interfacename">FilterSecurityMetadataSource</code>. This is a marker
            interface which subclasses <code class="interfacename">SecurityMetadataSource</code>. It
            simply denotes the <code class="interfacename">SecurityMetadataSource</code> understands
                <code class="classname">FilterInvocation</code>s. In the interests of simplicity we'll
            continue to refer to the
                <code class="interfacename">FilterInvocationSecurityMetadataSource</code> as a
                <code class="interfacename">SecurityMetadataSource</code>, as the distinction is of
            little relevance to most users.</p>
        <p>The <code class="interfacename">SecurityMetadataSource</code> created by the namespace
            syntax obtains the configuration attributes for a particular
                <code class="classname">FilterInvocation</code> by matching the request URL against the
            configured <code class="literal">pattern</code> attributes. This behaves in the same way as it
            does for namespace configuration. The default is to treat all expressions as Apache Ant
            paths and regular expressions are also supported for more complex cases. The
                <code class="literal">path-type</code> attribute is used to specify the type of pattern being
            used. It is not possible to mix expression syntaxes within the same definition. As an
            example, the previous configuration using regular expressions instead of Ant paths would
            be written as follows:</p>
        <pre class="programlisting">
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"filterInvocationInterceptor"</span>
     <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.access.intercept.FilterSecurityInterceptor"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"authenticationManager"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"accessDecisionManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"accessDecisionManager"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"runAsManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"runAsManager"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"securityMetadataSource"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;security:filter-security-metadata-source</span> <span class="hl-attribute">path-type</span>=<span class="hl-value">"regex"</span><span class="hl-tag">&gt;</span>
      <span class="hl-tag">&lt;security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"\A/secure/super/.*\Z"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_WE_DONT_HAVE"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"\A/secure/.*\"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_SUPERVISOR,ROLE_TELLER"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/security:filter-security-metadata-source&gt;</span>
  <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>        </pre>
        <p>Patterns are always evaluated in the order they are defined. Thus it is important that
            more specific patterns are defined higher in the list than less specific patterns. This
            is reflected in our example above, where the more specific
                <code class="literal">/secure/super/</code> pattern appears higher than the less specific
                <code class="literal">/secure/</code> pattern. If they were reversed, the
                <code class="literal">/secure/</code> pattern would always match and the
                <code class="literal">/secure/super/</code> pattern would never be evaluated.</p>
        
    </div>
    <div class="section" title="8.2&nbsp; ExceptionTranslationFilter"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="exception-translation-filter"></a>8.2&nbsp;
            <code class="classname">ExceptionTranslationFilter</code></h2></div></div></div>
        
        <p>The <code class="classname">ExceptionTranslationFilter</code> sits above the
                <code class="classname">FilterSecurityInterceptor</code> in the security filter stack. It
            doesn't do any actual security enforcement itself, but handles exceptions thrown by the
            security interceptors and provides suitable and HTTP responses. </p><pre class="programlisting">
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"exceptionTranslationFilter"</span>
     <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.access.ExceptionTranslationFilter"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationEntryPoint"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"authenticationEntryPoint"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"accessDeniedHandler"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"accessDeniedHandler"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"authenticationEntryPoint"</span>
     <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"loginFormUrl"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/login.jsp"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"accessDeniedHandler"</span>
     <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.access.AccessDeniedHandlerImpl"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"errorPage"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/accessDenied.htm"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>
</pre>
        <div class="section" title="8.2.1&nbsp;AuthenticationEntryPoint"><div class="titlepage"><div><div><h3 class="title"><a name="auth-entry-point"></a>8.2.1&nbsp;<code class="interfacename">AuthenticationEntryPoint</code></h3></div></div></div>
            
            <p> The <code class="interfacename">AuthenticationEntryPoint</code> will be called if the
                user requests a secure HTTP resource but they are not authenticated. An appropriate
                    <code class="exceptionname">AuthenticationException</code> or
                    <code class="exceptionname">AccessDeniedException</code> will be thrown by a
                security interceptor further down the call stack, triggering the
                    <code class="methodname">commence</code> method on the entry point. This does the job
                of presenting the appropriate response to the user so that authentication can begin.
                The one we've used here is <code class="classname">LoginUrlAuthenticationEntryPoint</code>,
                which redirects the request to a different URL (typically a login page). The actual
                implementation used will depend on the authentication mechanism you want to be used
                in your application. </p>
        </div>
        <div class="section" title="8.2.2&nbsp;AccessDeniedHandler"><div class="titlepage"><div><div><h3 class="title"><a name="access-denied-handler"></a>8.2.2&nbsp;<code class="interfacename">AccessDeniedHandler</code></h3></div></div></div>
            
            <p>What happens if a user is already authenticated an they try to access a protected
                resource? In normal usage, this shouldn't happen because the application workflow
                should be restricted to operations to which a user has access. For example, an HTML
                link to an administration page might be hidden from users who do not have an admin
                role. You can't rely on hiding links for security though, as there's always a
                possibility that a user will just enter the URL directly in an attempt to bypass the
                restrictions. Or they might modify a RESTful URL to change some of the argument
                values. Your application must be protected against these scenarios or it will
                definitely be insecure. You will typically use simple web layer security to apply
                constraints to basic URLs and use more specific method-based security on your
                service layer interfaces to really nail down what is permissible.</p>
            <p>If an <code class="exceptionname">AccessDeniedException</code> is thrown and a user
                has already been authenticated, then this means that an operation has been attempted
                for which they don't have enough permissions. In this case,
                    <code class="classname">ExceptionTranslationFilter</code> will invoke a second strategy,
                the <code class="interfacename">AccessDeniedHandler</code>. By default, an
                    <code class="classname">AccessDeniedHandlerImpl</code> is used, which just sends a 403
                (Forbidden) response to the client. Alternatively you can configure an instance
                explicitly (as in the above example) and set an error page URL which it will
                forwards the request to <sup>[<a name="d4e1436" href="#ftn.d4e1436" class="footnote">7</a>]</sup>. This can be a simple <span class="quote">&#8220;<span class="quote">access denied</span>&#8221;</span> page, such as a JSP,
                or it could be a more complex handler such as an MVC controller. And of course, you
                can implement the interface yourself and use your own implementation. </p>
            <p>It's also possible to supply a custom
                    <code class="interfacename">AccessDeniedHandler</code> when you're using the
                namespace to configure your application. See <a class="ulink" href="#nsa-access-denied-handler" target="_top">the namespace appendix</a> for more
                details.</p>
        </div>
    </div>
    <div class="section" title="8.3&nbsp;SecurityContextPersistenceFilter"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="security-context-persistence-filter"></a>8.3&nbsp;<code class="classname">SecurityContextPersistenceFilter</code></h2></div></div></div>
        
        <p> We covered the purpose of this all-important filter in the <a class="ulink" href="#tech-intro-sec-context-persistence" target="_top">Technical Overview</a> chapter
            so you might want to re-read that section at this point. Let's first take a look at how
            you would configure it for use with a <code class="classname">FilterChainProxy</code>. A basic
            configuration only requires the bean itself </p><pre class="programlisting">
&lt;bean id="securityContextPersistenceFilter"
class="org.springframework.security.web.context.SecurityContextPersistenceFilter"/&gt;
</pre><p> As we saw previously, this filter has two main tasks. It is responsible for
            storage of the <code class="classname">SecurityContext</code> contents between HTTP requests and
            for clearing the <code class="classname">SecurityContextHolder</code> when a request is
            completed. Clearing the <code class="classname">ThreadLocal</code> in which the context is
            stored is essential, as it might otherwise be possible for a thread to be replaced into
            the servlet container's thread pool, with the security context for a particular user
            still attached. This thread might then be used at a later stage, performing operations
            with the wrong credentials. </p>
        <div class="section" title="8.3.1&nbsp;SecurityContextRepository"><div class="titlepage"><div><div><h3 class="title"><a name="security-context-repository"></a>8.3.1&nbsp;<code class="interfacename">SecurityContextRepository</code></h3></div></div></div>
            
            <p>From Spring Security 3.0, the job of loading and storing the security context is
                now delegated to a separate strategy interface:
                </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> SecurityContextRepository {
  SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder);
  <span class="hl-keyword">void</span> saveContext(SecurityContext context, HttpServletRequest request,
         HttpServletResponse response);
}
</pre><p>
                The <code class="classname">HttpRequestResponseHolder</code> is simply a container for the
                incoming request and response objects, allowing the implementation to replace these
                with wrapper classes. The returned contents will be passed to the filter chain. </p>
            <p> The default implementation is
                    <code class="classname">HttpSessionSecurityContextRepository</code>, which stores the
                security context as an <code class="interfacename">HttpSession</code> attribute <sup>[<a name="d4e1461" href="#ftn.d4e1461" class="footnote">8</a>]</sup>. The most important configuration parameter for this implementation is
                the <code class="literal">allowSessionCreation</code> property, which defaults to
                    <code class="literal">true</code>, thus allowing the class to create a session if it needs
                one to store the security context for an authenticated user (it won't create one
                unless authentication has taken place and the contents of the security context have
                changed). If you don't want a session to be created, then you can set this property
                to <code class="literal">false</code>: </p><pre class="programlisting">
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"securityContextPersistenceFilter"</span>
<span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.context.SecurityContextPersistenceFilter"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">'securityContextRepository'</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">'org.springframework.security.web.context.HttpSessionSecurityContextRepository'</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">'allowSessionCreation'</span> <span class="hl-attribute">value</span>=<span class="hl-value">'false'</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>
<span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>
</pre><p> Alternatively you could provide a null implementation of the
                    <code class="interfacename">SecurityContextRepository</code> interface, which will
                prevent the security context from being stored, even if a session has already been
                created during the request. </p>
        </div>
    </div>
    <div class="section" title="8.4&nbsp;UsernamePasswordAuthenticationFilter"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="form-login-filter"></a>8.4&nbsp;<code class="classname">UsernamePasswordAuthenticationFilter</code></h2></div></div></div>
        
        <p>We've now seen the three main filters which are always present in a Spring Security
            web configuration. These are also the three which are automatically created by the
            namespace <code class="literal">&lt;http&gt;</code> element and cannot be substituted with
            alternatives. The only thing that's missing now is an actual authentication mechanism,
            something that will allow a user to authenticate. This filter is the most commonly used
            authentication filter and the one that is most often customized <sup>[<a name="d4e1475" href="#ftn.d4e1475" class="footnote">9</a>]</sup>. It also provides the implementation used by the
                <code class="literal">&lt;form-login&gt;</code> element from the namespace. There are three
            stages required to configure it. </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                    <p>Configure a <code class="classname">LoginUrlAuthenticationEntryPoint</code> with
                        the URL of the login page, just as we did above, and set it on the
                            <code class="classname">ExceptionTranslationFilter</code>. </p>
                </li><li class="listitem">
                    <p>Implement the login page (using a JSP or MVC controller).</p>
                </li><li class="listitem">
                    <p>Configure an instance of
                            <code class="classname">UsernamePasswordAuthenticationFilter</code> in the
                        application context</p>
                </li><li class="listitem">
                    <p>Add the filter bean to your filter chain proxy (making sure you pay
                        attention to the order). </p>
                </li></ol></div><p> The login form simply contains <code class="literal">j_username</code> and
                <code class="literal">j_password</code> input fields, and posts to the URL that is monitored
            by the filter (by default this is <code class="literal">/j_spring_security_check</code>). The
            basic filter configuration looks something like this: </p><pre class="programlisting">
&lt;bean id="authenticationFilter" class=
"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"&gt;
  &lt;property name="authenticationManager" ref="authenticationManager"/&gt;
  &lt;property name="filterProcessesUrl" value="/j_spring_security_check"/&gt;
&lt;/bean&gt; 
                </pre>
        <div class="section" title="8.4.1&nbsp;Application Flow on Authentication Success and Failure"><div class="titlepage"><div><div><h3 class="title"><a name="form-login-flow-handling"></a>8.4.1&nbsp;Application Flow on Authentication Success and Failure</h3></div></div></div>
            
            <p> The filter calls the configured
                    <code class="interfacename">AuthenticationManager</code> to process each
                authentication request. The destination following a successful authentication or an
                authentication failure is controlled by the
                    <code class="interfacename">AuthenticationSuccessHandler</code> and
                    <code class="interfacename">AuthenticationFailureHandler</code> strategy interfaces,
                respectively. The filter has properties which allow you to set these so you can
                customize the behaviour completely <sup>[<a name="d4e1502" href="#ftn.d4e1502" class="footnote">10</a>]</sup>. Some standard implementations are supplied such as
                    <code class="classname">SimpleUrlAuthenticationSuccessHandler</code>,
                    <code class="classname">SavedRequestAwareAuthenticationSuccessHandler</code>,
                    <code class="classname">SimpleUrlAuthenticationFailureHandler</code> and
                    <code class="classname">ExceptionMappingAuthenticationFailureHandler</code>. Have a look
                at the Javadoc for these classes to see how they work. </p>
            <p>If authentication is successful, the resulting
                    <code class="interfacename">Authentication</code> object will be placed into the
                    <code class="classname">SecurityContextHolder</code>. The configured
                    <code class="interfacename">AuthenticationSuccessHandler</code> will then be called
                to either redirect or forward the user to the appropriate destination. By default a
                    <code class="classname">SavedRequestAwareAuthenticationSuccessHandler</code> is used,
                which means that the user will be redirected to the original destination they
                requested before they were asked to login. </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
                    <p> The <code class="classname">ExceptionTranslationFilter</code> caches the original
                        request a user makes. When the user authenticates, the request handler makes
                        use of this cached request to obtain the original URL and redirect to it.
                        The original request is then rebuilt and used as an alternative. </p>
                </td></tr></table></div><p> If authentication fails, the configured
                    <code class="interfacename">AuthenticationFailureHandler</code> will be invoked.
            </p>
        </div>
    </div>
<div class="footnotes"><br><hr width="100" align="left"><div class="footnote">
                    <p><sup>[<a name="ftn.d4e1436" href="#d4e1436" class="para">7</a>] </sup>We use a forward so that the SecurityContextHolder still contains details
                        of the principal, which may be useful for displaying to the user. In old
                        releases of Spring Security we relied upon the servlet container to handle a
                        403 error message, which lacked this useful contextual information.</p>
                </div><div class="footnote">
                    <p><sup>[<a name="ftn.d4e1461" href="#d4e1461" class="para">8</a>] </sup>In Spring Security 2.0 and earlier, this filter was called
                            <code class="classname">HttpSessionContextIntegrationFilter</code> and performed
                        all the work of storing the context was performed by the filter itself. If
                        you were familiar with this class, then most of the configuration options
                        which were available can now be found on
                            <code class="classname">HttpSessionSecurityContextRepository</code>. </p>
                </div><div class="footnote">
                <p><sup>[<a name="ftn.d4e1475" href="#d4e1475" class="para">9</a>] </sup>For historical reasons, prior to Spring Security 3.0, this filter was called
                        <code class="classname">AuthenticationProcessingFilter</code> and the entry point
                    was called <code class="classname">AuthenticationProcessingFilterEntryPoint</code>.
                    Since the framework now supports many different forms of authentication, they
                    have both been given more specific names in 3.0.</p>
            </div><div class="footnote">
                    <p><sup>[<a name="ftn.d4e1502" href="#d4e1502" class="para">10</a>] </sup>In versions prior to 3.0, the application flow at this point had evolved
                        to a stage was controlled by a mix of properties on this class and strategy
                        plugins. The decision was made for 3.0 to refactor the code to make these
                        two strategies entirely responsible. </p>
                </div></div></div>
    <div class="chapter" title="9.&nbsp;Basic and Digest Authentication"><div class="titlepage"><div><div><h2 class="title"><a name="basic"></a>9.&nbsp;Basic and Digest Authentication</h2></div></div></div>
    
    <p>Basic and digest authentiation are alternative authentication mechanisms which are popular
        in web applications. Basic authentication is often used with stateless clients which pass
        their credentials on each request. It's quite common to use it in combination with
        form-based authentication where an application is used through both a browser-based user
        interface and as a web-service. However, basic authentication transmits the password as
        plain text so it should only really be used over an encrypted transport layer such as
        HTTPS.</p>
    <div class="section" title="9.1&nbsp;BasicAuthenticationFilter"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="basic-processing-filter"></a>9.1&nbsp;<code class="classname">BasicAuthenticationFilter</code></h2></div></div></div>
        
        <p><code class="literal">BasicAuthenticationFilter</code> is responsible for processing basic
            authentication credentials presented in HTTP headers. This can be used for
            authenticating calls made by Spring remoting protocols (such as Hessian and Burlap), as
            well as normal browser user agents (such as Firefox and Internet Explorer). The standard
            governing HTTP Basic Authentication is defined by RFC 1945, Section 11, and
                <code class="literal">BasicAuthenticationFilter</code> conforms with this RFC. Basic
            Authentication is an attractive approach to authentication, because it is very widely
            deployed in user agents and implementation is extremely simple (it's just a Base64
            encoding of the username:password, specified in an HTTP header).</p>
        <div class="section" title="9.1.1&nbsp;Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="basic-config"></a>9.1.1&nbsp;Configuration</h3></div></div></div>
            
            <p>To implement HTTP Basic Authentication, you need to add a
                    <code class="literal">BasicAuthenticationFilter</code> to your filter chain. The
                application context should contain <code class="literal">BasicAuthenticationFilter</code> and
                its required collaborator:</p>
            <p>
                </p><pre class="programlisting">
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"basicAuthenticationFilter"</span>
  <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.authentication.www.BasicAuthenticationFilter"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"authenticationManager"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationEntryPoint"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"authenticationEntryPoint"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"authenticationEntryPoint"</span>
  <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"realmName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"Name Of Your Realm"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>
                </pre><p>
            </p>
            <p>The configured <code class="interfacename">AuthenticationManager</code> processes each
                authentication request. If authentication fails, the configured
                    <code class="interfacename">AuthenticationEntryPoint</code> will be used to retry
                the authentication process. Usually you will use the filter in combination with a
                    <code class="literal">BasicAuthenticationEntryPoint</code>, which returns a 401 response
                with a suitable header to retry HTTP Basic authentication. If authentication is
                successful, the resulting <code class="interfacename">Authentication</code> object will
                be placed into the <code class="classname">SecurityContextHolder</code> as usual.</p>
            <p>If the authentication event was successful, or authentication was not attempted
                because the HTTP header did not contain a supported authentication request, the
                filter chain will continue as normal. The only time the filter chain will be
                interrupted is if authentication fails and the
                    <code class="interfacename">AuthenticationEntryPoint</code> is called.</p>
        </div>
    </div>
    <div class="section" title="9.2&nbsp;DigestAuthenticationFilter"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="digest-processing-filter"></a>9.2&nbsp;<code class="classname">DigestAuthenticationFilter</code></h2></div></div></div>
        
        <p><code class="classname">DigestAuthenticationFilter</code> is capable of processing digest
            authentication credentials presented in HTTP headers. Digest Authentication attempts to
            solve many of the weaknesses of Basic authentication, specifically by ensuring
            credentials are never sent in clear text across the wire. Many user agents support
            Digest Authentication, including FireFox and Internet Explorer. The standard governing
            HTTP Digest Authentication is defined by RFC 2617, which updates an earlier version of
            the Digest Authentication standard prescribed by RFC 2069. Most user agents implement
            RFC 2617. Spring Security's <code class="classname">DigestAuthenticationFilter</code> is
            compatible with the "<code class="literal">auth</code>" quality of protection
                (<code class="literal">qop</code>) prescribed by RFC 2617, which also provides backward
            compatibility with RFC 2069. Digest Authentication is a more attractive option if you
            need to use unencrypted HTTP (i.e. no TLS/HTTPS) and wish to maximise security of the
            authentication process. Indeed Digest Authentication is a mandatory requirement for the
            WebDAV protocol, as noted by RFC 2518 Section 17.1.</p>
        <p>Digest Authentication is definitely the most secure choice between Form
            Authentication, Basic Authentication and Digest Authentication, although extra security
            also means more complex user agent implementations. Central to Digest Authentication is
            a "nonce". This is a value the server generates. Spring Security's nonce adopts the
            following format:</p>
        <p>
            </p><pre class="programlisting">
                base64(expirationTime + ":" + md5Hex(expirationTime + ":" + key))

                expirationTime:   The date and time when the nonce expires, expressed in milliseconds
                key:              A private key to prevent modification of the nonce token
            </pre><p>
        </p>
        <p>The <code class="classname">DigestAuthenticatonEntryPoint</code> has a property specifying the
                <code class="literal">key</code> used for generating the nonce tokens, along with a
                <code class="literal">nonceValiditySeconds</code> property for determining the expiration time
            (default 300, which equals five minutes). Whist ever the nonce is valid, the digest is
            computed by concatenating various strings including the username, password, nonce, URI
            being requested, a client-generated nonce (merely a random value which the user agent
            generates each request), the realm name etc, then performing an MD5 hash. Both the
            server and user agent perform this digest computation, resulting in different hash codes
            if they disagree on an included value (eg password). In Spring Security implementation,
            if the server-generated nonce has merely expired (but the digest was otherwise valid),
            the <code class="classname">DigestAuthenticationEntryPoint</code> will send a
                <code class="literal">"stale=true"</code> header. This tells the user agent there is no need
            to disturb the user (as the password and username etc is correct), but simply to try
            again using a new nonce.</p>
        <p>An appropriate value for <code class="classname">DigestAuthenticationEntryPoint</code>'s
                <code class="literal">nonceValiditySeconds</code> parameter will depend on your application.
            Extremely secure applications should note that an intercepted authentication header can
            be used to impersonate the principal until the <code class="literal">expirationTime</code>
            contained in the nonce is reached. This is the key principle when selecting an
            appropriate setting, but it would be unusual for immensely secure applications to not be
            running over TLS/HTTPS in the first instance.</p>
        <p>Because of the more complex implementation of Digest Authentication, there are often
            user agent issues. For example, Internet Explorer fails to present an
                "<code class="literal">opaque</code>" token on subsequent requests in the same session. Spring
            Security filters therefore encapsulate all state information into the
                "<code class="literal">nonce</code>" token instead. In our testing, Spring Security's
            implementation works reliably with FireFox and Internet Explorer, correctly handling
            nonce timeouts etc.</p>
        <div class="section" title="9.2.1&nbsp;Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="digest-config"></a>9.2.1&nbsp;Configuration</h3></div></div></div>
            
            <p>Now that we've reviewed the theory, let's see how to use it. To implement HTTP
                Digest Authentication, it is necessary to define
                    <code class="literal">DigestAuthenticationFilter</code> in the filter chain. The
                application context will need to define the
                    <code class="literal">DigestAuthenticationFilter</code> and its required
                collaborators:</p>
            <p>
                </p><pre class="programlisting">
&lt;bean id="digestFilter" class=
    "org.springframework.security.web.authentication.www.DigestAuthenticationFilter"&gt;
  &lt;property name="userDetailsService" ref="jdbcDaoImpl"/&gt;
  &lt;property name="authenticationEntryPoint" ref="digestEntryPoint"/&gt;
  &lt;property name="userCache" ref="userCache"/&gt;
&lt;/bean&gt;

&lt;bean id="digestEntryPoint" class=
    "org.springframework.security.web.authentication.www.DigestAuthenticationEntryPoint"&gt;
  &lt;property name="realmName" value="Contacts Realm via Digest Authentication"/&gt;
  &lt;property name="key" value="acegi"/&gt;
  &lt;property name="nonceValiditySeconds" value="10"/&gt;
&lt;/bean&gt;
                </pre><p>
            </p>
            <p>The configured <code class="interfacename">UserDetailsService</code> is needed because
                    <code class="literal">DigestAuthenticationFilter</code> must have direct access to the
                clear text password of a user. Digest Authentication will NOT work if you are using
                encoded passwords in your DAO. The DAO collaborator, along with the
                    <code class="literal">UserCache</code>, are typically shared directly with a
                    <code class="classname">DaoAuthenticationProvider</code>. The
                    <code class="literal">authenticationEntryPoint</code> property must be
                    <code class="classname">DigestAuthenticationEntryPoint</code>, so that
                    <code class="classname">DigestAuthenticationFilter</code> can obtain the correct
                    <code class="literal">realmName</code> and <code class="literal">key</code> for digest
                calculations.</p>
            <p>Like <code class="literal">BasicAuthenticationFilter</code>, if authentication is successful
                an <code class="interfacename">Authentication</code> request token will be placed into
                the <code class="classname">SecurityContextHolder</code>. If the authentication event was
                successful, or authentication was not attempted because the HTTP header did not
                contain a Digest Authentication request, the filter chain will continue as normal.
                The only time the filter chain will be interrupted is if authentication fails and
                the <code class="interfacename">AuthenticationEntryPoint</code> is called, as discussed
                in the previous paragraph.</p>
            <p>Digest Authentication's RFC offers a range of additional features to further
                increase security. For example, the nonce can be changed on every request. Despite
                this, Spring Security implementation was designed to minimise the complexity of the
                implementation (and the doubtless user agent incompatibilities that would emerge),
                and avoid needing to store server-side state. You are invited to review RFC 2617 if
                you wish to explore these features in more detail. As far as we are aware, Spring
                Security's implementation does comply with the minimum standards of this RFC.</p>
        </div>
    </div>
</div>
    <div class="chapter" title="10.&nbsp;Remember-Me Authentication"><div class="titlepage"><div><div><h2 class="title"><a name="remember-me"></a>10.&nbsp;Remember-Me Authentication</h2></div></div></div>
    
    <div class="section" title="10.1&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remember-me-overview"></a>10.1&nbsp;Overview</h2></div></div></div>
        
        <p>Remember-me or persistent-login authentication refers to web sites being able to
            remember the identity of a principal between sessions. This is typically accomplished by
            sending a cookie to the browser, with the cookie being detected during future sessions
            and causing automated login to take place. Spring Security provides the necessary hooks
            for these operations to take place, and has two concrete remember-me implementations.
            One uses hashing to preserve the security of cookie-based tokens and the other uses a
            database or other persistent storage mechanism to store the generated tokens. </p>
        <p> Note that both implemementations require a
                <code class="interfacename">UserDetailsService</code>. If you are using an
            authentication provider which doesn't use a
                <code class="interfacename">UserDetailsService</code> (for example, the LDAP provider)
            then it won't work unless you also have a
                <code class="interfacename">UserDetailsService</code> bean in your application context.
        </p>
    </div>
    <div class="section" title="10.2&nbsp;Simple Hash-Based Token Approach"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remember-me-hash-token"></a>10.2&nbsp;Simple Hash-Based Token Approach</h2></div></div></div>
        
        <p>This approach uses hashing to achieve a useful remember-me strategy. In essence a
            cookie is sent to the browser upon successful interactive authentication, with the
            cookie being composed as follows:
            </p><pre class="programlisting">
    base64(username + ":" + expirationTime + ":" +
             md5Hex(username + ":" + expirationTime + ":" password + ":" + key))

    username:          As identifiable to the <code class="interfacename">UserDetailsService</code>
    password:          That matches the one in the retrieved UserDetails
    expirationTime:    The date and time when the remember-me token expires,
                       expressed in milliseconds
    key:               A private key to prevent modification of the remember-me token
        </pre>
        <p>As such the remember-me token is valid only for the period specified, and provided
            that the username, password and key does not change. Notably, this has a potential
            security issue in that a captured remember-me token will be usable from any user agent
            until such time as the token expires. This is the same issue as with digest
            authentication. If a principal is aware a token has been captured, they can easily
            change their password and immediately invalidate all remember-me tokens on issue. If
            more significant security is needed you should use the approach described in the next
            section. Alternatively remember-me services should simply not be used at all.</p>
        <p>If you are familiar with the topics discussed in the chapter on <a class="ulink" href="#ns-config" target="_top">namespace configuration</a>, you can enable remember-me
            authentication just by adding the <code class="literal">&lt;remember-me&gt;</code> element: </p><pre class="programlisting">
  &lt;http&gt;
    ...
    &lt;remember-me key="myAppKey"/&gt;
  &lt;/http&gt;
  
                </pre><p> The <code class="interfacename">UserDetailsService</code> will
            normally be selected automatically. If you have more than one in your application
            context, you need to specify which one should be used with the
                <code class="literal">user-service-ref</code> attribute, where the value is the name of your
                <code class="interfacename">UserDetailsService</code> bean. </p>
    </div>
    <div class="section" title="10.3&nbsp;Persistent Token Approach"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remember-me-persistent-token"></a>10.3&nbsp;Persistent Token Approach</h2></div></div></div>
        
        <p>This approach is based on the article <a class="ulink" href="http://jaspan.com/improved_persistent_login_cookie_best_practice" target="_top">http://jaspan.com/improved_persistent_login_cookie_best_practice</a> with some
            minor modifications <sup>[<a name="d4e1625" href="#ftn.d4e1625" class="footnote">11</a>]</sup>.
            To use the this approach with namespace configuration, you would supply a datasource
            reference: </p><pre class="programlisting">
  &lt;http&gt;
    ...
    &lt;remember-me data-source-ref="someDataSource"/&gt;
  &lt;/http&gt;
  
            </pre><p> The database should contain a
                <code class="literal">persistent_logins</code> table, created using the following SQL (or
            equivalent):
            </p><pre class="programlisting">
    create table persistent_logins (username varchar(64) not null, series varchar(64) primary key, token varchar(64) not null, last_used timestamp not null)
</pre>
        
    </div>
    <div class="section" title="10.4&nbsp;Remember-Me Interfaces and Implementations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remember-me-impls"></a>10.4&nbsp;Remember-Me Interfaces and Implementations</h2></div></div></div>
        
        <p>Remember-me authentication is not used with basic authentication, given it is often
            not used with <code class="literal">HttpSession</code>s. Remember-me is used with
                <code class="literal">UsernamePasswordAuthenticationFilter</code>, and is implemented via
            hooks in the <code class="literal">AbstractAuthenticationProcessingFilter</code> superclass. The
            hooks will invoke a concrete <code class="interfacename">RememberMeServices</code> at the
            appropriate times. The interface looks like this:
            </p><pre class="programlisting">
  Authentication autoLogin(HttpServletRequest request, HttpServletResponse response);
  <span class="hl-keyword">void</span> loginFail(HttpServletRequest request, HttpServletResponse response);
  <span class="hl-keyword">void</span> loginSuccess(HttpServletRequest request, HttpServletResponse response,
      Authentication successfulAuthentication);
    </pre><p>
            Please refer to the JavaDocs for a fuller discussion on what the methods do, although
            note at this stage that <code class="literal">AbstractAuthenticationProcessingFilter</code> only
            calls the <code class="literal">loginFail()</code> and <code class="literal">loginSuccess()</code> methods.
            The <code class="literal">autoLogin()</code> method is called by
                <code class="classname">RememberMeAuthenticationFilter</code> whenever the
                <code class="classname">SecurityContextHolder</code> does not contain an
                <code class="interfacename">Authentication</code>. This interface therefore provides the
            underlying remember-me implementation with sufficient notification of
            authentication-related events, and delegates to the implementation whenever a candidate
            web request might contain a cookie and wish to be remembered. This design allows any
            number of remember-me implementation strategies. We've seen above that Spring Security
            provides two implementations. We'll look at these in turn.</p>
        <div class="section" title="10.4.1&nbsp;TokenBasedRememberMeServices"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1647"></a>10.4.1&nbsp;TokenBasedRememberMeServices</h3></div></div></div>
            
            <p> This implementation supports the simpler approach described in <a class="xref" href="#remember-me-hash-token" title="10.2&nbsp;Simple Hash-Based Token Approach">Section&nbsp;10.2, &#8220;Simple Hash-Based Token Approach&#8221;</a>.
                    <code class="classname">TokenBasedRememberMeServices</code> generates a
                    <code class="literal">RememberMeAuthenticationToken</code>, which is processed by
                    <code class="literal">RememberMeAuthenticationProvider</code>. A <code class="literal">key</code> is
                shared between this authentication provider and the
                    <code class="literal">TokenBasedRememberMeServices</code>. In addition,
                    <code class="literal">TokenBasedRememberMeServices</code> requires A UserDetailsService
                from which it can retrieve the username and password for signature comparison
                purposes, and generate the <code class="literal">RememberMeAuthenticationToken</code> to
                contain the correct <code class="interfacename">GrantedAuthority</code>[]s. Some sort of
                logout command should be provided by the application that invalidates the cookie if
                the user requests this. <code class="classname">TokenBasedRememberMeServices</code> also
                implements Spring Security's <code class="interfacename">LogoutHandler</code> interface
                so can be used with <code class="classname">LogoutFilter</code> to have the cookie cleared
                automatically. </p>
            <p>The beans required in an application context to enable remember-me services are as
                follows: </p><pre class="programlisting">
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"rememberMeFilter"</span> <span class="hl-attribute">class</span>=
 <span class="hl-value">"org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"rememberMeServices"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"rememberMeServices"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"theAuthenticationManager"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"rememberMeServices"</span> <span class="hl-attribute">class</span>=
 <span class="hl-value">"org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"userDetailsService"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myUserDetailsService"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"key"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"springRocks"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"rememberMeAuthenticationProvider"</span> <span class="hl-attribute">class</span>=
 <span class="hl-value">"org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationProvider"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"key"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"springRocks"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

            </pre><p>Don't forget to add your
                    <code class="interfacename">RememberMeServices</code> implementation to your
                    <code class="literal">UsernamePasswordAuthenticationFilter.setRememberMeServices()</code>
                property, include the <code class="literal">RememberMeAuthenticationProvider</code> in your
                    <code class="literal">AuthenticationManager.setProviders()</code> list, and add
                    <code class="classname">RememberMeAuthenticationFilter</code> into your
                    <code class="classname">FilterChainProxy</code> (typically immediately after your
                    <code class="literal">UsernamePasswordAuthenticationFilter</code>).</p>
        </div>
        <div class="section" title="10.4.2&nbsp;PersistentTokenBasedRememberMeServices"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1671"></a>10.4.2&nbsp;PersistentTokenBasedRememberMeServices</h3></div></div></div>
            
            <p> This class can be used in the same way as
                    <code class="classname">TokenBasedRememberMeServices</code>, but it additionally needs
                to be configured with a <code class="interfacename">PersistentTokenRepository</code> to
                store the tokens. There are two standard implementations.
                                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="classname">InMemoryTokenRepositoryImpl</code>
                            which is intended for testing
                                only.</p></li><li class="listitem"><p><code class="classname">JdbcTokenRepositoryImpl</code>
                            which stores the tokens in a database. </p></li></ul></div><p>
                The database schema is described above in <a class="xref" href="#remember-me-persistent-token" title="10.3&nbsp;Persistent Token Approach">Section&nbsp;10.3, &#8220;Persistent Token Approach&#8221;</a>. </p>
        </div>
    </div>
<div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d4e1625" href="#d4e1625" class="para">11</a>] </sup>Essentially, the username is not included in the
                    cookie, to prevent exposing a valid login name unecessarily. There is a
                    discussion on this in the comments section of this article.</p></div></div></div>
    <div class="chapter" title="11.&nbsp;Session Management"><div class="titlepage"><div><div><h2 class="title"><a name="session-mgmt"></a>11.&nbsp;Session Management</h2></div></div></div>
  
  <p>HTTP session related functonality is handled by a combination of the
      <code class="classname">SessionManagementFilter</code> and the
      <code class="interfacename">SessionAuthenticationStrategy</code> interface, which the filter
    delegates to. Typical usage includes session-fixation protection attack prevention, detection of
    session timeouts and restrictions on how many sessions an authenticated user may have open
    concurrently.</p>
  <div class="section" title="11.1&nbsp;SessionManagementFilter"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1691"></a>11.1&nbsp;SessionManagementFilter</h2></div></div></div>
    
    <p>The <code class="classname">SessionManagementFilter</code> checks the contents of the
        <code class="interfacename">SecurityContextRepository</code> against the current contents of the
        <code class="classname">SecurityContextHolder</code> to determine whether a user has been
      authenticated during the current request, typically by a non-interactive authentication
      mechanism, such as pre-authentication or remember-me <sup>[<a name="d4e1697" href="#ftn.d4e1697" class="footnote">12</a>]</sup>. If the repository contains a
      security context, the filter does nothing. If it doesn't, and the thread-local
        <code class="interfacename">SecurityContext</code> contains a (non-anonymous)
        <code class="interfacename">Authentication</code> object, the filter assumes they have been
      authenticated by a previous filter in the stack. It will then invoke the configured
        <code class="interfacename">SessionAuthenticationStrategy</code>.</p>
    <p>If the user is not currently authenticated, the filter will check whether an invalid
      session ID has been requested (because of a timeout, for example) and will redirect to the
      configured <code class="literal">invalidSessionUrl</code> if set. The easiest way to configure this is
      through the namespace, <a class="ulink" href="#ns-session-mgmt" target="_top">as described earlier</a>.</p>
  </div>
  <div class="section" title="11.2&nbsp;SessionAuthenticationStrategy"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1706"></a>11.2&nbsp;<code class="interfacename">SessionAuthenticationStrategy</code></h2></div></div></div>
    
    <p>
      <code class="interfacename">SessionAuthenticationStrategy</code> is used by both
        <code class="classname">SessionManagementFilter</code> and
        <code class="classname">AbstractAuthenticationProcessingFilter</code>, so if you are using a
      customized form-login class, for example, you will need to inject it into both of these. In
      this case, a typical configuration, combining the namespace and custom beans might look like this:</p><pre class="programlisting">
  &lt;http&gt;
    &lt;custom-filter position="FORM_LOGIN_FILTER" ref="myAuthFilter" /&gt;
    &lt;session-management session-authentication-strategy-ref="sas"/&gt;
  &lt;/http&gt;

  &lt;beans:bean id="myAuthFilter"
      class="org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"&gt;
    &lt;beans:property name="sessionAuthenticationStrategy" ref="sas" /&gt;
    ...
  &lt;/beans:bean&gt;

  &lt;beans:bean id="sas"
      class="org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy"&gt;
    &lt;beans:property name="sessionRegistry" ref="sessionRegistry" /&gt;
    &lt;beans:property name="maximumSessions" value="1" /&gt;
  &lt;/beans:bean&gt;

      </pre>
  </div>
  <div class="section" title="11.3&nbsp;Concurrency Control"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="concurrent-sessions"></a>11.3&nbsp;Concurrency Control</h2></div></div></div>
    
    <p>Spring Security is able to prevent a principal from concurrently authenticating to the
      same application more than a specified number of times. Many ISVs take advantage of this to
      enforce licensing, whilst network administrators like this feature because it helps prevent
      people from sharing login names. You can, for example, stop user <span class="quote">&#8220;<span class="quote">Batman</span>&#8221;</span> from
      logging onto the web application from two different sessions. You can either expire their
      previous login or you can report an error when they try to log in again, preventing the second
      login. Note that if you are using the second approach, a user who has not explicitly logged
      out (but who has just closed their browser, for example) will not be able to log in again
      until their original session expires.</p>
    <p>Concurrency control is supported by the namespace, so please check the earlier namespace
      chapter for the simplest configuration. Sometimes you need to customize things though. </p>
    <p>The implementation uses a specialized version of
        <code class="interfacename">SessionAuthenticationStrategy</code>, called
        <code class="classname">ConcurrentSessionControlStrategy</code>. </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Previously the
          concurrent authentication check was made by the <code class="classname">ProviderManager</code>,
          which could be injected with a <code class="literal">ConcurrentSessionController</code>. The latter
          would check if the user was attempting to exceed the number of permitted sessions.
          However, this approach required that an HTTP session be created in advance, which is
          undesirable. In Spring Security 3, the user is first authenticated by the
            <code class="interfacename">AuthenticationManager</code> and once they are successfully
          authenticated, a session is created and the check is made whether they are allowed to have
          another session open.</p></td></tr></table></div>
    <p>To use concurrent session support, you'll need to add the following to
        <code class="literal">web.xml</code>: </p><pre class="programlisting">
  &lt;listener&gt;
    &lt;listener-class&gt;
      org.springframework.security.web.session.HttpSessionEventPublisher
    &lt;/listener-class&gt;
  &lt;/listener&gt; 
        </pre>
    <p>In addition, you will need to add the <code class="literal">ConcurrentSessionFilter</code> to your
        <code class="classname">FilterChainProxy</code>. The <code class="classname">ConcurrentSessionFilter</code>
      requires two properties, <code class="literal">sessionRegistry</code>, which generally points to an
      instance of <code class="classname">SessionRegistryImpl</code>, and <code class="literal">expiredUrl</code>, which
      points to the page to display when a session has expired. A configuration using the namespace
      to create the <code class="classname">FilterChainProxy</code> and other default beans might look like
      this: </p><pre class="programlisting">
  &lt;http&gt;
    &lt;custom-filter position="CONCURRENT_SESSION_FILTER" ref="concurrencyFilter" /&gt;
    &lt;custom-filter position="FORM_LOGIN_FILTER" ref="myAuthFilter" /&gt;

    &lt;session-management session-authentication-strategy-ref="sas"/&gt;
  &lt;/http&gt;

  &lt;beans:bean id="concurrencyFilter"
      class="org.springframework.security.web.session.ConcurrentSessionFilter"&gt;
    &lt;beans:property name="sessionRegistry" ref="sessionRegistry" /&gt;
    &lt;beans:property name="expiredUrl" value="/session-expired.htm" /&gt;
  &lt;/beans:bean&gt;

  &lt;beans:bean id="myAuthFilter"
      class="org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"&gt;
    &lt;beans:property name="sessionAuthenticationStrategy" ref="sas" /&gt;
    &lt;beans:property name="authenticationManager" ref="authenticationManager" /&gt;
  &lt;/beans:bean&gt;

  &lt;beans:bean id="sas"
      class="org.springframework.security.web.authentication.session.ConcurrentSessionControlStrategy"&gt;
    &lt;beans:constructor-arg name="sessionRegistry" ref="sessionRegistry" /&gt;
    &lt;beans:property name="maximumSessions" value="1" /&gt;
  &lt;/beans:bean&gt;

  &lt;beans:bean id="sessionRegistry" class="org.springframework.security.core.session.SessionRegistryImpl" /&gt;

    </pre>
    <p>Adding the listener to <code class="filename">web.xml</code> causes an
        <code class="literal">ApplicationEvent</code> to be published to the Spring
        <code class="literal">ApplicationContext</code> every time a <code class="literal">HttpSession</code> commences
      or terminates. This is critical, as it allows the <code class="classname">SessionRegistryImpl</code>
      to be notified when a session ends. Without it, a user will never be able to log back in again
      once they have exceeded their session allowance, even if they log out of another session or it
      times out.</p>
  </div>
<div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d4e1697" href="#d4e1697" class="para">12</a>] </sup>Authentication by
          mechanisms which perform a redirect after authenticating (such as form-login) will not be
          detected by <code class="classname">SessionManagementFilter</code>, as the filter will not be
          invoked during the authenticating request. Session-management functionality has to be
          handled separately in these cases. </p></div></div></div>
    <div class="chapter" title="12.&nbsp;Anonymous Authentication"><div class="titlepage"><div><div><h2 class="title"><a name="anonymous"></a>12.&nbsp;Anonymous Authentication</h2></div></div></div>
    
    <div class="section" title="12.1&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="anonymous-overview"></a>12.1&nbsp;Overview</h2></div></div></div>
        
        <p>It's generally considered good security practice to adopt a
                <span class="quote">&#8220;<span class="quote">deny-by-default</span>&#8221;</span> where you explicitly specify what is allowed and
            disallow everything else. Defining what is accessible to unauthenticated users is a
            similar situation, particularly for web applications. Many sites require that users must
            be authenticated for anything other than a few URLs (for example the home and login
            pages). In this case it is easiest to define access configuration attributes for these
            specific URLs rather than have for every secured resource. Put differently, sometimes it
            is nice to say <code class="literal">ROLE_SOMETHING</code> is required by default and only allow
            certain exceptions to this rule, such as for login, logout and home pages of an
            application. You could also omit these pages from the filter chain entirely, thus
            bypassing the access control checks, but this may be undesirable for other reasons,
            particularly if the pages behave differently for authenticated users.</p>
        <p>This is what we mean by anonymous authentication. Note that there is no real
            conceptual difference between a user who is <span class="quote">&#8220;<span class="quote">anonymously authenticated</span>&#8221;</span> and
            an unauthenticated user. Spring Security's anonymous authentication just gives you a
            more convenient way to configure your access-control attributes. Calls to servlet API
            calls such as <code class="methodname">getCallerPrincipal</code>, for example, will still
            return null even though there is actually an anonymous authentication object in the
                <code class="classname">SecurityContextHolder</code>.</p>
        <p>There are other situations where anonymous authentication is useful, such as when an
            auditing interceptor queries the <code class="classname">SecurityContextHolder</code> to
            identify which principal was responsible for a given operation. Classes can be authored
            more robustly if they know the <code class="classname">SecurityContextHolder</code> always
            contains an <code class="interfacename">Authentication</code> object, and never
                <code class="literal">null</code>.</p>
    </div>
    <div class="section" title="12.2&nbsp;Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="anonymous-config"></a>12.2&nbsp;Configuration</h2></div></div></div>
        
        <p>Anonymous authentication support is provided automatically when using the HTTP
            configuration Spring Security 3.0 and can be customized (or disabled) using the
                <code class="literal">&lt;anonymous&gt;</code> element. You don't need to configure the beans
            described here unless you are using traditional bean configuration.</p>
        <p>Three classes that together provide the anonymous authentication feature.
                <code class="literal">AnonymousAuthenticationToken</code> is an implementation of
                <code class="interfacename">Authentication</code>, and stores the
                <code class="interfacename">GrantedAuthority</code>s which apply to the anonymous
            principal. There is a corresponding <code class="literal">AnonymousAuthenticationProvider</code>,
            which is chained into the <code class="literal">ProviderManager</code> so that
                <code class="literal">AnonymousAuthenticationToken</code>s are accepted. Finally, there is an
                <code class="classname">AnonymousAuthenticationFilter</code>, which is chained after the
            normal authentication mechanisms and automatically adds an
                <code class="literal">AnonymousAuthenticationToken</code> to the
                <code class="classname">SecurityContextHolder</code> if there is no existing
                <code class="interfacename">Authentication</code> held there. The definition of the
            filter and authentication provider appears as follows:</p>
        <p>
            </p><pre class="programlisting">

&lt;bean id="anonymousAuthFilter"
    class="org.springframework.security.web.authentication.AnonymousAuthenticationFilter"&gt;
  &lt;property name="key" value="foobar"/&gt;
  &lt;property name="userAttribute" value="anonymousUser,ROLE_ANONYMOUS"/&gt;
&lt;/bean&gt;

&lt;bean id="anonymousAuthenticationProvider"
    class="org.springframework.security.authentication.AnonymousAuthenticationProvider"&gt;
  &lt;property name="key" value="foobar"/&gt;
&lt;/bean&gt;
    </pre><p>
        </p>
        <p>The <code class="literal">key</code> is shared between the filter and authentication provider,
            so that tokens created by the former are accepted by the latter<sup>[<a name="d4e1786" href="#ftn.d4e1786" class="footnote">13</a>]</sup>. The
                <code class="literal">userAttribute</code> is expressed in the form of
                <code class="literal">usernameInTheAuthenticationToken,grantedAuthority[,grantedAuthority]</code>.
            This is the same syntax as used after the equals sign for
                <code class="literal">InMemoryDaoImpl</code>'s <code class="literal">userMap</code> property.</p>
        <p>As explained earlier, the benefit of anonymous authentication is that all URI patterns
            can have security applied to them. For example:</p>
        <p>
            </p><pre class="programlisting">

&lt;bean id="filterSecurityInterceptor"
    class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor"&gt;
  &lt;property name="authenticationManager" ref="authenticationManager"/&gt;
  &lt;property name="accessDecisionManager" ref="httpRequestAccessDecisionManager"/&gt;
  &lt;property name="securityMetadata"&gt;
    &lt;security:filter-security-metadata-source&gt;
      &lt;security:intercept-url pattern='/index.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
      &lt;security:intercept-url pattern='/hello.htm' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
      &lt;security:intercept-url pattern='/logoff.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
      &lt;security:intercept-url pattern='/login.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
      &lt;security:intercept-url pattern='/**' access='ROLE_USER'/&gt;
    &lt;/security:filter-security-metadata-source&gt;" +
  &lt;/property&gt;
&lt;/bean&gt;
    </pre><p>
        </p>
    </div>
    <div class="section" title="12.3&nbsp;AuthenticationTrustResolver"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="anonymous-auth-trust-resolver"></a>12.3&nbsp;<code class="interfacename">AuthenticationTrustResolver</code></h2></div></div></div>
        
        <p> Rounding out the anonymous authentication discussion is the
                <code class="interfacename">AuthenticationTrustResolver</code> interface, with its
            corresponding <code class="literal">AuthenticationTrustResolverImpl</code> implementation. This
            interface provides an <code class="literal">isAnonymous(Authentication)</code> method, which
            allows interested classes to take into account this special type of authentication
            status. The <code class="classname">ExceptionTranslationFilter</code> uses this interface in
            processing <code class="literal">AccessDeniedException</code>s. If an
                <code class="literal">AccessDeniedException</code> is thrown, and the authentication is of an
            anonymous type, instead of throwing a 403 (forbidden) response, the filter will instead
            commence the <code class="interfacename">AuthenticationEntryPoint</code> so the principal
            can authenticate properly. This is a necessary distinction, otherwise principals would
            always be deemed <span class="quote">&#8220;<span class="quote">authenticated</span>&#8221;</span> and never be given an opportunity to login
            via form, basic, digest or some other normal authentication mechanism. </p>
        <p> You will often see the <code class="literal">ROLE_ANONYMOUS</code> attribute in the above
            interceptor configuration replaced with <code class="literal">IS_AUTHENTICATED_ANONYMOUSLY</code>,
            which is effectively the same thing when defining access controls. This is an example of
            the use of the <code class="classname">AuthenticatedVoter</code> which we will see in the <a class="ulink" href="#authz-authenticated-voter" target="_top">authorization chapter</a>. It uses an
                <code class="interfacename">AuthenticationTrustResolver</code> to process this
            particular configuration attribute and grant access to anonymous users. The
                <code class="classname">AuthenticatedVoter</code> approach is more powerful, since it allows
            you to differentiate between anonymous, remember-me and fully-authenticated users. If
            you don't need this functionality though, then you can stick with
                <code class="literal">ROLE_ANONYMOUS</code>, which will be processed by Spring Security's
            standard <code class="classname">RoleVoter</code>. </p>
    </div>
<div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d4e1786" href="#d4e1786" class="para">13</a>] </sup>The use
                    of the <code class="literal">key</code> property should not be regarded as providing any
                    real security here. It is merely a book-keeping exercise. If you are sharing a
                        <code class="classname">ProviderManager</code> which contains an
                        <code class="classname">AnonymousAuthenticationProvider</code> in a scenario where
                    it is possible for an authenticating client to construct the
                        <code class="interfacename">Authentication</code> object (such as with RMI
                    invocations), then a malicious client could submit an
                        <code class="classname">AnonymousAuthenticationToken</code> which it had created
                    itself (with chosen username and authority list). If the <code class="literal">key</code>
                    is guessable or can be found out, then the token would be accepted by the
                    anonymous provider. This isn't a problem with normal usage but if you are using
                    RMI you would be best to use a customized <code class="classname">ProviderManager</code>
                    which omits the anonymous provider rather than sharing the one you use for your
                    HTTP authentication mechanisms.</p></div></div></div>
  </div>
  
  <div class="part" title="Part&nbsp;IV.&nbsp;Authorization"><div class="titlepage"><div><div><h1 class="title"><a name="authorization"></a>Part&nbsp;IV.&nbsp;Authorization</h1></div></div></div>
    
    <div class="partintro" title="Authorization"><div></div>
      <p>The advanced authorization capabilities within Spring Security represent one of the most
        compelling reasons for its popularity. Irrespective of how you choose to authenticate -
        whether using a Spring Security-provided mechanism and provider, or integrating with a
        container or other non-Spring Security authentication authority - you will find the
        authorization services can be used within your application in a consistent and simple
        way.</p>
      <p>In this part we'll explore the different
          <code class="classname">AbstractSecurityInterceptor</code> implementations, which were introduced
        in Part I. We then move on to explore how to fine-tune authorization through use of domain
        access control lists.</p>
    </div>
    <div class="chapter" title="13.&nbsp;Authorization Architecture"><div class="titlepage"><div><div><h2 class="title"><a name="authz-arch"></a>13.&nbsp;Authorization Architecture</h2></div></div></div>
  
  <div class="section" title="13.1&nbsp;Authorities"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="authz-authorities"></a>13.1&nbsp;Authorities</h2></div></div></div>
    
    <p>As we saw in the <a class="ulink" href="#tech-granted-authority" target="_top">technical overview</a>, all
        <code class="interfacename">Authentication</code> implementations store a list of
        <code class="interfacename">GrantedAuthority</code> objects. These represent the authorities
      that have been granted to the principal. The <code class="interfacename">GrantedAuthority</code>
      objects are inserted into the <code class="interfacename">Authentication</code> object by the
        <code class="interfacename">AuthenticationManager</code> and are later read by
        <code class="interfacename">AccessDecisionManager</code>s when making authorization
      decisions.</p>
    <p><code class="interfacename">GrantedAuthority</code> is an interface with only one method:
      </p><pre class="programlisting">
  String getAuthority();
    </pre><p> This method allows
        <code class="interfacename">AccessDecisionManager</code>s to obtain a precise
        <code class="literal">String</code> representation of the
        <code class="interfacename">GrantedAuthority</code>. By returning a representation as a
        <code class="literal">String</code>, a <code class="interfacename">GrantedAuthority</code> can be easily
        <span class="quote">&#8220;<span class="quote">read</span>&#8221;</span> by most <code class="interfacename">AccessDecisionManager</code>s. If a
        <code class="interfacename">GrantedAuthority</code> cannot be precisely represented as a
        <code class="literal">String</code>, the <code class="interfacename">GrantedAuthority</code> is considered
        <span class="quote">&#8220;<span class="quote">complex</span>&#8221;</span> and <code class="literal">getAuthority()</code> must return
        <code class="literal">null</code>.</p>
    <p>An example of a <span class="quote">&#8220;<span class="quote">complex</span>&#8221;</span>
      <code class="interfacename">GrantedAuthority</code> would be an implementation that stores a list
      of operations and authority thresholds that apply to different customer account numbers.
      Representing this complex <code class="interfacename">GrantedAuthority</code> as a
        <code class="literal">String</code> would be quite difficult, and as a result the
        <code class="literal">getAuthority()</code> method should return <code class="literal">null</code>. This will
      indicate to any <code class="interfacename">AccessDecisionManager</code> that it will need to
      specifically support the <code class="interfacename">GrantedAuthority</code> implementation in
      order to understand its contents.</p>
    <p>Spring Security includes one concrete <code class="interfacename">GrantedAuthority</code>
      implementation, <code class="literal">GrantedAuthorityImpl</code>. This allows any user-specified
        <code class="literal">String</code> to be converted into a
        <code class="interfacename">GrantedAuthority</code>. All
        <code class="classname">AuthenticationProvider</code>s included with the security architecture use
        <code class="literal">GrantedAuthorityImpl</code> to populate the
        <code class="interfacename">Authentication</code> object.</p>
  </div>
  <div class="section" title="13.2&nbsp;Pre-Invocation Handling"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="authz-pre-invocation"></a>13.2&nbsp;Pre-Invocation Handling</h2></div></div></div>
    
    <p> As we've also seen in the <a class="ulink" href="#secure-objects" target="_top">Technical Overview</a>
      chapter, Spring Security provides interceptors which control access to secure objects such as
      method invocations or web requests. A pre-invocation decision on whether the invocation is
      allowed to proceed is made by the <code class="interfacename">AccessDecisionManager</code>. </p>
    <div class="section" title="13.2.1&nbsp;The AccessDecisionManager"><div class="titlepage"><div><div><h3 class="title"><a name="authz-access-decision-manager"></a>13.2.1&nbsp;The AccessDecisionManager</h3></div></div></div>
      
      <p>The <code class="interfacename">AccessDecisionManager</code> is called by the
          <code class="classname">AbstractSecurityInterceptor</code> and is responsible for making final
        access control decisions. The <code class="interfacename">AccessDecisionManager</code> interface
        contains three methods:
        </p><pre class="programlisting">
 void decide(Authentication authentication, Object secureObject,
     List&lt;ConfigAttribute&gt; config) throws AccessDeniedException;
 boolean supports(ConfigAttribute attribute);
 boolean supports(Class clazz);
      </pre><p>
        The <code class="interfacename">AccessDecisionManager</code>'s <code class="methodname">decide</code>
        method is passed all the relevant information it needs in order to make an authorization
        decision. In particular, passing the secure <code class="literal">Object</code> enables those
        arguments contained in the actual secure object invocation to be inspected. For example,
        let's assume the secure object was a <code class="classname">MethodInvocation</code>. It would be
        easy to query the <code class="classname">MethodInvocation</code> for any
          <code class="literal">Customer</code> argument, and then implement some sort of security logic in
        the <code class="interfacename">AccessDecisionManager</code> to ensure the principal is
        permitted to operate on that customer. Implementations are expected to throw an
          <code class="literal">AccessDeniedException</code> if access is denied.</p>
      <p>The <code class="literal">supports(ConfigAttribute)</code> method is called by the
          <code class="classname">AbstractSecurityInterceptor</code> at startup time to determine if the
          <code class="interfacename">AccessDecisionManager</code> can process the passed
          <code class="literal">ConfigAttribute</code>. The <code class="literal">supports(Class)</code> method is
        called by a security interceptor implementation to ensure the configured
          <code class="interfacename">AccessDecisionManager</code> supports the type of secure object
        that the security interceptor will present.</p>
    </div>
    <div class="section" title="13.2.2&nbsp;Voting-Based AccessDecisionManager Implementations"><div class="titlepage"><div><div><h3 class="title"><a name="authz-voting-based"></a>13.2.2&nbsp;Voting-Based AccessDecisionManager Implementations</h3></div></div></div>
      
      <p>Whilst users can implement their own
          <code class="interfacename">AccessDecisionManager</code> to control all aspects of
        authorization, Spring Security includes several
          <code class="interfacename">AccessDecisionManager</code> implementations that are based on
        voting. <a class="xref" href="#authz-access-voting" title="Figure&nbsp;13.1.&nbsp;Voting Decision Manager">Figure&nbsp;13.1, &#8220;Voting Decision Manager&#8221;</a> illustrates the relevant classes.</p>
      <div class="figure"><a name="authz-access-voting"></a><p class="title"><b>Figure&nbsp;13.1.&nbsp;Voting Decision Manager</b></p><div class="figure-contents">
        
        <div class="mediaobject" align="center"><img src="images/access-decision-voting.png" align="middle" alt="Voting Decision Manager"></div>
      </div></div><br class="figure-break">
      <p>Using this approach, a series of <code class="interfacename">AccessDecisionVoter</code>
        implementations are polled on an authorization decision. The
          <code class="interfacename">AccessDecisionManager</code> then decides whether or not to throw
        an <code class="literal">AccessDeniedException</code> based on its assessment of the votes.</p>
      <p>The <code class="interfacename">AccessDecisionVoter</code> interface has three methods:
        </p><pre class="programlisting">
int vote(Authentication authentication, Object object, List&lt;ConfigAttribute&gt; config);
boolean supports(ConfigAttribute attribute);
boolean supports(Class clazz);
</pre><p>
        Concrete implementations return an <code class="literal">int</code>, with possible values being
        reflected in the <code class="interfacename">AccessDecisionVoter</code> static fields
          <code class="literal">ACCESS_ABSTAIN</code>, <code class="literal">ACCESS_DENIED</code> and
          <code class="literal">ACCESS_GRANTED</code>. A voting implementation will return
          <code class="literal">ACCESS_ABSTAIN</code> if it has no opinion on an authorization decision. If it
        does have an opinion, it must return either <code class="literal">ACCESS_DENIED</code> or
          <code class="literal">ACCESS_GRANTED</code>.</p>
      <p>There are three concrete <code class="interfacename">AccessDecisionManager</code>s provided
        with Spring Security that tally the votes. The <code class="literal">ConsensusBased</code>
        implementation will grant or deny access based on the consensus of non-abstain votes.
        Properties are provided to control behavior in the event of an equality of votes or if all
        votes are abstain. The <code class="literal">AffirmativeBased</code> implementation will grant access
        if one or more <code class="literal">ACCESS_GRANTED</code> votes were received (i.e. a deny vote will
        be ignored, provided there was at least one grant vote). Like the
          <code class="literal">ConsensusBased</code> implementation, there is a parameter that controls the
        behavior if all voters abstain. The <code class="literal">UnanimousBased</code> provider expects
        unanimous <code class="literal">ACCESS_GRANTED</code> votes in order to grant access, ignoring
        abstains. It will deny access if there is any <code class="literal">ACCESS_DENIED</code> vote. Like
        the other implementations, there is a parameter that controls the behaviour if all voters
        abstain.</p>
      <p>It is possible to implement a custom
          <code class="interfacename">AccessDecisionManager</code> that tallies votes differently. For
        example, votes from a particular <code class="interfacename">AccessDecisionVoter</code> might
        receive additional weighting, whilst a deny vote from a particular voter may have a veto
        effect.</p>
      <div class="section" title="RoleVoter"><div class="titlepage"><div><div><h4 class="title"><a name="authz-role-voter"></a><code class="classname">RoleVoter</code></h4></div></div></div>
        
        <p> The most commonly used <code class="interfacename">AccessDecisionVoter</code> provided
          with Spring Security is the simple <code class="classname">RoleVoter</code>, which treats
          configuration attributes as simple role names and votes to grant access if the user has
          been assigned that role.</p>
        <p>It will vote if any <code class="interfacename">ConfigAttribute</code> begins with the
          prefix <code class="literal">ROLE_</code>. It will vote to grant access if there is a
            <code class="interfacename">GrantedAuthority</code> which returns a
            <code class="literal">String</code> representation (via the <code class="literal">getAuthority()</code>
          method) exactly equal to one or more <code class="literal">ConfigAttributes</code> starting with the
          prefix <code class="literal">ROLE_</code>. If there is no exact match of any
            <code class="literal">ConfigAttribute</code> starting with <code class="literal">ROLE_</code>, the
            <code class="literal">RoleVoter</code> will vote to deny access. If no
            <code class="literal">ConfigAttribute</code> begins with <code class="literal">ROLE_</code>, the voter will
          abstain.</p>
      </div>
      <div class="section" title="AuthenticatedVoter"><div class="titlepage"><div><div><h4 class="title"><a name="authz-authenticated-voter"></a><code class="classname">AuthenticatedVoter</code></h4></div></div></div>
        
        <p> Another voter which we've implicitly seen is the
            <code class="classname">AuthenticatedVoter</code>, which can be used to differentiate between
          anonymous, fully-authenticated and remember-me authenticated users. Many sites allow
          certain limited access under remember-me authentication, but require a user to confirm
          their identity by logging in for full access.</p>
        <p>When we've used the attribute <code class="literal">IS_AUTHENTICATED_ANONYMOUSLY</code> to grant
          anonymous access, this attribute was being processed by the
            <code class="classname">AuthenticatedVoter</code>. See the Javadoc for this class for more
          information. </p>
      </div>
      <div class="section" title="Custom Voters"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1972"></a>Custom Voters</h4></div></div></div>
        
        <p>It is also possible to implement a custom
            <code class="interfacename">AccessDecisionVoter</code>. Several examples are provided in
          Spring Security unit tests, including <code class="literal">ContactSecurityVoter</code> and
            <code class="literal">DenyVoter</code>. The <code class="literal">ContactSecurityVoter</code> abstains from
          voting decisions where a <code class="literal">CONTACT_OWNED_BY_CURRENT_USER</code>
          <code class="literal">ConfigAttribute</code> is not found. If voting, it queries the
            <code class="classname">MethodInvocation</code> to extract the owner of the
            <code class="literal">Contact</code> object that is subject of the method call. It votes to grant
          access if the <code class="literal">Contact</code> owner matches the principal presented in the
            <code class="interfacename">Authentication</code> object. It could have just as easily
          compared the <code class="literal">Contact</code> owner with some
            <code class="interfacename">GrantedAuthority</code> the
            <code class="interfacename">Authentication</code> object presented. All of this is achieved
          with relatively few lines of code and demonstrates the flexibility of the authorization
          model.</p>
      </div>
    </div>
  </div>
  <div class="section" title="13.3&nbsp;After Invocation Handling"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="authz-after-invocation-handling"></a>13.3&nbsp;After Invocation Handling</h2></div></div></div>
    
    <p>Whilst the <code class="interfacename">AccessDecisionManager</code> is called by the
        <code class="classname">AbstractSecurityInterceptor</code> before proceeding with the secure object
      invocation, some applications need a way of modifying the object actually returned by the
      secure object invocation. Whilst you could easily implement your own AOP concern to achieve
      this, Spring Security provides a convenient hook that has several concrete implementations
      that integrate with its ACL capabilities.</p>
    <p><a class="xref" href="#authz-after-invocation" title="Figure&nbsp;13.2.&nbsp;After Invocation Implementation">Figure&nbsp;13.2, &#8220;After Invocation Implementation&#8221;</a> illustrates Spring Security's
        <code class="literal">AfterInvocationManager</code> and its concrete implementations. </p><div class="figure"><a name="authz-after-invocation"></a><p class="title"><b>Figure&nbsp;13.2.&nbsp;After Invocation Implementation</b></p><div class="figure-contents">
        
        <div class="mediaobject" align="center"><img src="images/after-invocation.png" align="middle" alt="After Invocation Implementation"></div>
      </div></div><p><br class="figure-break"></p>
    <p>Like many other parts of Spring Security, <code class="literal">AfterInvocationManager</code> has a
      single concrete implementation, <code class="literal">AfterInvocationProviderManager</code>, which polls
      a list of <code class="literal">AfterInvocationProvider</code>s. Each
        <code class="literal">AfterInvocationProvider</code> is allowed to modify the return object or throw
      an <code class="literal">AccessDeniedException</code>. Indeed multiple providers can modify the object,
      as the result of the previous provider is passed to the next in the list.</p>
    <p>Please be aware that if you're using <code class="literal">AfterInvocationManager</code>, you will
      still need configuration attributes that allow the
        <code class="classname">MethodSecurityInterceptor</code>'s
        <code class="interfacename">AccessDecisionManager</code> to allow an operation. If you're using
      the typical Spring Security included <code class="interfacename">AccessDecisionManager</code>
      implementations, having no configuration attributes defined for a particular secure method
      invocation will cause each <code class="interfacename">AccessDecisionVoter</code> to abstain from
      voting. In turn, if the <code class="interfacename">AccessDecisionManager</code> property
        "<code class="literal">allowIfAllAbstainDecisions</code>" is <code class="literal">false</code>, an
        <code class="literal">AccessDeniedException</code> will be thrown. You may avoid this potential issue
      by either (i) setting "<code class="literal">allowIfAllAbstainDecisions</code>" to
        <code class="literal">true</code> (although this is generally not recommended) or (ii) simply ensure
      that there is at least one configuration attribute that an
        <code class="interfacename">AccessDecisionVoter</code> will vote to grant access for. This
      latter (recommended) approach is usually achieved through a <code class="literal">ROLE_USER</code> or
        <code class="literal">ROLE_AUTHENTICATED</code> configuration attribute.</p>
    
    
  </div>
  
</div>
    <div class="chapter" title="14.&nbsp;Secure Object Implementations"><div class="titlepage"><div><div><h2 class="title"><a name="secure-object-impls"></a>14.&nbsp;Secure Object Implementations</h2></div></div></div>
  
  <div class="section" title="14.1&nbsp;AOP Alliance (MethodInvocation) Security Interceptor"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-alliance"></a>14.1&nbsp;AOP Alliance (MethodInvocation) Security Interceptor</h2></div></div></div>
    
    <p> Prior to Spring Security 2.0, securing <code class="classname">MethodInvocation</code>s needed
      quite a lot of boiler plate configuration. Now the recommended approach for method security is
      to use <a class="ulink" href="#ns-method-security" target="_top">namespace configuration</a>. This way the
      method security infrastructure beans are configured automatically for you so you don't really
      need to know about the implementation classes. We'll just provide a quick overview of the
      classes that are involved here. </p>
    <p> Method security in enforced using a <code class="classname">MethodSecurityInterceptor</code>,
      which secures <code class="classname">MethodInvocation</code>s. Depending on the configuration
      approach, an interceptor may be specific to a single bean or shared between multiple beans.
      The interceptor uses a <code class="interfacename">MethodSecurityMetadataSource</code> instance to
      obtain the configuration attributes that apply to a particular method invocation.
        <code class="classname">MapBasedMethodSecurityMetadataSource</code> is used to store configuration
      attributes keyed by method names (which can be wildcarded) and will be used internally when
      the attributes are defined in the application context using the
        <code class="literal">&lt;intercept-methods&gt;</code> or <code class="literal">&lt;protect-point&gt;</code>
      elements. Other implementations will be used to handle annotation-based configuration. </p>
    <div class="section" title="14.1.1&nbsp;Explicit MethodSecurityInterceptor Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="d4e2042"></a>14.1.1&nbsp;Explicit MethodSecurityInterceptor Configuration</h3></div></div></div>
      
      <p> You can of course configure a <code class="classname">MethodSecurityIterceptor</code> directly
        in your application context for use with one of Spring AOP's proxying mechanisms: </p><pre class="programlisting">
&lt;bean id="bankManagerSecurity"
    class="org.springframework.security.access.intercept.aopalliance.MethodSecurityInterceptor"&gt;
  &lt;property name="authenticationManager" ref="authenticationManager"/&gt;
  &lt;property name="accessDecisionManager" ref="accessDecisionManager"/&gt;
  &lt;property name="afterInvocationManager" ref="afterInvocationManager"/&gt;
  &lt;property name="securityMetadataSource"&gt;
    &lt;value&gt;
      com.mycompany.BankManager.delete*=ROLE_SUPERVISOR
      com.mycompany.BankManager.getBalance=ROLE_TELLER,ROLE_SUPERVISOR
    &lt;/value&gt;
  &lt;/property&gt;
&lt;/bean&gt; 
</pre>
    </div>
  </div>
  <div class="section" title="14.2&nbsp;AspectJ (JoinPoint) Security Interceptor"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aspectj"></a>14.2&nbsp;AspectJ (JoinPoint) Security Interceptor</h2></div></div></div>
    
    <p>The AspectJ security interceptor is very similar to the AOP Alliance security interceptor
      discussed in the previous section. Indeed we will only discuss the differences in this
      section.</p>
    <p>The AspectJ interceptor is named <code class="literal">AspectJSecurityInterceptor</code>. Unlike the
      AOP Alliance security interceptor, which relies on the Spring application context to weave in
      the security interceptor via proxying, the <code class="literal">AspectJSecurityInterceptor</code> is
      weaved in via the AspectJ compiler. It would not be uncommon to use both types of security
      interceptors in the same application, with <code class="literal">AspectJSecurityInterceptor</code> being
      used for domain object instance security and the AOP Alliance
        <code class="classname">MethodSecurityInterceptor</code> being used for services layer
      security.</p>
    <p>Let's first consider how the <code class="literal">AspectJSecurityInterceptor</code> is configured
      in the Spring application context:</p>
    <pre class="programlisting">
&lt;bean id="bankManagerSecurity"
     class="org.springframework.security.access.intercept.aspectj.AspectJSecurityInterceptor"&gt;
  &lt;property name="authenticationManager" ref="authenticationManager"/&gt;
  &lt;property name="accessDecisionManager" ref="accessDecisionManager"/&gt;
  &lt;property name="afterInvocationManager" ref="afterInvocationManager"/&gt;
  &lt;property name="securityMetadataSource"&gt;
    &lt;value&gt;
        com.mycompany.BankManager.delete*=ROLE_SUPERVISOR
        com.mycompany.BankManager.getBalance=ROLE_TELLER,ROLE_SUPERVISOR
    &lt;/value&gt;
&lt;/property&gt;
&lt;/bean&gt;        </pre>
    <p>As you can see, aside from the class name, the
        <code class="literal">AspectJSecurityInterceptor</code> is exactly the same as the AOP Alliance
      security interceptor. Indeed the two interceptors can share the same
        <code class="literal">securityMetadataSource</code>, as the
        <code class="interfacename">SecurityMetadataSource</code> works with
        <code class="literal">java.lang.reflect.Method</code>s rather than an AOP library-specific class. Of
      course, your access decisions have access to the relevant AOP library-specific invocation (ie
        <code class="classname">MethodInvocation</code> or <code class="literal">JoinPoint</code>) and as such can
      consider a range of addition criteria when making access decisions (such as method
      arguments).</p>
    <p>Next you'll need to define an AspectJ <code class="literal">aspect</code>. For example:</p>
    <pre class="programlisting">
<span class="hl-keyword">package</span> org.springframework.security.samples.aspectj;

<span class="hl-keyword">import</span> org.springframework.security.access.intercept.aspectj.AspectJSecurityInterceptor;
<span class="hl-keyword">import</span> org.springframework.security.access.intercept.aspectj.AspectJCallback;
<span class="hl-keyword">import</span> org.springframework.beans.factory.InitializingBean;

<span class="hl-keyword">public</span> aspect DomainObjectInstanceSecurityAspect <span class="hl-keyword">implements</span> InitializingBean {

    <span class="hl-keyword">private</span> AspectJSecurityInterceptor securityInterceptor;

    pointcut domainObjectInstanceExecution(): target(PersistableEntity)
        &amp;&amp; execution(<span class="hl-keyword">public</span> * *(..)) &amp;&amp; !within(DomainObjectInstanceSecurityAspect);

    Object around(): domainObjectInstanceExecution() {
        <span class="hl-keyword">if</span> (<span class="hl-keyword">this</span>.securityInterceptor == null) {
            <span class="hl-keyword">return</span> proceed();
        }

        AspectJCallback callback = <span class="hl-keyword">new</span> AspectJCallback() {
            <span class="hl-keyword">public</span> Object proceedWithObject() {
                <span class="hl-keyword">return</span> proceed();
            }
        };

        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.securityInterceptor.invoke(thisJoinPoint, callback);
    }

    <span class="hl-keyword">public</span> AspectJSecurityInterceptor getSecurityInterceptor() {
        <span class="hl-keyword">return</span> securityInterceptor;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setSecurityInterceptor(AspectJSecurityInterceptor securityInterceptor) {
        <span class="hl-keyword">this</span>.securityInterceptor = securityInterceptor;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> afterPropertiesSet() <span class="hl-keyword">throws</span> Exception {
        <span class="hl-keyword">if</span> (<span class="hl-keyword">this</span>.securityInterceptor == null)
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(<span class="hl-string">"securityInterceptor required"</span>);
        }
    }
}
</pre>
    <p>In the above example, the security interceptor will be applied to every instance of
        <code class="literal">PersistableEntity</code>, which is an abstract class not shown (you can use any
      other class or <code class="literal">pointcut</code> expression you like). For those curious,
        <code class="literal">AspectJCallback</code> is needed because the <code class="literal">proceed();</code>
      statement has special meaning only within an <code class="literal">around()</code> body. The
        <code class="literal">AspectJSecurityInterceptor</code> calls this anonymous
        <code class="literal">AspectJCallback</code> class when it wants the target object to continue.</p>
    <p>You will need to configure Spring to load the aspect and wire it with the
        <code class="literal">AspectJSecurityInterceptor</code>. A bean declaration which achieves this is
      shown below:</p>
    <pre class="programlisting">
&lt;bean id="domainObjectInstanceSecurityAspect"
     class="security.samples.aspectj.DomainObjectInstanceSecurityAspect"
     factory-method="aspectOf"&gt;
  &lt;property name="securityInterceptor" ref="bankManagerSecurity"/&gt;
&lt;/bean&gt;
    </pre>
    <p>That's it! Now you can create your beans from anywhere within your application, using
      whatever means you think fit (eg <code class="literal">new Person();</code>) and they will have the
      security interceptor applied.</p>
  </div>
</div>
    <div class="chapter" title="15.&nbsp;Expression-Based Access Control"><div class="titlepage"><div><div><h2 class="title"><a name="el-access"></a>15.&nbsp;Expression-Based Access Control</h2></div></div></div>
    
    <p> Spring Security 3.0 introduced the ability to use Spring EL expressions as an
        authorization mechanism in addition to the simple use of configuration attributes and
        access-decision voters which have seen before. Expression-based access control is built on
        the same architecture but allows complicated boolean logic to be encapsulated in a single
        expression.</p>
    <div class="section" title="15.1&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e2086"></a>15.1&nbsp;Overview</h2></div></div></div>
        
        <p>Spring Security uses Spring EL for expression support and you should look at how that
            works if you are interested in understanding the topic in more depth. Expressions are
            evaluated with a <span class="quote">&#8220;<span class="quote">root object</span>&#8221;</span> as part of the evaluation context. Spring
            Security uses specific classes for web and method security as the root object, in order
            to provide built-in expressions and access to values such as the current
            principal.</p>
        <div class="section" title="15.1.1&nbsp;Common Built-In Expressions"><div class="titlepage"><div><div><h3 class="title"><a name="el-common-built-in"></a>15.1.1&nbsp;Common Built-In Expressions</h3></div></div></div>
            
            <p>The base class for expression root objects is
                    <code class="classname">SecurityExpressionRoot</code>. This provides some common
                expressions which are available in both web and method security.</p>
            <div class="table"><a name="d4e2094"></a><p class="title"><b>Table&nbsp;15.1.&nbsp;Common built-in expressions</b></p><div class="table-contents">
                
                <table summary="Common built-in expressions" style="border: none;"><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Expression</th><th style="border-bottom: 0.5pt solid ; ">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">hasRole([role])</code></td><td style="border-bottom: 0.5pt solid ; ">Returns <code class="literal">true</code> if the current principal has the
                                specified role.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">hasAnyRole([role1,role2])</code></td><td style="border-bottom: 0.5pt solid ; ">Returns <code class="literal">true</code> if the current principal has any
                                of the supplied roles (given as a comma-separated list of
                                strings)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">principal</code></td><td style="border-bottom: 0.5pt solid ; ">Allows direct access to the principal object representing the
                                current user</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">authentication</code></td><td style="border-bottom: 0.5pt solid ; ">Allows direct access to the current
                                    <code class="interfacename">Authentication</code> object obtained
                                from the <code class="interfacename">SecurityContext</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">permitAll</code></td><td style="border-bottom: 0.5pt solid ; ">Always evaluates to <code class="literal">true</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">denyAll</code></td><td style="border-bottom: 0.5pt solid ; ">Always evaluates to <code class="literal">false</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">isAnonymous()</code></td><td style="border-bottom: 0.5pt solid ; ">Returns <code class="literal">true</code> if the current principal is an
                                anonymous user</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">isRememberMe()</code></td><td style="border-bottom: 0.5pt solid ; ">Returns <code class="literal">true</code> if the current principal is a
                                remember-me user</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">isAuthenticated()</code></td><td style="border-bottom: 0.5pt solid ; ">Returns <code class="literal">true</code> if the user is not
                                anonymous</td></tr><tr><td style="border-right: 0.5pt solid ; "><code class="literal">isFullyAuthenticated()</code></td><td style="">Returns <code class="literal">true</code> if the user is not an anonymous
                                or a remember-me user</td></tr></tbody></table>
            </div></div><br class="table-break">
        </div>
    </div>
    <div class="section" title="15.2&nbsp;Web Security Expressions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="el-access-web"></a>15.2&nbsp;Web Security Expressions</h2></div></div></div>
        
        <p> To use expressions to secure individual URLs, you would first need to set the
                <code class="literal">use-expressions</code> attribute in the <code class="literal">&lt;http&gt;</code>
            element to <code class="literal">true</code>. Spring Security will then expect the
                <code class="literal">access</code> attributes of the <code class="literal">&lt;intercept-url&gt;</code>
            elements to contain Spring EL expressions. The expressions should evaluate to a boolean,
            defining whether access should be allowed or not. For example:</p><pre class="programlisting">
  &lt;http use-expressions="true"&gt;
    &lt;intercept-url pattern="/admin*"
        access="hasRole('admin') and hasIpAddress('192.168.1.0/24')"/&gt;
    ...
  &lt;/http&gt;
</pre><p>Here we have defined that the <span class="quote">&#8220;<span class="quote">admin</span>&#8221;</span> area of an application
            (defined by the URL pattern) should only be available to users who have the granted
            authority <span class="quote">&#8220;<span class="quote">admin</span>&#8221;</span> and whose IP address matches a local subnet. We've
            already seen the built-in <code class="literal">hasRole</code> expression in the previous section.
            The expression <code class="literal">hasIpAddress</code> is an additional built-in expression
            which is specific to web security. It is defined by the
                <code class="classname">WebSecurityExpressionRoot</code> class, an instance of which is used
            as the expression root object when evaluation web-access expressions. This object also
            directly exposed the <code class="interfacename">HttpServletRequest</code> object under the
            name <code class="literal">request</code> so you can invoke the request directly in an
            expression.</p>
        <p>If expressions are being used, a <code class="classname">WebExpressionVoter</code> will be
            added to the <code class="interfacename">AccessDecisionManager</code> which is used by the
            namespace. So if you aren't using the namespace and want to use expressions, you will
            have to add one of these to your configuration.</p>
    </div>
    <div class="section" title="15.3&nbsp;Method Security Expressions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e2173"></a>15.3&nbsp;Method Security Expressions</h2></div></div></div>
        
        <p>Method security is a bit more complicated than a simple allow or deny rule. Spring
            Security 3.0 introduced some new annotations in order to allow comprehensive support for
            the use of expressions.</p>
        <div class="section" title="15.3.1&nbsp;@Pre and @Post Annotations"><div class="titlepage"><div><div><h3 class="title"><a name="el-pre-post-annotations"></a>15.3.1&nbsp;<code class="literal">@Pre</code> and <code class="literal">@Post</code> Annotations</h3></div></div></div>
            
            <p>There are four annotations which support expression attributes to allow pre and
                post-invocation authorization checks and also to support filtering of submitted
                collection arguments or return values. They are <code class="literal">@PreAuthorize</code>,
                    <code class="literal">@PreFilter</code>, <code class="literal">@PostAuthorize</code> and
                    <code class="literal">@PostFilter</code>. Their use is enabled through the
                    <code class="literal">global-method-security</code> namespace
                element:</p><pre class="programlisting">&lt;global-method-security pre-post-annotations="enabled"/&gt;</pre>
            <div class="section" title="Access Control using @PreAuthorize and @PostAuthorize"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2187"></a>Access Control using <code class="literal">@PreAuthorize</code> and
                        <code class="literal">@PostAuthorize</code></h4></div></div></div>
                
                <p>The most obviously useful annotation is <code class="literal">@PreAuthorize</code> which
                    decides whether a method can actually be invoked or not. For example (from the
                        <span class="quote">&#8220;<span class="quote">Contacts</span>&#8221;</span> sample
                    application)</p><pre class="programlisting">  @PreAuthorize("hasRole('ROLE_USER')")
  public void create(Contact contact);</pre><p>which
                    means that access will only be allowed for users with the role "ROLE_USER".
                    Obviously the same thing could easily be achieved using a traditional
                    configuration and a simple configuration attribute for the required role. But
                    what
                    about:</p><pre class="programlisting">  @PreAuthorize("hasPermission(#contact, 'admin')")
  public void deletePermission(Contact contact, Sid recipient, Permission permission);</pre><p>Here
                    we're actually using a method argument as part of the expression to decide
                    whether the current user has the <span class="quote">&#8220;<span class="quote">admin</span>&#8221;</span>permission for the given
                    contact. The built-in <code class="literal">hasPermission()</code> expression is linked
                    into the Spring Security ACL module through the application context, as we'll
                        <a class="ulink" href="#el-permission-evaluator" target="_top">see below</a>. You can access
                    any of the method arguments by name as expression variables, provided your code
                    has debug information compiled in. Any Spring-EL functionality is available
                    within the expression, so you can also access properties on the arguments. For
                    example, if you wanted a particular method to only allow access to a user whose
                    username matched that of the contact, you could write</p>
                <pre class="programlisting">  @PreAuthorize("#contact.name == principal.name)")
  public void doSomething(Contact contact);</pre>
                <p>Here we are accessing another built&#8211;in expression, which is the
                        <code class="literal">principal</code> of the current Spring Security
                        <code class="interfacename">Authentication</code> object obtained from the
                    security context. You can also access the
                        <code class="interfacename">Authentication</code> object itself directly using
                    the expression name <code class="literal">authentication</code>.</p>
                <p>Less commonly, you may wish to perform an access-control check after the
                    method has been invoked. This can be achieved using the
                        <code class="literal">@PostAuthorize</code> annotation. To access the return value
                    from a method, use the built&#8211;in name <code class="literal">returnObject</code> in the
                    expression.</p>
            </div>
            <div class="section" title="Filtering using @PreFilter and @PostFilter"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2208"></a>Filtering using <code class="literal">@PreFilter</code> and
                        <code class="literal">@PostFilter</code></h4></div></div></div>
                
                <p>As you may already be aware, Spring Security supports filtering of collections
                    and arrays and this can now be achieved using expressions. This is most commonly
                    performed on the return value of a method. For
                    example:</p><pre class="programlisting">  @PreAuthorize("hasRole('ROLE_USER')")
  @PostFilter("hasPermission(filterObject, 'read') or hasPermission(filterObject, 'admin')")
  public List&lt;Contact&gt; getAll();</pre><p>When
                    using the <code class="literal">@PostFilter</code> annotation, Spring Security iterates
                    through the returned collection and removes any elements for which the supplied
                    expression is false. The name <code class="literal">filterObject</code> refers to the
                    current object in the collection. You can also filter before the method call,
                    using <code class="literal">@PreFilter</code>, though this is a less common requirement.
                    The syntax is just the same, but if there is more than one argument which is a
                    collection type then you have to select one by name using the
                        <code class="literal">filterTarget</code> property of this annotation.</p>
                <p>Note that filtering is obviously not a substitute for tuning your data
                    retrieval queries. If you are filtering large collections and removing many of
                    the entries then this is likely to be inefficient.</p>
            </div>
        </div>
        <div class="section" title="15.3.2&nbsp;Built-In Expressions"><div class="titlepage"><div><div><h3 class="title"><a name="el-method-built-in"></a>15.3.2&nbsp;Built-In Expressions</h3></div></div></div>
            
            <p>There are some built-in expressions which are specific to method security, which
                we have already seen in use above. The <code class="literal">filterTarget</code> and
                    <code class="literal">returnValue</code> values are simple enough, but the use of the
                    <code class="literal">hasPermission()</code> expression warrants a closer look.</p>
            <div class="section" title="The PermissionEvaluator interface"><div class="titlepage"><div><div><h4 class="title"><a name="el-permission-evaluator"></a>The <code class="interfacename">PermissionEvaluator</code> interface</h4></div></div></div>
                
                <p><code class="literal">hasPermission()</code> expressions are delegated to an instance of
                        <code class="interfacename">PermissionEvaluator</code>. It is intended to bridge
                    between the expression system and Spring Security's ACL system, allowing you to
                    specify authorization constraints on domain objects, based on abstract
                    permissions. It has no explicit dependencies on the ACL module, so you could
                    swap that out for an alternative implementation if required. The interface has
                    two methods:
                    </p><pre class="programlisting">  <span class="hl-keyword">boolean</span> hasPermission(Authentication authentication, Object targetDomainObject, Object permission);

  <span class="hl-keyword">boolean</span> hasPermission(Authentication authentication, Serializable targetId, String targetType, Object permission);</pre><p>which
                    map directly to the available versions of the expression, with the exception
                    that the first argument (the <code class="interfacename">Authentication</code>
                    object) is not supplied. The first is used in situations where the domain
                    object, to which access is being controlled, is already loaded. Then expression
                    will return true if the current user has the given permission for that object.
                    The second version is used in cases where the object is not loaded, but its
                    identifier is known. An abstract <span class="quote">&#8220;<span class="quote">type</span>&#8221;</span> specifier for the domain
                    object is also required, allowing the correct ACL permissions to be loaded. This
                    has traditionally been the Java class of the object, but does not have to be as
                    long as it is consistent with how the permissions are loaded.</p>
                <p>To use <code class="literal">hasPermission()</code> expressions, you have to explicitly
                    configure a <code class="interfacename">PermissionEvaluator</code> in your
                    application context. This would look something like this:</p><pre class="programlisting">  <span class="hl-tag">&lt;security:global-method-security</span> <span class="hl-attribute">pre-post-annotations</span>=<span class="hl-value">"enabled"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;security:expression-handler</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"expressionHandler"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/security:global-method-security&gt;</span>

  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"expressionHandler"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"permissionEvaluator"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myPermissionEvaluator"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/bean&gt;</span></pre><p>Where <code class="literal">myPermissionEvaluator</code> is the bean which
                    implements <code class="interfacename">PermissionEvaluator</code>. Usually this will
                    be the implementation from the ACL module which is called
                        <code class="classname">AclPermissionEvaluator</code>. See the
                        <span class="quote">&#8220;<span class="quote">Contacts</span>&#8221;</span> sample application configuration for more
                    details.</p>
            </div>
        </div>
    </div>
</div>
  </div>
  <div class="part" title="Part&nbsp;V.&nbsp;Additional Topics"><div class="titlepage"><div><div><h1 class="title"><a name="advanced-topics"></a>Part&nbsp;V.&nbsp;Additional Topics</h1></div></div></div>
    
    
    <div class="partintro" title="Additional Topics"><div></div>
      <p> In this part we cover features which require a knowledge of previous chapters  as well
        as some of the more advanced and less-commonly used features of the framework.</p>
    </div>
    <div class="chapter" title="16.&nbsp;Domain Object Security (ACLs)"><div class="titlepage"><div><div><h2 class="title"><a name="domain-acls"></a>16.&nbsp;Domain Object Security (ACLs)</h2></div></div></div>
    
    <div class="section" title="16.1&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="domain-acls-overview"></a>16.1&nbsp;Overview</h2></div></div></div>
        
        <p>Complex applications often will find the need to define access permissions not simply
            at a web request or method invocation level. Instead, security decisions need to
            comprise both who (<code class="interfacename">Authentication</code>), where
            (<code class="classname">MethodInvocation</code>) and what (<code class="literal">SomeDomainObject</code>). In
            other words, authorization decisions also need to consider the actual domain object
            instance subject of a method invocation.</p>
        <p>Imagine you're designing an application for a pet clinic. There will be two main
            groups of users of your Spring-based application: staff of the pet clinic, as well as
            the pet clinic's customers. The staff will have access to all of the data, whilst your
            customers will only be able to see their own customer records. To make it a little more
            interesting, your customers can allow other users to see their customer records, such as
            their "puppy preschool" mentor or president of their local "Pony Club". Using Spring
            Security as the foundation, you have several approaches that can be used:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                    <p>Write your business methods to enforce the security. You could consult a
                        collection within the <code class="literal">Customer</code> domain object instance to
                        determine which users have access. By using the
                            <code class="literal">SecurityContextHolder.getContext().getAuthentication()</code>,
                        you'll be able to access the <code class="interfacename">Authentication</code>
                    object.</p>
                </li><li class="listitem">
                    <p>Write an <code class="interfacename">AccessDecisionVoter</code> to enforce the security
                        from the <code class="literal">GrantedAuthority[]</code>s stored in the
                            <code class="interfacename">Authentication</code> object. This would mean your
                            <code class="interfacename">AuthenticationManager</code> would need to populate the
                            <code class="interfacename">Authentication</code> with custom
                        <code class="interfacename">GrantedAuthority</code>[]s representing each of the
                            <code class="literal">Customer</code> domain object instances the principal has
                        access to.</p>
                </li><li class="listitem">
                    <p>Write an <code class="interfacename">AccessDecisionVoter</code> to enforce the security
                        and open the target <code class="literal">Customer</code> domain object directly. This
                        would mean your voter needs access to a DAO that allows it to retrieve the
                            <code class="literal">Customer</code> object. It would then access the
                            <code class="literal">Customer</code> object's collection of approved users and
                        make the appropriate decision.</p>
                </li></ol></div>
        <p>Each one of these approaches is perfectly legitimate. However, the first couples your
            authorization checking to your business code. The main problems with this include the
            enhanced difficulty of unit testing and the fact it would be more difficult to reuse the
                <code class="literal">Customer</code> authorization logic elsewhere. Obtaining the
                <code class="literal">GrantedAuthority[]</code>s from the <code class="interfacename">Authentication</code>
            object is also fine, but will not scale to large numbers of
            <code class="literal">Customer</code>s. If a user might be able to access 5,000
            <code class="literal">Customer</code>s (unlikely in this case, but imagine if it were a popular
            vet for a large Pony Club!) the amount of memory consumed and time required to construct
            the <code class="interfacename">Authentication</code> object would be undesirable. The final method,
            opening the <code class="literal">Customer</code> directly from external code, is probably the
            best of the three. It achieves separation of concerns, and doesn't misuse memory or CPU
            cycles, but it is still inefficient in that both the
            <code class="interfacename">AccessDecisionVoter</code> and the eventual business method itself will
            perform a call to the DAO responsible for retrieving the <code class="literal">Customer</code>
            object. Two accesses per method invocation is clearly undesirable. In addition, with
            every approach listed you'll need to write your own access control list (ACL)
            persistence and business logic from scratch.</p>
        <p>Fortunately, there is another alternative, which we'll talk about below.</p>
    </div>
    <div class="section" title="16.2&nbsp;Key Concepts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="domain-acls-key-concepts"></a>16.2&nbsp;Key Concepts</h2></div></div></div>
        
        <p>Spring Security's ACL services are shipped in the
            <code class="literal">spring-security-acl-xxx.jar</code>. You will need to add this JAR to your
            classpath to use Spring Security's domain object instance security capabilities.</p>
        <p>Spring Security's domain object instance security capabilities centre on the concept
            of an access control list (ACL). Every domain object instance in your system has its own
            ACL, and the ACL records details of who can and can't work with that domain object. With
            this in mind, Spring Security delivers three main ACL-related capabilities to your application:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                    <p>A way of efficiently retrieving ACL entries for all of your domain objects
                        (and modifying those ACLs)</p>
                </li><li class="listitem">
                    <p>A way of ensuring a given principal is permitted to work with your
                        objects, before methods are called</p>
                </li><li class="listitem">
                    <p>A way of ensuring a given principal is permitted to work with your objects
                        (or something they return), after methods are called</p>
                </li></ul></div>
        <p>As indicated by the first bullet point, one of the main capabilities of the Spring
            Security ACL module is providing a high-performance way of retrieving ACLs. This ACL
            repository capability is extremely important, because every domain object instance in
            your system might have several access control entries, and each ACL might inherit from
            other ACLs in a tree-like structure (this is supported out-of-the-box by Spring
            Security, and is very commonly used). Spring Security's ACL capability has been
            carefully designed to provide high performance retrieval of ACLs, together with
            pluggable caching, deadlock-minimizing database updates, independence from ORM
            frameworks (we use JDBC directly), proper encapsulation, and transparent database
            updating.</p>
        <p>Given databases are central to the operation of the ACL module, let's explore the four
            main tables used by default in the implementation. The tables are presented below in
            order of size in a typical Spring Security ACL deployment, with the table with the most
            rows listed last:</p>
        <p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                    <p>ACL_SID allows us to uniquely identify any principal or authority in the
                        system ("SID" stands for "security identity"). The only columns are the ID,
                        a textual representation of the SID, and a flag to indicate whether the
                        textual representation refers to a principal name or a
                            <code class="interfacename">GrantedAuthority</code>. Thus, there is a single row for
                        each unique principal or <code class="interfacename">GrantedAuthority</code>. When used in
                        the context of receiving a permission, a SID is generally called a
                        "recipient".</p>
                </li><li class="listitem">
                    <p>ACL_CLASS allows us to uniquely identify any domain object class in the
                        system. The only columns are the ID and the Java class name. Thus, there is
                        a single row for each unique Class we wish to store ACL permissions
                    for.</p>
                </li><li class="listitem">
                    <p>ACL_OBJECT_IDENTITY stores information for each unique domain object
                        instance in the system. Columns include the ID, a foreign key to the
                        ACL_CLASS table, a unique identifier so we know which ACL_CLASS instance
                        we're providing information for, the parent, a foreign key to the ACL_SID
                        table to represent the owner of the domain object instance, and whether we
                        allow ACL entries to inherit from any parent ACL. We have a single row for
                        every domain object instance we're storing ACL permissions for.</p>
                </li><li class="listitem">
                    <p>Finally, ACL_ENTRY stores the individual permissions assigned to each
                        recipient. Columns include a foreign key to the ACL_OBJECT_IDENTITY, the
                        recipient (ie a foreign key to ACL_SID), whether we'll be auditing or not,
                        and the integer bit mask that represents the actual permission being granted
                        or denied. We have a single row for every recipient that receives a
                        permission to work with a domain object.</p>
                </li></ul></div><p>
        </p>
        <p>As mentioned in the last paragraph, the ACL system uses integer bit masking. Don't
            worry, you need not be aware of the finer points of bit shifting to use the ACL system,
            but suffice to say that we have 32 bits we can switch on or off. Each of these bits
            represents a permission, and by default the permissions are read (bit 0), write (bit 1),
            create (bit 2), delete (bit 3) and administer (bit 4). It's easy to implement your own
                <code class="literal">Permission</code> instance if you wish to use other permissions, and the
            remainder of the ACL framework will operate without knowledge of your extensions.</p>
        <p>It is important to understand that the number of domain objects in your system has
            absolutely no bearing on the fact we've chosen to use integer bit masking. Whilst you
            have 32 bits available for permissions, you could have billions of domain object
            instances (which will mean billions of rows in ACL_OBJECT_IDENTITY and quite probably
            ACL_ENTRY). We make this point because we've found sometimes people mistakenly believe
            they need a bit for each potential domain object, which is not the case.</p>
        <p>Now that we've provided a basic overview of what the ACL system does, and what it
            looks like at a table structure, let's explore the key interfaces. The key interfaces
            are:</p>
        <div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
                <p><code class="literal">Acl</code>: Every domain object has one and only one
                    <code class="literal">Acl</code> object, which internally holds the
                        <code class="literal">AccessControlEntry</code>s as well as knows the owner of the
                        <code class="literal">Acl</code>. An Acl does not refer directly to the domain object,
                    but instead to an <code class="literal">ObjectIdentity</code>. The <code class="literal">Acl</code>
                    is stored in the ACL_OBJECT_IDENTITY table.</p>
            </li><li class="listitem">
                <p><code class="literal">AccessControlEntry</code>: An <code class="literal">Acl</code> holds
                    multiple <code class="literal">AccessControlEntry</code>s, which are often abbreviated as
                    ACEs in the framework. Each ACE refers to a specific tuple of
                        <code class="literal">Permission</code>, <code class="literal">Sid</code> and
                    <code class="literal">Acl</code>. An ACE can also be granting or non-granting and contain
                    audit settings. The ACE is stored in the ACL_ENTRY table.</p>
            </li><li class="listitem">
                <p><code class="literal">Permission</code>: A permission represents a particular immutable
                    bit mask, and offers convenience functions for bit masking and outputting
                    information. The basic permissions presented above (bits 0 through 4) are
                    contained in the <code class="literal">BasePermission</code> class.</p>
            </li><li class="listitem">
                <p><code class="literal">Sid</code>: The ACL module needs to refer to principals and
                        <code class="literal">GrantedAuthority[]</code>s. A level of indirection is provided
                    by the <code class="literal">Sid</code> interface, which is an abbreviation of "security
                    identity". Common classes include <code class="literal">PrincipalSid</code> (to represent
                    the principal inside an <code class="interfacename">Authentication</code> object) and
                        <code class="literal">GrantedAuthoritySid</code>. The security identity information is
                    stored in the ACL_SID table.</p>
            </li><li class="listitem">
                <p><code class="literal">ObjectIdentity</code>: Each domain object is represented
                    internally within the ACL module by an <code class="literal">ObjectIdentity</code>. The
                    default implementation is called <code class="literal">ObjectIdentityImpl</code>.</p>
            </li><li class="listitem">
                <p><code class="literal">AclService</code>: Retrieves the <code class="literal">Acl</code> applicable
                    for a given <code class="literal">ObjectIdentity</code>. In the included implementation
                        (<code class="literal">JdbcAclService</code>), retrieval operations are delegated to a
                        <code class="literal">LookupStrategy</code>. The <code class="literal">LookupStrategy</code>
                    provides a highly optimized strategy for retrieving ACL information, using
                    batched retrievals <code class="literal">(BasicLookupStrategy</code>) and supporting
                    custom implementations that leverage materialized views, hierarchical queries
                    and similar performance-centric, non-ANSI SQL capabilities.</p>
            </li><li class="listitem">
                <p><code class="literal">MutableAclService</code>: Allows a modified <code class="literal">Acl</code>
                    to be presented for persistence. It is not essential to use this interface if
                    you do not wish.</p>
            </li></ul></div>
        <p>Please note that our out-of-the-box AclService and related database classes all use
            ANSI SQL. This should therefore work with all major databases. At the time of writing,
            the system had been successfully tested using Hypersonic SQL, PostgreSQL, Microsoft SQL
            Server and Oracle.</p>
        <p>Two samples ship with Spring Security that demonstrate the ACL module. The first is
            the Contacts Sample, and the other is the Document Management System (DMS) Sample. We
            suggest taking a look over these for examples.</p>
    </div>
    <div class="section" title="16.3&nbsp;Getting Started"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="domain-acls-getting-started"></a>16.3&nbsp;Getting Started</h2></div></div></div>
        
        <p>To get starting using Spring Security's ACL capability, you will need to store your
            ACL information somewhere. This necessitates the instantiation of a
            <code class="literal">DataSource</code> using Spring. The <code class="literal">DataSource</code> is then
            injected into a <code class="literal">JdbcMutableAclService</code> and
                <code class="literal">BasicLookupStrategy</code> instance. The latter provides
            high-performance ACL retrieval capabilities, and the former provides mutator
            capabilities. Refer to one of the samples that ship with Spring Security for an example
            configuration. You'll also need to populate the database with the four ACL-specific
            tables listed in the last section (refer to the ACL samples for the appropriate SQL
            statements).</p>
        <p>Once you've created the required schema and instantiated
                <code class="literal">JdbcMutableAclService</code>, you'll next need to ensure your domain
            model supports interoperability with the Spring Security ACL package. Hopefully
                <code class="literal">ObjectIdentityImpl</code> will prove sufficient, as it provides a large
            number of ways in which it can be used. Most people will have domain objects that
            contain a <code class="literal">public Serializable getId()</code> method. If the return type is
            long, or compatible with long (eg an int), you will find you need not give further
            consideration to <code class="literal">ObjectIdentity</code> issues. Many parts of the ACL module
            rely on long identifiers. If you're not using long (or an int, byte etc), there is a
            very good chance you'll need to reimplement a number of classes. We do not intend to
            support non-long identifiers in Spring Security's ACL module, as longs are already
            compatible with all database sequences, the most common identifier data type, and are of
            sufficient length to accommodate all common usage scenarios.</p>
        <p>The following fragment of code shows how to create an <code class="literal">Acl</code>, or
            modify an existing
            <code class="literal">Acl</code>:</p><pre class="programlisting">// Prepare the information we'd like in our access control entry (ACE)
ObjectIdentity oi = new ObjectIdentityImpl(Foo.class, new Long(44));
Sid sid = new PrincipalSid("Samantha");
Permission p = BasePermission.ADMINISTRATION;

// Create or update the relevant ACL
MutableAcl acl = null;
try {
  acl = (MutableAcl) aclService.readAclById(oi);
} catch (NotFoundException nfe) {
  acl = aclService.createAcl(oi);
}

// Now grant some permissions via an access control entry (ACE)
acl.insertAce(acl.getEntries().length, p, sid, true);
aclService.updateAcl(acl);
</pre>
        <p>In the example above, we're retrieving the ACL associated with the "Foo" domain object
            with identifier number 44. We're then adding an ACE so that a principal named "Samantha"
            can "administer" the object. The code fragment is relatively self-explanatory, except
            the insertAce method. The first argument to the insertAce method is determining at what
            position in the Acl the new entry will be inserted. In the example above, we're just
            putting the new ACE at the end of the existing ACEs. The final argument is a boolean
            indicating whether the ACE is granting or denying. Most of the time it will be granting
            (true), but if it is denying (false), the permissions are effectively being blocked.</p>
        <p>Spring Security does not provide any special integration to automatically create,
            update or delete ACLs as part of your DAO or repository operations. Instead, you will
            need to write code like shown above for your individual domain objects. It's worth
            considering using AOP on your services layer to automatically integrate the ACL
            information with your services layer operations. We've found this quite an effective
            approach in the past.</p>
        <p>Once you've used the above techniques to store some ACL information in the database,
            the next step is to actually use the ACL information as part of authorization decision
            logic. You have a number of choices here. You could write your own
                <code class="interfacename">AccessDecisionVoter</code> or <code class="literal">AfterInvocationProvider</code>
            that respectively fires before or after a method invocation. Such classes would use
                <code class="literal">AclService</code> to retrieve the relevant ACL and then call
                <code class="literal">Acl.isGranted(Permission[] permission, Sid[] sids, boolean
                administrativeMode)</code> to decide whether permission is granted or denied.
            Alternately, you could use our <code class="literal">AclEntryVoter</code>,
                <code class="literal">AclEntryAfterInvocationProvider</code> or
                <code class="literal">AclEntryAfterInvocationCollectionFilteringProvider</code> classes. All
            of these classes provide a declarative-based approach to evaluating ACL information at
            runtime, freeing you from needing to write any code. Please refer to the sample
            applications to learn how to use these classes.</p>
    </div>
</div>
    <div class="chapter" title="17.&nbsp;Pre-Authentication Scenarios"><div class="titlepage"><div><div><h2 class="title"><a name="preauth"></a>17.&nbsp;Pre-Authentication Scenarios</h2></div></div></div>
  
  <p> There are situations where you want to use Spring Security for authorization, but the user
    has already been reliably authenticated by some external system prior to accessing the
    application. We refer to these situations as <span class="quote">&#8220;<span class="quote">pre-authenticated</span>&#8221;</span> scenarios.
    Examples include X.509, Siteminder and authentication by the J2EE container in which the
    application is running. When using pre-authentication, Spring Security has to
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Identify the user making the request.
          </p></li><li class="listitem"><p>Obtain the authorities for the
      user.</p></li></ol></div><p>The details will depend on the external authentication
    mechanism. A user might be identified by their certificate information in the case of X.509, or
    by an HTTP request header in the case of Siteminder. If relying on container authentication, the
    user will be identified by calling the <code class="methodname">getUserPrincipal()</code> method on the
    incoming HTTP request. In some cases, the external mechanism may supply role/authority
    information for the user but in others the authorities must be obtained from a separate source,
    such as a <code class="interfacename">UserDetailsService</code>. </p>
  <div class="section" title="17.1&nbsp;Pre-Authentication Framework Classes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e2413"></a>17.1&nbsp;Pre-Authentication Framework Classes</h2></div></div></div>
    
    <p> Because most pre-authentication mechanisms follow the same pattern, Spring Security has a
      set of classes which provide an internal framework for implementing pre-authenticated
      authentication providers. This removes duplication and allows new implementations to be added
      in a structured fashion, without having to write everything from scratch. You don't need to
      know about these classes if you want to use something like <a class="ulink" href="#x509" target="_top">X.509
        authentication</a>, as it already has a namespace configuration option which is simpler
      to use and get started with. If you need to use explicit bean configuration or are planning on
      writing your own implementation then an understanding of how the provided implementations work
      will be useful. You will find classes under the
        <span class="package">org.springframework.security.web.authentication.preauth</span>. We just provide
      an outline here so you should consult the Javadoc and source where appropriate. </p>
    <div class="section" title="17.1.1&nbsp;AbstractPreAuthenticatedProcessingFilter"><div class="titlepage"><div><div><h3 class="title"><a name="d4e2418"></a>17.1.1&nbsp;AbstractPreAuthenticatedProcessingFilter</h3></div></div></div>
      
      <p> This class will check the current contents of the security context and, if empty, it
        will attempt to extract user information from the HTTP request and submit it to the
          <code class="interfacename">AuthenticationManager</code>. Subclasses override the following
        methods to obtain this information:
        </p><pre class="programlisting">
  <span class="hl-keyword">protected</span> <span class="hl-keyword">abstract</span> Object getPreAuthenticatedPrincipal(HttpServletRequest request);

  <span class="hl-keyword">protected</span> <span class="hl-keyword">abstract</span> Object getPreAuthenticatedCredentials(HttpServletRequest request);
</pre><p>
        After calling these, the filter will create a
          <code class="classname">PreAuthenticatedAuthenticationToken</code> containing the returned data
        and submit it for authentication. By <span class="quote">&#8220;<span class="quote">authentication</span>&#8221;</span> here, we really just mean
        further processing to perhaps load the user's authorities, but the standard Spring Security
        authentication architecture is followed. </p>
    </div>
    <div class="section" title="17.1.2&nbsp;AbstractPreAuthenticatedAuthenticationDetailsSource"><div class="titlepage"><div><div><h3 class="title"><a name="d4e2425"></a>17.1.2&nbsp;AbstractPreAuthenticatedAuthenticationDetailsSource</h3></div></div></div>
      
      <p> Like other Spring Security authentication filters, the pre-authentication filter has an
          <code class="literal">authenticationDetailsSource</code> property which by default will create a
          <code class="classname">WebAuthenticationDetails</code> object to store additional information
        such as the session-identifier and originating IP address in the <code class="literal">details</code>
        property of the <code class="interfacename">Authentication</code> object. In cases where user
        role information can be obtained from the pre-authentication mechanism, the data is also
        stored in this property. Subclasses of
          <code class="classname">AbstractPreAuthenticatedAuthenticationDetailsSource</code> use an extended
        details object which implements the
          <code class="interfacename">GrantedAuthoritiesContainer</code> interface, thus enabling the
        authentication provider to read the authorities which were externally allocated to the user.
        We'll look at a concrete example next. </p>
      <div class="section" title="J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource"><div class="titlepage"><div><div><h4 class="title"><a name="j2ee-preauth-details"></a>J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource</h4></div></div></div>
        
        <p> If the filter is configured with an <code class="literal">authenticationDetailsSource</code>
          which is an instance of this class, the authority information is obtained by calling the
            <code class="methodname">isUserInRole(String role)</code> method for each of a pre-determined
          set of <span class="quote">&#8220;<span class="quote">mappable roles</span>&#8221;</span>. The class gets these from a configured
            <code class="interfacename">MappableAttributesRetriever</code>. Possible implementations
          include hard-coding a list in the application context and reading the role information
          from the <code class="literal">&lt;security-role&gt;</code> information in a
            <code class="filename">web.xml</code> file. The pre-authentication sample application uses the
          latter approach. </p>
        <p>There is an additional stage where the roles (or attributes) are mapped to Spring
          Security <code class="interfacename">GrantedAuthority</code> objects using a configured
            <code class="interfacename">Attributes2GrantedAuthoritiesMapper</code>. The default will
          just add the usual <code class="literal">ROLE_</code> prefix to the names, but it gives you full
          control over the behaviour. </p>
      </div>
    </div>
    <div class="section" title="17.1.3&nbsp;PreAuthenticatedAuthenticationProvider"><div class="titlepage"><div><div><h3 class="title"><a name="d4e2447"></a>17.1.3&nbsp;PreAuthenticatedAuthenticationProvider</h3></div></div></div>
      
      <p> The pre-authenticated provider has little more to do than load the
          <code class="interfacename">UserDetails</code> object for the user. It does this by delegating
        to a <code class="interfacename">AuthenticationUserDetailsService</code>. The latter is similar
        to the standard <code class="interfacename">UserDetailsService</code> but takes an
          <code class="interfacename">Authentication</code> object rather than just user name:
        </p><pre class="programlisting">
  <span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> AuthenticationUserDetailsService {
    UserDetails loadUserDetails(Authentication token) <span class="hl-keyword">throws</span> UsernameNotFoundException;
  }
</pre><p>
        This interface may have also other uses but with pre-authentication it allows access to the
        authorities which were packaged in the <code class="interfacename">Authentication</code> object,
        as we saw in the previous section. The
          <code class="classname">PreAuthenticatedGrantedAuthoritiesUserDetailsService</code> class does
        this. Alternatively, it may delegate to a standard
          <code class="interfacename">UserDetailsService</code> via the
          <code class="classname">UserDetailsByNameServiceWrapper</code> implementation. </p>
    </div>
    <div class="section" title="17.1.4&nbsp;Http403ForbiddenEntryPoint"><div class="titlepage"><div><div><h3 class="title"><a name="d4e2459"></a>17.1.4&nbsp;Http403ForbiddenEntryPoint</h3></div></div></div>
      
      <p> The <code class="interfacename">AuthenticationEntryPoint</code> was discussed in the <a class="ulink" href="#tech-intro-auth-entry-point" target="_top">technical overview</a> chapter. Normally it
        is responsible for kick-starting the authentication process for an unauthenticated user
        (when they try to access a protected resource), but in the pre-authenticated case this
        doesn't apply. You would only configure the
          <code class="classname">ExceptionTranslationFilter</code> with an instance of this class if you
        aren't using pre-authentication in combination with other authentication mechanisms. It will
        be called if the user is rejected by the
          <code class="classname">AbstractPreAuthenticatedProcessingFilter</code> resulting in a null
        authentication. It always returns a <code class="literal">403</code>-forbidden response code if
        called. </p>
    </div>
  </div>
  <div class="section" title="17.2&nbsp;Concrete Implementations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e2467"></a>17.2&nbsp;Concrete Implementations</h2></div></div></div>
    
    <p> X.509 authentication is covered in its <a class="ulink" href="#x509" target="_top">own chapter</a>. Here
      we'll look at some classes which provide support for other pre-authenticated scenarios. </p>
    <div class="section" title="17.2.1&nbsp;Request-Header Authentication (Siteminder)"><div class="titlepage"><div><div><h3 class="title"><a name="d4e2471"></a>17.2.1&nbsp;Request-Header Authentication (Siteminder)</h3></div></div></div>
      
      <p> An external authentication system may supply information to the application by setting
        specific headers on the HTTP request. A well known example of this is Siteminder, which
        passes the username in a header called <code class="literal">SM_USER</code>. This mechanism is
        supported by the class <code class="classname">RequestHeaderAuthenticationFilter</code> which simply
        extracts the username from the header. It defaults to using the name
          <code class="literal">SM_USER</code> as the header name. See the Javadoc for more details. </p>
      <div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
        <p>Note that when using a system like this, the framework performs no authentication
          checks at all and it is <span class="emphasis"><em>extremely</em></span> important that the external system
          is configured properly and protects all access to the application. If an attacker is able
          to forge the headers in their original request without this being detected then they could
          potentially choose any username they wished. </p>
      </td></tr></table></div>
      <div class="section" title="Siteminder Example Configuration"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2480"></a>Siteminder Example Configuration</h4></div></div></div>
        
        <p> A typical configuration using this filter would look like this: </p><pre class="programlisting">
  &lt;security:http&gt;
    &lt;!-- Additional http configuration omitted --&gt;
    &lt;security:custom-filter ref="siteminderFilter" /&gt;
  &lt;/security:http&gt;

    &lt;bean id="siteminderFilter" class=
"org.springframework.security.web.authentication.preauth.header.RequestHeaderAuthenticationFilter"&gt;
    &lt;property name="principalRequestHeader" value="SM_USER"/&gt;
    &lt;property name="authenticationManager" ref="authenticationManager" /&gt;
  &lt;/bean&gt;

  &lt;bean id="preauthAuthProvider"
class="org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationProvider"&gt;
    &lt;property name="preAuthenticatedUserDetailsService"&gt;
      &lt;bean id="userDetailsServiceWrapper"
          class="org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper"&gt;
        &lt;property name="userDetailsService" ref="userDetailsService"/&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
    &lt;/bean&gt;

    &lt;security:authentication-manager alias="authenticationManager"&gt;
      &lt;security:authentication-provider ref="preauthAuthProvider" /&gt;
    &lt;/security-authentication-manager&gt;

</pre><p> We've assumed here that the security namespace is being used for
          configuration (hence the user of the <code class="literal">custom-filter</code>,
            <code class="literal">authentication-manager</code> and
            <code class="literal">custom-authentication-provider</code> elements (you can read more about them
          in the <a class="ulink" href="#ns-config" target="_top">namespace chapter</a>). You would leave these out
          of a traditional bean configuration. It's also assumed that you have added a
            <code class="interfacename">UserDetailsService</code> (called
            <span class="quote">&#8220;<span class="quote">userDetailsService</span>&#8221;</span>) to your configuration to load the user's roles.
        </p>
      </div>
    </div>
    <div class="section" title="17.2.2&nbsp;J2EE Container Authentication"><div class="titlepage"><div><div><h3 class="title"><a name="d4e2490"></a>17.2.2&nbsp;J2EE Container Authentication</h3></div></div></div>
      
      <p> The class <code class="classname">J2eePreAuthenticatedProcessingFilter</code> will extract the
        username from the <code class="literal">userPrincipal</code> property of the
          <code class="interfacename">HttpServletRequest</code>. Use of this filter would usually be
        combined with the use of J2EE roles as described above in <a class="xref" href="#j2ee-preauth-details" title="J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource">the section called &#8220;J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource&#8221;</a>. </p>
      <p> There is a sample application in the codebase which uses this approach, so get hold of
        the code from subversion and have a look at the application context file if you are
        interested. The code is in the <code class="filename">samples/preauth</code> directory. </p>
    </div>
  </div>
</div>
    <div class="chapter" title="18.&nbsp;LDAP Authentication"><div class="titlepage"><div><div><h2 class="title"><a name="ldap"></a>18.&nbsp;LDAP Authentication</h2></div></div></div>
    
    <div class="section" title="18.1&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ldap-overview"></a>18.1&nbsp;Overview</h2></div></div></div>
        
        <p>LDAP is often used by organizations as a central repository for user information and
            as an authentication service. It can also be used to store the role information for
            application users.</p>
        <p>There are many different scenarios for how an LDAP server may be configured so Spring
            Security's LDAP provider is fully configurable. It uses separate strategy interfaces for
            authentication and role retrieval and provides default implementations which can be
            configured to handle a wide range of situations.</p>
        <p>You should be familiar with LDAP before trying to use it with Spring Security. The
            following link provides a good introduction to the concepts involved and a guide to
            setting up a directory using the free LDAP server OpenLDAP: <code class="uri"><a class="uri" href="http://www.zytrax.com/books/ldap/" target="_top">http://www.zytrax.com/books/ldap/</a></code>. Some familiarity with the JNDI APIs used
            to access LDAP from Java may also be useful. We don't use any third-party LDAP libraries
            (Mozilla, JLDAP etc.) in the LDAP provider, but extensive use is made of Spring LDAP, so
            some familiarity with that project may be useful if you plan on adding your own
            customizations.</p>
    </div>
    <div class="section" title="18.2&nbsp;Using LDAP with Spring Security"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e2511"></a>18.2&nbsp;Using LDAP with Spring Security</h2></div></div></div>
        
        <p> LDAP authentication in Spring Security can be roughly divided into the following
            stages. </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                    <p>Obtaining the unique LDAP <span class="quote">&#8220;<span class="quote">Distinguished Name</span>&#8221;</span>, or DN, from
                        the login name. This will often mean performing a search in the directory,
                        unless the exact mapping of usernames to DNs is known in advance.</p>
                </li><li class="listitem">
                    <p>Authenticating the user, either by binding as that user or by performing a
                        remote <span class="quote">&#8220;<span class="quote">compare</span>&#8221;</span> operation of the user's password against the
                        password attribute in the directory entry for the DN.</p>
                </li><li class="listitem">
                    <p>Loading the list of authorities for the user.</p>
                </li></ol></div><p> The exception is when the LDAP directory is just being used to retrieve
            user information and authenticate against it locally. This may not be possible as
            directories are often set up with limited read access for attributes such as user
            passwords. </p>
        <p> We will look at some configuration scenarios below. For full information on available
            configuration options, please consult the security namespace schema (information from
            which should be available in your XML editor). </p>
    </div>
    <div class="section" title="18.3&nbsp;Configuring an LDAP Server"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ldap-server"></a>18.3&nbsp;Configuring an LDAP Server</h2></div></div></div>
        
        <p> The first thing you need to do is configure the server against which authentication
            should take place. This is done using the <code class="literal">&lt;ldap-server&gt;</code> element
            from the security namespace. This can be configured to point at an external LDAP server,
            using the <code class="literal">url</code> attribute: </p><pre class="programlisting">
  &lt;ldap-server url="ldap://springframework.org:389/dc=springframework,dc=org" /&gt;

            </pre>
        <div class="section" title="18.3.1&nbsp;Using an Embedded Test Server"><div class="titlepage"><div><div><h3 class="title"><a name="d4e2534"></a>18.3.1&nbsp;Using an Embedded Test Server</h3></div></div></div>
            
            <p> The <code class="literal">&lt;ldap-server&gt;</code> element can also be used to create an
                embedded server, which can be very useful for testing and demonstrations. In this
                case you use it without the <code class="literal">url</code> attribute: </p><pre class="programlisting">
  &lt;ldap-server root="dc=springframework,dc=org"/&gt;
 
    </pre><p> Here we've specified that the root DIT of the directory should be
                    <span class="quote">&#8220;<span class="quote">dc=springframework,dc=org</span>&#8221;</span>, which is the default. Used this way,
                the namespace parser will create an embedded Apache Directory server and scan the
                classpath for any LDIF files, which it will attempt to load into the server. You can
                customize this behaviour using the <code class="literal">ldif</code> attribute, which defines
                an LDIF resource to be loaded: </p><pre class="programlisting">
  &lt;ldap-server ldif="classpath:users.ldif" /&gt;
        </pre><p> This makes it a lot easier to get up and running with LDAP, since it
                can be inconvenient to work all the time with an external server. It also insulates
                the user from the complex bean configuration needed to wire up an Apache Directory
                server. Using plain Spring Beans the configuration would be much more cluttered. You
                must have the necessary Apache Directory dependency jars available for your
                application to use. These can be obtained from the LDAP sample application. </p>
        </div>
        <div class="section" title="18.3.2&nbsp;Using Bind Authentication"><div class="titlepage"><div><div><h3 class="title"><a name="d4e2545"></a>18.3.2&nbsp;Using Bind Authentication</h3></div></div></div>
            
            <p> This is the most common LDAP authentication scenario. </p><pre class="programlisting">
  &lt;ldap-authentication-provider user-dn-pattern="uid={0},ou=people"/&gt;
                     </pre><p> This simple example would obtain the DN for the user by
                substituting the user login name in the supplied pattern and attempting to bind as
                that user with the login password. This is OK if all your users are stored under a
                single node in the directory. If instead you wished to configure an LDAP search
                filter to locate the user, you could use the following: </p><pre class="programlisting">
  &lt;ldap-authentication-provider user-search-filter="(uid={0})"
          user-search-base="ou=people"/&gt;
                    </pre><p> If used with the server definition above, this would
                perform a search under the DN <code class="literal">ou=people,dc=springframework,dc=org</code>
                using the value of the <code class="literal">user-search-filter</code> attribute as a filter.
                Again the user login name is substituted for the parameter in the filter name. If
                    <code class="literal">user-search-base</code> isn't supplied, the search will be performed
                from the root. </p>
        </div>
        <div class="section" title="18.3.3&nbsp;Loading Authorities"><div class="titlepage"><div><div><h3 class="title"><a name="d4e2555"></a>18.3.3&nbsp;Loading Authorities</h3></div></div></div>
            
            <p> How authorities are loaded from groups in the LDAP directory is controlled by the
                following attributes. </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                        <p>
                            <code class="literal">group-search-base</code>. Defines the part of the directory
                            tree under which group searches should be performed.</p>
                    </li><li class="listitem">
                        <p>
                            <code class="literal">group-role-attribute</code>. The attribute which contains
                            the name of the authority defined by the group entry. Defaults to
                                <code class="literal">cn</code>
                        </p>
                    </li><li class="listitem">
                        <p>
                            <code class="literal">group-search-filter</code>. The filter which is used to
                            search for group membership. The default is
                                <code class="literal">uniqueMember={0}</code>, corresponding to the
                                <code class="literal">groupOfUniqueMembers</code> LDAP class. In this case,
                            the substituted parameter is the full distinguished name of the user.
                            The parameter <code class="literal">{1}</code> can be used if you want to filter
                            on the login name.</p>
                    </li></ul></div><p> So if we used the following configuration </p><pre class="programlisting">
  &lt;ldap-authentication-provider user-dn-pattern="uid={0},ou=people"
          group-search-base="ou=groups" /&gt;
    </pre><p> and authenticated successfully as user <span class="quote">&#8220;<span class="quote">ben</span>&#8221;</span>, the subsequent
                loading of authorities would perform a search under the directory entry
                    <code class="literal">ou=groups,dc=springframework,dc=org</code>, looking for entries
                which contain the attribute <code class="literal">uniqueMember</code> with value
                    <code class="literal">uid=ben,ou=people,dc=springframework,dc=org</code>. By default the
                authority names will have the prefix <code class="literal">ROLE_</code> prepended. You can
                change this using the <code class="literal">role-prefix</code> attribute. If you don't want
                any prefix, use <code class="literal">role-prefix="none"</code>. For more information on
                loading authorities, see the Javadoc for the
                    <code class="classname">DefaultLdapAuthoritiesPopulator</code> class. </p>
        </div>
    </div>
    <div class="section" title="18.4&nbsp;Implementation Classes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e2583"></a>18.4&nbsp;Implementation Classes</h2></div></div></div>
        
        <p>The namespace configuration options we've used above are simple to use and much more
            concise than using Spring beans explicitly. There are situations when you may need to
            know how to configure Spring Security LDAP directly in your application context. You may
            wish to customize the behaviour of some of the classes, for example. If you're happy
            using namespace configuration then you can skip this section and the next one. </p>
        <p> The main LDAP provider class, <code class="classname">LdapAuthenticationProvider</code>,
            doesn't actually do much itself but delegates the work to two other beans, an
                <code class="interfacename">LdapAuthenticator</code> and an
                <code class="interfacename">LdapAuthoritiesPopulator</code> which are responsible for
            authenticating the user and retrieving the user's set of
                <code class="interfacename">GrantedAuthority</code>s respectively.</p>
        <div class="section" title="18.4.1&nbsp;LdapAuthenticator Implementations"><div class="titlepage"><div><div><h3 class="title"><a name="ldap-ldap-authenticators"></a>18.4.1&nbsp;LdapAuthenticator Implementations</h3></div></div></div>
            
            <p>The authenticator is also responsible for retrieving any required user attributes.
                This is because the permissions on the attributes may depend on the type of
                authentication being used. For example, if binding as the user, it may be necessary
                to read them with the user's own permissions.</p>
            <p>There are currently two authentication strategies supplied with Spring Security: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                        <p>Authentication directly to the LDAP server ("bind"
                            authentication).</p>
                    </li><li class="listitem">
                        <p>Password comparison, where the password supplied by the user is
                            compared with the one stored in the repository. This can either be done
                            by retrieving the value of the password attribute and checking it
                            locally or by performing an LDAP "compare" operation, where the supplied
                            password is passed to the server for comparison and the real password
                            value is never retrieved.</p>
                    </li></ul></div>
            <div class="section" title="Common Functionality"><div class="titlepage"><div><div><h4 class="title"><a name="ldap-ldap-authenticators-common"></a>Common Functionality</h4></div></div></div>
                
                <p>Before it is possible to authenticate a user (by either strategy), the
                    distinguished name (DN) has to be obtained from the login name supplied to the
                    application. This can be done either by simple pattern-matching (by setting the
                        <span class="property">setUserDnPatterns</span> array property) or by setting the
                        <span class="property">userSearch</span> property. For the DN pattern-matching
                    approach, a standard Java pattern format is used, and the login name will be
                    substituted for the parameter <em class="parameter"><code>{0}</code></em>. The pattern should be
                    relative to the DN that the configured
                        <code class="interfacename">SpringSecurityContextSource</code> will bind to (see
                    the section on <a class="link" href="#ldap-context-source" title="18.4.2&nbsp;Connecting to the LDAP Server">connecting to the LDAP
                        server</a> for more information on this). For example, if you are using
                    an LDAP server with the URL
                        <code class="literal">ldap://monkeymachine.co.uk/dc=springframework,dc=org</code>, and
                    have a pattern <code class="literal">uid={0},ou=greatapes</code>, then a login name of
                    "gorilla" will map to a DN
                        <code class="literal">uid=gorilla,ou=greatapes,dc=springframework,dc=org</code>. Each
                    configured DN pattern will be tried in turn until a match is found. For
                    information on using a search, see the section on <a class="link" href="#ldap-searchobjects" title="18.4.3&nbsp;LDAP Search Objects">search objects</a> below. A combination of
                    the two approaches can also be used - the patterns will be checked first and if
                    no matching DN is found, the search will be used.</p>
            </div>
            <div class="section" title="BindAuthenticator"><div class="titlepage"><div><div><h4 class="title"><a name="ldap-ldap-authenticators-bind"></a>BindAuthenticator</h4></div></div></div>
                
                <p>The class <code class="classname">BindAuthenticator</code> in the package
                        <code class="filename">org.springframework.security.ldap.authentication</code>
                    implements the bind authentication strategy. It simply attempts to bind as the
                    user.</p>
            </div>
            <div class="section" title="PasswordComparisonAuthenticator"><div class="titlepage"><div><div><h4 class="title"><a name="ldap-ldap-authenticators-password"></a>PasswordComparisonAuthenticator</h4></div></div></div>
                
                <p>The class <code class="classname">PasswordComparisonAuthenticator</code> implements
                    the password comparison authentication strategy.</p>
            </div>
            <div class="section" title="Active Directory Authentication"><div class="titlepage"><div><div><h4 class="title"><a name="ldap-ldap-authenticators-active-directory"></a>Active Directory Authentication</h4></div></div></div>
                
                <p>In addition to standard LDAP authentication (binding with a DN), Active
                    Directory has its own non-standard syntax for user authentication.</p>
            </div>
        </div>
        <div class="section" title="18.4.2&nbsp;Connecting to the LDAP Server"><div class="titlepage"><div><div><h3 class="title"><a name="ldap-context-source"></a>18.4.2&nbsp;Connecting to the LDAP Server</h3></div></div></div>
            
            <p>The beans discussed above have to be able to connect to the server. They both have
                to be supplied with a <code class="interfacename">SpringSecurityContextSource</code>
                which is an extension of Spring LDAP's <code class="interfacename">ContextSource</code>.
                Unless you have special requirements, you will usually configure a
                    <code class="classname">DefaultSpringSecurityContextSource</code> bean, which can be
                configured with the URL of your LDAP server and optionally with the username and
                password of a "manager" user which will be used by default when binding to the
                server (instead of binding anonymously). For more information read the Javadoc for
                this class and for Spring LDAP's <code class="classname">AbstractContextSource</code>.
            </p>
        </div>
        <div class="section" title="18.4.3&nbsp;LDAP Search Objects"><div class="titlepage"><div><div><h3 class="title"><a name="ldap-searchobjects"></a>18.4.3&nbsp;LDAP Search Objects</h3></div></div></div>
            
            <p>Often a more complicated strategy than simple DN-matching is required to
                locate a user entry in the directory. This can be encapsulated in an
                    <code class="interfacename">LdapUserSearch</code> instance which can be supplied to
                the authenticator implementations, for example, to allow them to locate a user. The
                supplied implementation is <code class="classname">FilterBasedLdapUserSearch</code>.</p>
            <div class="section" title="FilterBasedLdapUserSearch"><div class="titlepage"><div><div><h4 class="title"><a name="ldap-searchobjects-filter"></a>
                        <code class="classname">FilterBasedLdapUserSearch</code>
                    </h4></div></div></div>
                
                <p>This bean uses an LDAP filter to match the user object in the directory. The
                    process is explained in the Javadoc for the corresponding search method on the
                        <a class="ulink" href="http://java.sun.com/j2se/1.4.2/docs/api/javax/naming/directory/DirContext.html#search(javax.naming.Name,%20java.lang.String,%20java.lang.Object[],%20javax.naming.directory.SearchControls)" target="_top">JDK DirContext class</a>. As explained there, the search filter can be
                    supplied with parameters. For this class, the only valid parameter is
                        <em class="parameter"><code>{0}</code></em> which will be replaced with the user's login
                    name.</p>
            </div>
        </div>
        <div class="section" title="18.4.4&nbsp;LdapAuthoritiesPopulator"><div class="titlepage"><div><div><h3 class="title"><a name="ldap-authorities"></a>18.4.4&nbsp;LdapAuthoritiesPopulator</h3></div></div></div>
            
            <p> After authenticating the user successfully, the
                    <code class="classname">LdapAuthenticationProvider</code> will attempt to load a set of
                authorities for the user by calling the configured
                    <code class="interfacename">LdapAuthoritiesPopulator</code> bean. The
                    <code class="classname">DefaultLdapAuthoritiesPopulator</code> is an implementation
                which will load the authorities by searching the directory for groups of which the
                user is a member (typically these will be <code class="literal">groupOfNames</code> or
                    <code class="literal">groupOfUniqueNames</code> entries in the directory). Consult the
                Javadoc for this class for more details on how it works. </p>
            <p>If you want to use LDAP only for authentication, but load the authorities from a
                difference source (such as a database) then you can provide your own implementation
                of this interface and inject that instead.</p>
        </div>
        <div class="section" title="18.4.5&nbsp;Spring Bean Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="ldap-bean-config"></a>18.4.5&nbsp;Spring Bean Configuration</h3></div></div></div>
            
            <p>A typical configuration, using some of the beans we've discussed here, might look
                like this: </p><pre class="programlisting">
&lt;bean id="contextSource"
        class="org.springframework.security.ldap.DefaultSpringSecurityContextSource"&gt;
  &lt;constructor-arg value="ldap://monkeymachine:389/dc=springframework,dc=org"/&gt;
  &lt;property name="userDn" value="cn=manager,dc=springframework,dc=org"/&gt;
  &lt;property name="password" value="password"/&gt;
&lt;/bean&gt;

&lt;bean id="ldapAuthProvider"
    class="org.springframework.security.ldap.authentication.LdapAuthenticationProvider"&gt;
 &lt;constructor-arg&gt;
   &lt;bean class="org.springframework.security.ldap.authentication.BindAuthenticator"&gt;
     &lt;constructor-arg ref="contextSource"/&gt;
     &lt;property name="userDnPatterns"&gt;
       &lt;list&gt;&lt;value&gt;uid={0},ou=people&lt;/value&gt;&lt;/list&gt;
     &lt;/property&gt;
   &lt;/bean&gt;
 &lt;/constructor-arg&gt;
 &lt;constructor-arg&gt;
   &lt;bean
     class="org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator"&gt;
     &lt;constructor-arg ref="contextSource"/&gt;
     &lt;constructor-arg value="ou=groups"/&gt;
     &lt;property name="groupRoleAttribute" value="ou"/&gt;
   &lt;/bean&gt;
 &lt;/constructor-arg&gt;
&lt;/bean&gt;
                </pre><p> This would set up the provider to access an LDAP server
                with URL <code class="literal">ldap://monkeymachine:389/dc=springframework,dc=org</code>.
                Authentication will be performed by attempting to bind with the DN
                    <code class="literal">uid=&lt;user-login-name&gt;,ou=people,dc=springframework,dc=org</code>.
                After successful authentication, roles will be assigned to the user by searching
                under the DN <code class="literal">ou=groups,dc=springframework,dc=org</code> with the default
                filter <code class="literal">(member=&lt;user's-DN&gt;)</code>. The role name will be taken
                from the <span class="quote">&#8220;<span class="quote">ou</span>&#8221;</span> attribute of each match.</p>
            <p>To configure a user search object, which uses the filter
                    <code class="literal">(uid=&lt;user-login-name&gt;)</code> for use instead of the
                DN-pattern (or in addition to it), you would configure the following bean </p><pre class="programlisting">
&lt;bean id="userSearch"
    class="org.springframework.security.ldap.search.FilterBasedLdapUserSearch"&gt;
  &lt;constructor-arg index="0" value=""/&gt;
  &lt;constructor-arg index="1" value="(uid={0})"/&gt;
  &lt;constructor-arg index="2" ref="contextSource" /&gt;
&lt;/bean&gt; 
                </pre><p> and use it by setting the
                    <code class="classname">BindAuthenticator</code> bean's <span class="property">userSearch</span>
                property. The authenticator would then call the search object to obtain the correct
                user's DN before attempting to bind as this user.</p>
        </div>
        <div class="section" title="18.4.6&nbsp;LDAP Attributes and Customized UserDetails"><div class="titlepage"><div><div><h3 class="title"><a name="ldap-custom-user-details"></a>18.4.6&nbsp;LDAP Attributes and Customized UserDetails</h3></div></div></div>
            
            <p> The net result of an authentication using
                    <code class="classname">LdapAuthenticationProvider</code> is the same as a normal Spring
                Security authentication using the standard
                    <code class="interfacename">UserDetailsService</code> interface. A
                    <code class="interfacename">UserDetails</code> object is created and stored in the
                returned <code class="interfacename">Authentication</code> object. As with using a
                    <code class="interfacename">UserDetailsService</code>, a common requirement is to be
                able to customize this implementation and add extra properties. When using LDAP,
                these will normally be attributes from the user entry. The creation of the
                    <code class="interfacename">UserDetails</code> object is controlled by the
                provider's <code class="interfacename">UserDetailsContextMapper</code> strategy, which
                is responsible for mapping user objects to and from LDAP context data: </p><pre class="programlisting">
public interface UserDetailsContextMapper {
  UserDetails mapUserFromContext(DirContextOperations ctx, String username,
          Collection&lt;GrantedAuthority&gt; authorities);

  void mapUserToContext(UserDetails user, DirContextAdapter ctx);
}
                </pre><p> Only the first method is relevant for
                authentication. If you provide an implementation of this interface, you can control
                exactly how the UserDetails object is created. The first parameter is an instance of
                Spring LDAP's <code class="interfacename">DirContextOperations</code> which gives you
                access to the LDAP attributes which were loaded. The <code class="literal">username</code>
                parameter is the name used to authenticate and the final parameter is the collection
                of authorities loaded for the user. </p>
            <p> The way the context data is loaded varies slightly depending on the type of
                authentication you are using. With the <code class="classname">BindAuthenticator</code>,
                the context returned from the bind operation will be used to read the attributes,
                otherwise the data will be read using the standard context obtained from the
                configured <code class="interfacename">ContextSource</code> (when a search is configured
                to locate the user, this will be the data returned by the search object). </p>
        </div>
    </div>
</div>
    <div class="chapter" title="19.&nbsp;JSP Tag Libraries"><div class="titlepage"><div><div><h2 class="title"><a name="taglibs"></a>19.&nbsp;JSP Tag Libraries</h2></div></div></div>
    
    <p> Spring Security has its own taglib which provides basic support for accessing security
        information and applying security constraints in JSPs. </p>
    <div class="section" title="19.1&nbsp;Declaring the Taglib"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e2705"></a>19.1&nbsp;Declaring the Taglib</h2></div></div></div>
        
        <p>To use any of the tags, you must have the security taglib declared in your JSP:
            </p><pre class="programlisting">
    &lt;%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags" %&gt;
</pre>
    </div>
    <div class="section" title="19.2&nbsp;The authorize Tag"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e2709"></a>19.2&nbsp;The <code class="literal">authorize</code> Tag</h2></div></div></div>
        
        <p> This tag is used to determine whether its contents should be evaluated or not. In
            Spring Security 3.0, it can be used in two ways <sup>[<a name="d4e2713" href="#ftn.d4e2713" class="footnote">14</a>]</sup>. The first approach uses a <a class="ulink" href="#el-access-web" target="_top">web-security
                expression</a>, specified in the <code class="literal">access</code> attribute of the tag.
            The expression evaluation will be delegated to the
                <code class="interfacename">WebSecurityExpressionHandler</code> defined in the
            application context (you should have web expressions enabled in your
                <code class="literal">&lt;http&gt;</code> namespace configuration to make sure this service is
            available). So, for example, you might
            have</p><pre class="programlisting">&lt;sec:authorize access="hasRole('supervisor')"&gt;

This content will only be visible to users who have
the "supervisor" authority in their list of &lt;tt&gt;GrantedAuthority&lt;/tt&gt;s.

&lt;/sec:authorize&gt;</pre>
        <p>A common requirement is to only show a particular link, if the user is actually
            allowed to click it. How can we determine in advance whether something will be allowed?
            This tag can also operate in an alternative mode which allows you to define a particular
            URL as an attribute. If the user is allowed to invoke that URL, then the tag body will
            be evaluated, otherwise it will be skipped. So you might have something
            like</p><pre class="programlisting">&lt;sec:authorize url="/admin"&gt;

This content will only be visible to users who are authorized to send requests to the "/admin" URL.

&lt;/sec:authorize&gt;</pre><p>To
            use this tag there must also be an instance of
                <code class="interfacename">WebInvocationPrivilegeEvaluator</code> in your application
            context. If you are using the namespace, one will automatically be registered. This is
            an instance of <code class="classname">DefaultWebInvocationPrivilegeEvaluator</code>, which
            creates a dummy web request for the supplied URL and invokes the security interceptor to
            see whether the request would succeed or fail. This allows you to delegate to the
            access-control setup you defined using <code class="literal">intercept-url</code> declarations
            within the <code class="literal">&lt;http&gt;</code> namespace configuration and saves having to
            duplicate the information (such as the required roles) within your JSPs. This approach
            can also be combined with a <code class="literal">method</code> attribute, supplying the HTTP
            method, for a more specific match.</p>
    </div>
    <div class="section" title="19.3&nbsp;The authenticationTag"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e2727"></a>19.3&nbsp;The <code class="literal">authentication</code>Tag</h2></div></div></div>
        
        <p>This tag allows access to the current <code class="interfacename">Authentication</code>
            object stored in the security context. It renders a property of the object directly in
            the JSP. So, for example, if the <code class="literal">principal</code> property of the
                <code class="interfacename">Authentication</code> is an instance of Spring Security's
                <code class="interfacename">UserDetails</code> object, then using
                <code class="literal">&lt;sec:authentication property="principal.username" /&gt;</code> will
            render the name of the current user.</p>
        <p>Of course, it isn't necessary to use JSP tags for this kind of thing and some people
            prefer to keep as little logic as possible in the view. You can access the
                <code class="interfacename">Authentication</code> object in your MVC controller (by
            calling <code class="code">SecurityContextHolder.getContext().getAuthentication()</code>) and add the
            data directly to your model for rendering by the view.</p>
    </div>
    <div class="section" title="19.4&nbsp;The accesscontrollist Tag"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e2739"></a>19.4&nbsp;The <code class="literal">accesscontrollist</code> Tag</h2></div></div></div>
        
        <p>This tag is only valid when used with Spring Security's ACL module. It checks a
            comma-separated list of required permissions for a specified domain object. If the
            current user has any of those permissions, then the tag body will be evaluated. If they
            don't, it will be skipped. An example might
            be</p><pre class="programlisting">&lt;sec:accesscontrollist hasPermission="1,2" domainObject="someObject"&gt;

This will be shown if the user has either of the permissions 
represented by the values "1" or "2" on the given object.

&lt;/sec:accesscontrollist&gt;</pre>
        <p>The permissions are passed to the <code class="interfacename">PermissionFactory</code>
            defined in the application context, converting them to ACL
                <code class="interfacename">Permission</code> instances, so they may be any format which
            is supported by the factory - they don't have to be integers, they could be strings like
                <code class="literal">READ</code> or <code class="literal">WRITE</code>. If no
                <code class="interfacename">PermissionFactory</code> is found, an instance of
                <code class="classname">DefaultPermissionFactory</code> will be used. The
                <code class="interfacename">AclService</code>from the application context will be used
            to load the <code class="interfacename">Acl</code> instance for the supplied object. The
                <code class="interfacename">Acl</code> will be invoked with the required permissions to
            check if any of them are granted.</p>
    </div>
<div class="footnotes"><br><hr width="100" align="left"><div class="footnote">
                <p><sup>[<a name="ftn.d4e2713" href="#d4e2713" class="para">14</a>] </sup>The legacy options from Spring Security 2.0 are also supported, but
                    discouraged.</p>
            </div></div></div>
    <div class="chapter" title="20.&nbsp;Java Authentication and Authorization Service (JAAS) Provider"><div class="titlepage"><div><div><h2 class="title"><a name="jaas"></a>20.&nbsp;Java Authentication and Authorization Service (JAAS) Provider</h2></div></div></div>
    

    <div class="section" title="20.1&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jaas-overview"></a>20.1&nbsp;Overview</h2></div></div></div>
        
        <p>Spring Security provides a package able to delegate
            authentication requests to the Java Authentication and Authorization
            Service (JAAS). This package is discussed in detail below.</p>

        <p>Central to JAAS operation are login configuration files. To
            learn more about JAAS login configuration files, consult the JAAS
            reference documentation available from Sun Microsystems. We expect you
            to have a basic understanding of JAAS and its login configuration file
            syntax in order to understand this section.</p>
    </div>

    <div class="section" title="20.2&nbsp;Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jaas-config"></a>20.2&nbsp;Configuration</h2></div></div></div>
        
        <p>The <code class="literal">JaasAuthenticationProvider</code> attempts to
            authenticate a user&#8217;s principal and credentials through JAAS.</p>

        <p>Let&#8217;s assume we have a JAAS login configuration file,
            <code class="literal">/WEB-INF/login.conf</code>, with the following
            contents:
</p><pre class="programlisting">
JAASTest {
    sample.SampleLoginModule required;
};</pre>
        <p>Like all Spring Security beans, the
            <code class="classname">JaasAuthenticationProvider</code> is configured via the
            application context. The following definitions would correspond to the
            above JAAS login configuration file:
</p><pre class="programlisting">
&lt;bean id="jaasAuthenticationProvider"
   class="org.springframework.security.authentication.jaas.JaasAuthenticationProvider"&gt;
 &lt;property name="loginConfig" value="/WEB-INF/login.conf"/&gt;
 &lt;property name="loginContextName" value="JAASTest"/&gt;
 &lt;property name="callbackHandlers"&gt;
  &lt;list&gt;
   &lt;bean
     class="org.springframework.security.authentication.jaas.JaasNameCallbackHandler"/&gt;
   &lt;bean
     class="org.springframework.security.authentication.jaas.JaasPasswordCallbackHandler"/&gt;
  &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="authorityGranters"&gt;
    &lt;list&gt;
      &lt;bean class="org.springframework.security.authentication.jaas.TestAuthorityGranter"/&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;
</pre>

        <p>The <code class="literal">CallbackHandler</code>s and
            <code class="interfacename">AuthorityGranter</code>s are discussed below.</p>

        <div class="section" title="20.2.1&nbsp;JAAS CallbackHandler"><div class="titlepage"><div><div><h3 class="title"><a name="jaas-callbackhandler"></a>20.2.1&nbsp;JAAS CallbackHandler</h3></div></div></div>
            

            <p>Most JAAS <code class="literal">LoginModule</code>s require a callback
                of some sort. These callbacks are usually used to obtain the
                username and password from the user.</p>

            <p>In a Spring Security deployment, Spring Security is
                responsible for this user interaction (via the authentication
                mechanism). Thus, by the time the authentication request is
                delegated through to JAAS, Spring Security's authentication
                mechanism will already have fully-populated an
                <code class="interfacename">Authentication</code> object containing all the
                information required by the JAAS
                <code class="literal">LoginModule</code>.</p>

            <p>Therefore, the JAAS package for Spring Security provides two
                default callback handlers,
                <code class="literal">JaasNameCallbackHandler</code> and
                <code class="literal">JaasPasswordCallbackHandler</code>. Each of these
                callback handlers implement
                <code class="literal">JaasAuthenticationCallbackHandler</code>. In most cases
                these callback handlers can simply be used without understanding the
                internal mechanics.</p>

            <p>For those needing full control over the callback behavior,
                internally <code class="literal">JaasAuthenticationProvider</code> wraps these
                <code class="literal">JaasAuthenticationCallbackHandler</code>s with an
                <code class="literal">InternalCallbackHandler</code>. The
                <code class="literal">InternalCallbackHandler</code> is the class that
                actually implements JAAS&#8217; normal <code class="literal">CallbackHandler</code>
                interface. Any time that the JAAS <code class="literal">LoginModule</code> is
                used, it is passed a list of application context configured
                <code class="literal">InternalCallbackHandler</code>s. If the
                <code class="literal">LoginModule</code> requests a callback against the
                <code class="literal">InternalCallbackHandler</code>s, the callback is in-turn
                passed to the <code class="literal">JaasAuthenticationCallbackHandler</code>s
                being wrapped.</p>
        </div>

        <div class="section" title="20.2.2&nbsp;JAAS AuthorityGranter"><div class="titlepage"><div><div><h3 class="title"><a name="jaas-authoritygranter"></a>20.2.2&nbsp;JAAS AuthorityGranter</h3></div></div></div>
            

            <p>JAAS works with principals. Even "roles" are represented as
                principals in JAAS. Spring Security, on the other hand, works with
                <code class="interfacename">Authentication</code> objects. Each
                <code class="interfacename">Authentication</code> object contains a single
                principal, and multiple <code class="interfacename">GrantedAuthority</code>[]s. To
                facilitate mapping between these different concepts, Spring
                Security's JAAS package includes an
                <code class="literal">AuthorityGranter</code> interface.</p>

            <p>An <code class="literal">AuthorityGranter</code> is responsible for
                inspecting a JAAS principal and returning a set of
                <code class="literal">String</code>s, representing the authorities assigned to the principal.
                For each returned authority string, the
                <code class="classname">JaasAuthenticationProvider</code> creates a
                <code class="classname">JaasGrantedAuthority</code> (which implements Spring
                Security&#8217;s <code class="interfacename">GrantedAuthority</code> interface) containing
                the authority string and the JAAS principal that the
                <code class="interfacename">AuthorityGranter</code> was passed. The
                <code class="classname">JaasAuthenticationProvider</code> obtains the JAAS
                principals by firstly successfully authenticating the user&#8217;s
                credentials using the JAAS <code class="literal">LoginModule</code>, and then
                accessing the <code class="literal">LoginContext</code> it returns. A call to
                <code class="literal">LoginContext.getSubject().getPrincipals()</code> is
                made, with each resulting principal passed to each
                <code class="interfacename">AuthorityGranter</code> defined against the
                <code class="literal">JaasAuthenticationProvider.setAuthorityGranters(List)</code>
                property.</p>

            <p>Spring Security does not include any production
                <code class="interfacename">AuthorityGranter</code>s given that every JAAS principal
                has an implementation-specific meaning. However, there is a
                <code class="literal">TestAuthorityGranter</code> in the unit tests that
                demonstrates a simple <code class="literal">AuthorityGranter</code>
                implementation.</p>
        </div>
    </div>
</div>
    <div class="chapter" title="21.&nbsp;CAS Authentication"><div class="titlepage"><div><div><h2 class="title"><a name="cas"></a>21.&nbsp;CAS Authentication</h2></div></div></div>
  
  <div class="section" title="21.1&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cas-overview"></a>21.1&nbsp;Overview</h2></div></div></div>
    
    <p>JA-SIG produces an enterprise-wide single sign on system known as CAS. Unlike other
      initiatives, JA-SIG's Central Authentication Service is open source, widely used, simple to
      understand, platform independent, and supports proxy capabilities. Spring Security fully
      supports CAS, and provides an easy migration path from single-application deployments of
      Spring Security through to multiple-application deployments secured by an enterprise-wide CAS
      server.</p>
    <p>You can learn more about CAS at <code class="literal">http://www.ja-sig.org/cas</code>. You will
      also need to visit this site to download the CAS Server files.</p>
  </div>
  <div class="section" title="21.2&nbsp;How CAS Works"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cas-how-it-works"></a>21.2&nbsp;How CAS Works</h2></div></div></div>
    
    <p>Whilst the CAS web site contains documents that detail the architecture of CAS, we present
      the general overview again here within the context of Spring Security. Spring Security 3.0
      supports CAS 3. At the time of writing, the CAS server was at version 3.3.</p>
    <p>Somewhere in your enterprise you will need to setup a CAS server. The CAS server is simply
      a standard WAR file, so there isn't anything difficult about setting up your server. Inside
      the WAR file you will customise the login and other single sign on pages displayed to
      users.</p>
    <p>When deploying a CAS 3.3 server, you will also need to specify an
        <code class="literal">AuthenticationHandler</code> in the
        <code class="filename">deployerConfigContext.xml</code> included with CAS. The
        <code class="literal">AuthenticationHandler</code> has a simple method that returns a boolean as to
      whether a given set of Credentials is valid. Your <code class="literal">AuthenticationHandler</code>
      implementation will need to link into some type of backend authentication repository, such as
      an LDAP server or database. CAS itself includes numerous
        <code class="literal">AuthenticationHandler</code>s out of the box to assist with this. When you
      download and deploy the server war file, it is set up to successfully authenticate users who
      enter a password matching their username, which is useful for testing.</p>
    <p>Apart from the CAS server itself, the other key players are of course the secure web
      applications deployed throughout your enterprise. These web applications are known as
      "services". There are two types of services: standard services and proxy services. A proxy
      service is able to request resources from other services on behalf of the user. This will be
      explained more fully later.</p>
    
  </div>
  <div class="section" title="21.3&nbsp;Configuration of CAS Client"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cas-client"></a>21.3&nbsp;Configuration of CAS Client</h2></div></div></div>
    
    <p>The web application side of CAS is made easy due to Spring Security. It is assumed you
      already know the basics of using Spring Security, so these are not covered again below. We'll
      assume a namespace based configuration is being used and add in the CAS beans as required. </p>
    <p>You will need to add a <code class="classname">ServiceProperties</code> bean to your application
      context. This represents your CAS service:</p>
    <p>
      </p><pre class="programlisting">
  &lt;bean id="serviceProperties"
        class="org.springframework.security.cas.ServiceProperties"&gt;
    &lt;property name="service"
        value="https://localhost:8443/cas-sample/j_spring_cas_security_check"/&gt;
    &lt;property name="sendRenew" value="false"/&gt;
  &lt;/bean&gt;
    </pre><p>
    </p>
    <p>The <code class="literal">service</code> must equal a URL that will be monitored by the
        <code class="literal">CasAuthenticationFilter</code>. The <code class="literal">sendRenew</code> defaults to
      false, but should be set to true if your application is particularly sensitive. What this
      parameter does is tell the CAS login service that a single sign on login is unacceptable.
      Instead, the user will need to re-enter their username and password in order to gain access to
      the service.</p>
    <p>The following beans should be configured to commence the CAS authentication process
      (assuming you're using a namespace configuration):</p>
    <p>
      </p><pre class="programlisting">
&lt;security:http entry-point-ref="casEntryPoint"&gt;
   ...
   &lt;custom-filter position="FORM_LOGIN_FILTER" ref="myFilter" /&gt;
&lt;/security:http&gt;

&lt;bean id="casFilter"
      class="org.springframework.security.cas.web.CasAuthenticationFilter"&gt;
  &lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;/bean&gt;

&lt;bean id="casEntryPoint"
    class="org.springframework.security.cas.web.CasAuthenticationEntryPoint"&gt;
  &lt;property name="loginUrl" value="https://localhost:9443/cas/login"/&gt;
  &lt;property name="serviceProperties" ref="serviceProperties"/&gt;
&lt;/bean&gt;

    </pre><p>
    </p>
    <p> The <code class="classname">CasAuthenticationEntryPoint</code> should be selected to drive
      authentication using <a class="ulink" href="#ns-entry-point-ref" target="_top"><code class="literal">entry-point-ref</code></a>. </p>
    <p>The <code class="classname">CasAuthenticationFilter</code> has very similar properties to the
        <code class="classname">UsernamePasswordAuthenticationFilter</code> (used for form-based logins).
    </p>
    <p>For CAS to operate, the <code class="classname">ExceptionTranslationFilter</code> must have its
        <code class="literal">authenticationEntryPoint</code> property set to the
        <code class="classname">CasAuthenticationEntryPoint</code> bean.</p>
    <p>The <code class="classname">CasAuthenticationEntryPoint</code> must refer to the
        <code class="classname">ServiceProperties</code> bean (discussed above), which provides the URL to the
      enterprise's CAS login server. This is where the user's browser will be redirected.</p>
    <p>Next you need to add a <code class="literal">CasAuthenticationProvider</code> and its collaborators: </p><pre class="programlisting">
  &lt;security:authentication-manager alias="authenticationManager"&gt;
    &lt;security:authentication-provider ref="casAuthenticationProvider" /&gt;
  &lt;/security:authentication-manager&gt;

  &lt;bean id="casAuthenticationProvider"
      class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt;
    &lt;property name="userDetailsService" ref="userService"/&gt;
    &lt;property name="serviceProperties" ref="serviceProperties" /&gt;
    &lt;property name="ticketValidator"&gt;
      &lt;bean class="org.jasig.cas.client.validation.Cas20ServiceTicketValidator"&gt;
        &lt;constructor-arg index="0" value="https://localhost:9443/cas" /&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="key" value="an_id_for_this_auth_provider_only"/&gt;
  &lt;/bean&gt;

  &lt;security:user-service id="userService"&gt;
    &lt;security:user name="joe" password="joe" authorities="ROLE_USER" /&gt;
    ...
  &lt;/security:user-service&gt;
      </pre><p> The
        <code class="classname">CasAuthenticationProvider</code> uses a
        <code class="interfacename">UserDetailsService</code> instance to load the authorities for a
      user, once they have been authentiated by CAS. We've shown a simple in-memory setup here. </p>
    <p>The beans are all reasonable self-explanatory if you refer back to the "How CAS Works"
      section.</p>
  </div>
  
</div>
    <div class="chapter" title="22.&nbsp;X.509 Authentication"><div class="titlepage"><div><div><h2 class="title"><a name="x509"></a>22.&nbsp;X.509 Authentication</h2></div></div></div>
    

    <div class="section" title="22.1&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="x509-overview"></a>22.1&nbsp;Overview</h2></div></div></div>

        <p>The most common use of X.509 certificate authentication is in verifying the identity
            of a server when using SSL, most commonly when using HTTPS from a browser. The browser
            will automatically check that the certificate presented by a server has been issued (ie
            digitally signed) by one of a list of trusted certificate authorities which it
            maintains.</p>
        <p>You can also use SSL with <span class="quote">&#8220;<span class="quote">mutual authentication</span>&#8221;</span>; the server will then
            request a valid certificate from the client as part of the SSL handshake. The server
            will authenticate the client by checking that its certificate is signed by an
            acceptable authority. If a valid certificate has been provided, it can be obtained
            through the servlet API in an application. Spring Security X.509 module extracts the
            certificate using a filter. It maps the certificate to an application user and loads that
            user's set of granted authorities for use with the standard Spring Security infrastructure.</p>
        <p>You should be familiar with using certificates and setting up client authentication
            for your servlet container before attempting to use it with Spring Security. Most of the
            work is in creating and installing suitable certificates and keys. For example, if
            you're using Tomcat then read the instructions here <code class="uri"><a class="uri" href="http://tomcat.apache.org/tomcat-6.0-doc/ssl-howto.html" target="_top">http://tomcat.apache.org/tomcat-6.0-doc/ssl-howto.html</a></code>. It's important that
            you get this working before trying it out with Spring Security</p>
    </div>
    <div class="section" title="22.2&nbsp;Adding X.509 Authentication to Your Web Application"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e2898"></a>22.2&nbsp;Adding X.509 Authentication to Your Web Application</h2></div></div></div>

        <p> Enabling X.509 client authentication is very straightforward. Just add the <code class="literal">&lt;x509/&gt;</code> element to your http security namespace configuration. </p><pre class="programlisting">
&lt;http&gt;
 ...
    &lt;x509 subject-principal-regex="CN=(.*?)," user-service-ref="userService"/&gt;
 ...
&lt;/http&gt;
            </pre><p> The element has two optional attributes: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                    <p><code class="literal">subject-principal-regex</code>. The regular expression used to
                        extract a username from the certificate's subject name. The default value is
                        shown above. This is the username which will be passed to the <code class="interfacename">UserDetailsService</code> to load the authorities for the
                    user.</p>
                </li><li class="listitem">
                    <p><code class="literal">user-service-ref</code>. This is the bean Id of the
                            <code class="interfacename">UserDetailsService</code> to be used with X.509.
                        It isn't needed if there is only one defined in your application
                    context.</p>
                </li></ul></div><p> The <code class="literal">subject-principal-regex</code> should contain a single
            group. For example the default expression "CN=(.*?)," matches the common name field. So
            if the subject name in the certificate is "CN=Jimi Hendrix, OU=...", this will give a
            user name of "Jimi Hendrix". The matches are case insensitive. So "emailAddress=(.?),"
            will match "EMAILADDRESS=jimi@hendrix.org,CN=..." giving a user name "jimi@hendrix.org".
            If the client presents a certificate and a valid username is successfully extracted,
            then there should be a valid <code class="classname">Authentication</code> object in the
            security context. If no certificate is found, or no corresponding user could be found
            then the security context will remain empty. This means that you can easily use X.509
            authentication with other options such as a form-based login. </p>
    </div>
    <div class="section" title="22.3&nbsp;Setting up SSL in Tomcat"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="x509-ssl-config"></a>22.3&nbsp;Setting up SSL in Tomcat</h2></div></div></div>
        

        <p>There are some pre-generated certificates in the
            <code class="filename">samples/certificate</code> directory in the Spring Security project.
            You can use these to enable SSL for testing if you don't want to generate your own. The file
                <code class="filename">server.jks</code> contains the server certificate, private key and the
            issuing certificate authority certificate. There are also some client certificate files
            for the users from the sample applications. You can install these in your browser to enable
            SSL client authentication.
        </p>
        <p>
            To run tomcat with SSL support, drop the <code class="filename">server.jks</code> file into the
            tomcat <code class="filename">conf</code> directory and add the following connector to the
            <code class="filename">server.xml</code> file
                </p><pre class="programlisting">
&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true" scheme="https" secure="true"
            clientAuth="true" sslProtocol="TLS"
            keystoreFile="${catalina.home}/conf/server.jks"
            keystoreType="JKS" keystorePass="password"
            truststoreFile="${catalina.home}/conf/server.jks"
            truststoreType="JKS" truststorePass="password"
/&gt;
                </pre><p>
            <em class="parameter"><code>clientAuth</code></em> can also be set to <em class="parameter"><code>want</code></em> if you still
            want SSL connections to succeed even if the client doesn't provide a certificate.
            Clients which don't present a certificate won't be able to access any objects secured by
            Spring Security unless you use a non-X.509 authentication mechanism, such as form authentication.
        </p>
    </div>
</div>
    <div class="chapter" title="23.&nbsp;Run-As Authentication Replacement"><div class="titlepage"><div><div><h2 class="title"><a name="runas"></a>23.&nbsp;Run-As Authentication Replacement</h2></div></div></div>


    <div class="section" title="23.1&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="runas-overview"></a>23.1&nbsp;Overview</h2></div></div></div>
        

        <p>The <code class="classname">AbstractSecurityInterceptor</code> is able to
            temporarily replace the <code class="interfacename">Authentication</code> object in
            the <code class="interfacename">SecurityContext</code> and
            <code class="classname">SecurityContextHolder</code> during the secure object
            callback phase. This only occurs if the original
            <code class="interfacename">Authentication</code> object was successfully processed by
            the <code class="interfacename">AuthenticationManager</code> and
            <code class="interfacename">AccessDecisionManager</code>. The
            <code class="literal">RunAsManager</code> will indicate the replacement
            <code class="interfacename">Authentication</code> object, if any, that should be used
            during the <code class="literal">SecurityInterceptorCallback</code>.</p>

        <p>By temporarily replacing the <code class="interfacename">Authentication</code>
            object during the secure object callback phase, the secured invocation
            will be able to call other objects which require different
            authentication and authorization credentials. It will also be able to
            perform any internal security checks for specific
            <code class="interfacename">GrantedAuthority</code> objects. Because Spring Security
            provides a number of helper classes that automatically configure
            remoting protocols based on the contents of the
            <code class="classname">SecurityContextHolder</code>, these run-as replacements
            are particularly useful when calling remote web services</p>
    </div>

    <div class="section" title="23.2&nbsp;Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="runas-config"></a>23.2&nbsp;Configuration</h2></div></div></div>
        
        <p>A <code class="literal">RunAsManager</code> interface is provided by Spring Security:
            </p><pre class="programlisting">
  Authentication buildRunAs(Authentication authentication, Object object,
      List&lt;ConfigAttribute&gt; config);
  boolean supports(ConfigAttribute attribute);
  boolean supports(Class clazz);
            </pre><p>
        </p>

        <p>The first method returns the <code class="interfacename">Authentication</code>
            object that should replace the existing
            <code class="interfacename">Authentication</code> object for the duration of the
            method invocation. If the method returns <code class="literal">null</code>, it
            indicates no replacement should be made. The second method is used by
            the <code class="classname">AbstractSecurityInterceptor</code> as part of its
            startup validation of configuration attributes. The
            <code class="literal">supports(Class)</code> method is called by a security
            interceptor implementation to ensure the configured
            <code class="literal">RunAsManager</code> supports the type of secure object
            that the security interceptor will present.</p>

        <p>One concrete implementation of a <code class="literal">RunAsManager</code>
            is provided with Spring Security. The
            <code class="literal">RunAsManagerImpl</code> class returns a replacement
            <code class="literal">RunAsUserToken</code> if any
            <code class="literal">ConfigAttribute</code> starts with
            <code class="literal">RUN_AS_</code>. If any such
            <code class="literal">ConfigAttribute</code> is found, the replacement
            <code class="literal">RunAsUserToken</code> will contain the same principal,
            credentials and granted authorities as the original
            <code class="interfacename">Authentication</code> object, along with a new
            <code class="literal">GrantedAuthorityImpl</code> for each
            <code class="literal">RUN_AS_</code> <code class="literal">ConfigAttribute</code>. Each
            new <code class="literal">GrantedAuthorityImpl</code> will be prefixed with
            <code class="literal">ROLE_</code>, followed by the <code class="literal">RUN_AS</code>
            <code class="literal">ConfigAttribute</code>. For example, a
            <code class="literal">RUN_AS_SERVER</code> will result in the replacement
            <code class="literal">RunAsUserToken</code> containing a
            <code class="literal">ROLE_RUN_AS_SERVER</code> granted authority.</p>

        <p>The replacement <code class="literal">RunAsUserToken</code> is just like
            any other <code class="interfacename">Authentication</code> object. It needs to be
            authenticated by the <code class="interfacename">AuthenticationManager</code>,
            probably via delegation to a suitable
            <code class="classname">AuthenticationProvider</code>. The
            <code class="literal">RunAsImplAuthenticationProvider</code> performs such
            authentication. It simply accepts as valid any
            <code class="literal">RunAsUserToken</code> presented.</p>

        <p>To ensure malicious code does not create a
            <code class="literal">RunAsUserToken</code> and present it for guaranteed
            acceptance by the <code class="literal">RunAsImplAuthenticationProvider</code>,
            the hash of a key is stored in all generated tokens. The
            <code class="literal">RunAsManagerImpl</code> and
            <code class="literal">RunAsImplAuthenticationProvider</code> is created in the
            bean context with the same key:
            </p><pre class="programlisting">

&lt;bean id="runAsManager"
    class="org.springframework.security.access.intercept.RunAsManagerImpl"&gt;
  &lt;property name="key" value="my_run_as_password"/&gt;
&lt;/bean&gt;

&lt;bean id="runAsAuthenticationProvider"
    class="org.springframework.security.access.intercept.RunAsImplAuthenticationProvider"&gt;
  &lt;property name="key" value="my_run_as_password"/&gt;
&lt;/bean&gt;</pre>
        <p>By using the same key, each <code class="literal">RunAsUserToken</code>
            can be validated it was created by an approved
            <code class="literal">RunAsManagerImpl</code>. The
            <code class="literal">RunAsUserToken</code> is immutable after creation for
            security reasons</p>
    </div>
</div>
  </div>
  <div class="appendix" title="Appendix&nbsp;A.&nbsp;Security Database Schema"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-schema"></a>Appendix&nbsp;A.&nbsp;Security Database Schema</h2></div></div></div>
  
  <p> There are various database schema used by the framework and this appendix provides a single
    reference point to them all. You only need to provide the tables for the areas of functonality
    you require. </p>
  <p> DDL statements are given for the HSQLDB database. You can use these as a guideline for
    defining the schema for the database you are using. </p>
  <div class="section" title="A.1&nbsp;User Schema"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e3009"></a>A.1&nbsp;User Schema</h2></div></div></div>
    
    <p> The standard JDBC implementation of the <code class="interfacename">UserDetailsService</code>
        (<code class="classname">JdbcDaoImpl</code>) requires tables to load the password, account status
      (enabled or disabled) and a list of authorities (roles) for the user.
      <a name="db_schema_users_authorities"></a></p><pre class="programlisting">
  create table users(
      username varchar_ignorecase(50) not null primary key,
      password varchar_ignorecase(50) not null,
      enabled boolean not null);

  create table authorities (
      username varchar_ignorecase(50) not null,
      authority varchar_ignorecase(50) not null,
      constraint fk_authorities_users foreign key(username) references users(username));
      create unique index ix_auth_username on authorities (username,authority);
</pre>
    <div class="section" title="A.1.1&nbsp;Group Authorities"><div class="titlepage"><div><div><h3 class="title"><a name="d4e3015"></a>A.1.1&nbsp;Group Authorities</h3></div></div></div>
      
      <p> Spring Security 2.0 introduced support for group authorities in
          <code class="classname">JdbcDaoImpl</code>. The table structure if groups are enabled is as
        follows:<a name="db-schema-groups"></a></p><pre class="programlisting">
create table groups (
  id bigint generated by default as identity(start with 0) primary key,
  group_name varchar_ignorecase(50) not null);

create table group_authorities (
  group_id bigint not null,
  authority varchar(50) not null,
  constraint fk_group_authorities_group foreign key(group_id) references groups(id));

create table group_members (
  id bigint generated by default as identity(start with 0) primary key,
  username varchar(50) not null,
  group_id bigint not null,
  constraint fk_group_members_group foreign key(group_id) references groups(id));
        </pre>
    </div>
  </div>
  <div class="section" title="A.2&nbsp;Persistent Login (Remember-Me) Schema"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e3020"></a>A.2&nbsp;Persistent Login (Remember-Me) Schema</h2></div></div></div>
    
    <p> This table is used to store data used by the more secure <a class="ulink" href="#remember-me-persistent-token" target="_top">persistent token</a> remember-me
      implementation. If you are using <code class="classname">JdbcTokenRepositoryImpl</code> either
      directly or through the namespace, then you will need this table.
      <a name="db-schema-remeber-me"></a></p><pre class="programlisting">
create table persistent_logins (
  username varchar(64) not null,
  series varchar(64) primary key,
  token varchar(64) not null,
  last_used timestamp not null);
</pre>
  </div>
  <div class="section" title="A.3&nbsp;ACL Schema"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dbschema-acl"></a>A.3&nbsp;ACL Schema</h2></div></div></div>
    
    <p>There are four tables used by the Spring Security <a class="ulink" href="#domain-acls" target="_top">ACL</a> implementation. </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
          <p><code class="literal">acl_sid</code> stores the security identities recognised by the ACL
            system. These can be unique principals or authorities which may apply to multiple
            principals.</p>
        </li><li class="listitem">
          <p><code class="literal">acl_class</code> defines the domain object types to which ACLs apply.
            The <code class="literal">class</code> column stores the Java class name of the object. </p>
        </li><li class="listitem">
          <p><code class="literal">acl_object_identity</code> stores the object identity definitions of
            specific domai objects.</p>
        </li><li class="listitem">
          <p><code class="literal">acl_entry</code> stores the ACL permissions which apply to a specific
            object identity and security identity.</p>
        </li></ol></div>
    <p>It is assumed that the database will auto-generate the primary keys for each of the
      identities. The <code class="literal">JdbcMutableAclService</code> has to be able to retrieve these when
      it has created a new row in the <code class="literal">acl_sid</code> or <code class="literal">acl_class</code>
      tables. It has two properties which define the SQL needed to retrieve these values
        <code class="literal">classIdentityQuery</code> and <code class="literal">sidIdentityQuery</code>. Both of these
      default to <code class="literal">call identity()</code></p>
    <div class="section" title="A.3.1&nbsp;Hypersonic SQL"><div class="titlepage"><div><div><h3 class="title"><a name="d4e3051"></a>A.3.1&nbsp;Hypersonic SQL</h3></div></div></div>
      
      <p>The default schema works with the embedded HSQLDB database that is used in unit tests
        within the
        framework.<a name="dbschema-acl-hsql"></a></p><pre class="programlisting">
create table acl_sid (
  id bigint generated by default as identity(start with 100) not null primary key,
  principal boolean not null,
  sid varchar_ignorecase(100) not null,
  constraint unique_uk_1 unique(sid,principal) );

create table acl_class (
  id bigint generated by default as identity(start with 100) not null primary key,
  class varchar_ignorecase(100) not null,
  constraint unique_uk_2 unique(class) );

create table acl_object_identity (
  id bigint generated by default as identity(start with 100) not null primary key,
  object_id_class bigint not null,
  object_id_identity bigint not null,
  parent_object bigint,
  owner_sid bigint not null,
  entries_inheriting boolean not null,
  constraint unique_uk_3 unique(object_id_class,object_id_identity),
  constraint foreign_fk_1 foreign key(parent_object)references acl_object_identity(id),
  constraint foreign_fk_2 foreign key(object_id_class)references acl_class(id),
  constraint foreign_fk_3 foreign key(owner_sid)references acl_sid(id) );

create table acl_entry (
  id bigint generated by default as identity(start with 100) not null primary key,
  acl_object_identity bigint not null,ace_order int not null,sid bigint not null,
  mask integer not null,granting boolean not null,audit_success boolean not null,
  audit_failure boolean not null,
  constraint unique_uk_4 unique(acl_object_identity,ace_order),
  constraint foreign_fk_4 foreign key(acl_object_identity)
      references acl_object_identity(id),
  constraint foreign_fk_5 foreign key(sid) references acl_sid(id) );

</pre>
      <div class="section" title="PostgreSQL"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3055"></a>PostgreSQL</h4></div></div></div>
        
        <p>
          </p><pre class="programlisting">create table acl_sid(
  id bigserial not null primary key,
  principal boolean not null,
  sid varchar(100) not null,
  constraint unique_uk_1 unique(sid,principal));

create table acl_class(
  id bigserial not null primary key,
  class varchar(100) not null,
  constraint unique_uk_2 unique(class));

create table acl_object_identity(
  id bigserial primary key,
  object_id_class bigint not null,
  object_id_identity bigint not null,
  parent_object bigint,
  owner_sid bigint,
  entries_inheriting boolean not null,
  constraint unique_uk_3 unique(object_id_class,object_id_identity),
  constraint foreign_fk_1 foreign key(parent_object) references acl_object_identity(id),
  constraint foreign_fk_2 foreign key(object_id_class) references acl_class(id),
  constraint foreign_fk_3 foreign key(owner_sid) references acl_sid(id));

create table acl_entry(
  id bigserial primary key,
  acl_object_identity bigint not null,
  ace_order int not null,
  sid bigint not null,
  mask integer not null,
  granting boolean not null,
  audit_success boolean not null,
  audit_failure boolean not null,
  constraint unique_uk_4 unique(acl_object_identity,ace_order),
  constraint foreign_fk_4 foreign key(acl_object_identity)
      references acl_object_identity(id),
  constraint foreign_fk_5 foreign key(sid) references acl_sid(id));
</pre><p>
        </p>
        <p>You will have to set the <code class="literal">classIdentityQuery</code> and
            <code class="literal">sidIdentityQuery</code> properties of
            <code class="classname">JdbcMutableAclService</code> to the following values, respectively: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              <p><code class="literal">select currval(pg_get_serial_sequence('acl_class',
                'id'))</code></p>
            </li><li class="listitem">
              <p><code class="literal">select currval(pg_get_serial_sequence('acl_sid',
                'id'))</code></p>
            </li></ul></div>
      </div>
    </div>
  </div>
</div>
  <div class="appendix" title="Appendix&nbsp;B.&nbsp;The Security Namespace"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-namespace"></a>Appendix&nbsp;B.&nbsp;The Security Namespace</h2></div></div></div>
  
  <p> This appendix provides a reference to the elements available in the security namespace and
    information on the underlying beans they create (a knowledge of the individual classes and how
    they work together is assumed - you can find more information in the project Javadoc and
    elsewhere in this document). If you haven't used the namespace before, please read the <a class="ulink" href="#ns-config" target="_top">introductory chapter</a> on namespace configuration, as this is
    intended as a supplement to the information there. Using a good quality XML editor while editing
    a configuration based on the schema is recommended as this will provide contextual information
    on which elements and attributes are available as well as comments explaining their purpose. The
    namespace is written in <a class="ulink" href="http://www.relaxng.org/" target="_top">RELAX NG</a> Compact
    format and later converted into an XSD schema. If you are familiar with this format, you may
    wish to examine the <a class="ulink" href="https://src.springsource.org/svn/spring-security/trunk/config/src/main/resources/org/springframework/security/config/spring-security-3.0.rnc" target="_top">schema file</a> directly.</p>
  <div class="section" title="B.1&nbsp;Web Application Security - the <http&gt; Element"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="nsa-http"></a>B.1&nbsp;Web Application Security - the <code class="literal">&lt;http&gt;</code> Element</h2></div></div></div>
    
    <p> The <code class="literal">&lt;http&gt;</code> element encapsulates the security configuration for
      the web layer of your application. It creates a <code class="classname">FilterChainProxy</code> bean
      named "springSecurityFilterChain" which maintains the stack of security filters which make up
      the web security configuration <sup>[<a name="d4e3084" href="#ftn.d4e3084" class="footnote">15</a>]</sup>. Some core filters are always created and others will be added to the stack
      depending on the attributes child elements which are present. The positions of the standard
      filters are fixed (see <a class="ulink" href="#filter-stack" target="_top">the filter order table</a> in the
      namespace introduction), removing a common source of errors with previous versions of the
      framework when users had to configure the filter chain explicitly in
        the<code class="classname">FilterChainProxy</code> bean. You can, of course, still do this if you
      need full control of the configuration. </p>
    <p> All filters which require a reference to the
        <code class="interfacename">AuthenticationManager</code> will be automatically injected with the
      internal instance created by the namespace configuration (see the <a class="ulink" href="#ns-auth-manager" target="_top"> introductory chapter</a> for more on the
        <code class="interfacename">AuthenticationManager</code>). </p>
    <p> The <code class="literal">&lt;http&gt;</code> namespace block always creates an
        <code class="classname">HttpSessionContextIntegrationFilter</code>, an
        <code class="classname">ExceptionTranslationFilter</code> and a
        <code class="classname">FilterSecurityInterceptor</code>. These are fixed and cannot be replaced
      with alternatives. </p>
    <div class="section" title="B.1.1&nbsp;<http&gt; Attributes"><div class="titlepage"><div><div><h3 class="title"><a name="nsa-http-attributes"></a>B.1.1&nbsp;<code class="literal">&lt;http&gt;</code> Attributes</h3></div></div></div>
      
      <p> The attributes on the <code class="literal">&lt;http&gt;</code> element control some of the
        properties on the core filters. </p>
      <div class="section" title="servlet-api-provision"><div class="titlepage"><div><div><h4 class="title"><a name="nsa-servlet-api-provision"></a><code class="literal">servlet-api-provision</code></h4></div></div></div>
        
        <p> Provides versions of <code class="literal">HttpServletRequest</code> security methods such as
            <code class="literal">isUserInRole()</code> and <code class="literal">getPrincipal()</code> which are
          implemented by adding a <code class="classname">SecurityContextHolderAwareRequestFilter</code>
          bean to the stack. Defaults to "true". </p>
      </div>
      <div class="section" title="path-type"><div class="titlepage"><div><div><h4 class="title"><a name="nsa-path-type"></a><code class="literal">path-type</code></h4></div></div></div>
        
        <p> Controls whether URL patterns are interpreted as ant paths (the default) or regular
          expressions. In practice this sets a particular <code class="interfacename">UrlMatcher</code>
          instance on the <code class="classname">FilterChainProxy</code>. </p>
      </div>
      <div class="section" title="lowercase-comparisons"><div class="titlepage"><div><div><h4 class="title"><a name="nsa-lowercase-comparisons"></a><code class="literal">lowercase-comparisons</code></h4></div></div></div>
        
        <p> Whether test URLs should be converted to lower case prior to comparing with defined
          path patterns. If unspecified, defaults to "true" </p>
      </div>
      <div class="section" title="realm"><div class="titlepage"><div><div><h4 class="title"><a name="nsa-realm"></a><code class="literal">realm</code></h4></div></div></div>
        
        <p> Sets the realm name used for basic authentication (if enabled). Corresponds to the
            <code class="literal">realmName</code> property on
            <code class="classname">BasicAuthenticationEntryPoint</code>. </p>
      </div>
      <div class="section" title="entry-point-ref"><div class="titlepage"><div><div><h4 class="title"><a name="nsa-entry-point-ref"></a><code class="literal">entry-point-ref</code></h4></div></div></div>
        
        <p> Normally the <code class="interfacename">AuthenticationEntryPoint</code> used will be set
          depending on which authentication mechanisms have been configured. This attribute allows
          this behaviour to be overridden by defining a customized
            <code class="interfacename">AuthenticationEntryPoint</code> bean which will start the
          authentication process. </p>
      </div>
      <div class="section" title="access-decision-manager-ref"><div class="titlepage"><div><div><h4 class="title"><a name="nsa-access-decision-manager-ref"></a><code class="literal">access-decision-manager-ref</code></h4></div></div></div>
        
        <p> Optional attribute specifying the ID of the
            <code class="interfacename">AccessDecisionManager</code> implementation which should be used
          for authorizing HTTP requests. By default an <code class="classname">AffirmativeBased</code>
          implementation is used for with a <code class="classname">RoleVoter</code> and an
            <code class="classname">AuthenticatedVoter</code>. </p>
      </div>
      <div class="section" title="access-denied-page"><div class="titlepage"><div><div><h4 class="title"><a name="nsa-access-denied-page"></a><code class="literal">access-denied-page</code></h4></div></div></div>
        
        <p> Deprecated in favour of the <code class="literal">access-denied-handler</code> child element.
        </p>
      </div>
      <div class="section" title="once-per-request"><div class="titlepage"><div><div><h4 class="title"><a name="nsa-once-per-request"></a><code class="literal">once-per-request</code></h4></div></div></div>
        
        <p> Corresponds to the <code class="literal">observeOncePerRequest</code> property of
            <code class="classname">FilterSecurityInterceptor</code>. Defaults to "true". </p>
      </div>
      <div class="section" title="create-session"><div class="titlepage"><div><div><h4 class="title"><a name="create-session"></a><code class="literal">create-session</code></h4></div></div></div>
        
        <p> Controls the eagerness with which an HTTP session is created. If not set, defaults to
          "ifRequired". Other options are "always" and "never". The setting of this attribute affect
          the <code class="literal">allowSessionCreation</code> and
            <code class="literal">forceEagerSessionCreation</code> properties of
            <code class="classname">HttpSessionContextIntegrationFilter</code>.
            <code class="literal">allowSessionCreation</code> will always be true unless this attribute is set
          to "never". <code class="literal">forceEagerSessionCreation</code> is "false" unless it is set to
          "always". So the default configuration allows session creation but does not force it. The
          exception is if concurrent session control is enabled, when
            <code class="literal">forceEagerSessionCreation</code> will be set to true, regardless of what the
          setting is here. Using "never" would then cause an exception during the initialization of
            <code class="classname">HttpSessionContextIntegrationFilter</code>. </p>
      </div>
    </div>
    <div class="section" title="B.1.2&nbsp;<access-denied-handler&gt;"><div class="titlepage"><div><div><h3 class="title"><a name="nsa-access-denied-handler"></a>B.1.2&nbsp;<code class="literal">&lt;access-denied-handler&gt;</code></h3></div></div></div>
      
      <p> This element allows you to set the <code class="literal">errorPage</code> property for the
        default <code class="interfacename">AccessDeniedHandler</code> used by the
          <code class="classname">ExceptionTranslationFilter</code>, (using the
          <code class="literal">error-page</code> attribute, or to supply your own implementation using the
          <code class="literal">ref</code> attribute. This is discussed in more detail in the section on <a class="ulink" href="#access-denied-handler" target="_top">the
          <code class="classname">ExceptionTranslationFilter</code></a>.</p>
    </div>
    <div class="section" title="B.1.3&nbsp;The <intercept-url&gt; Element"><div class="titlepage"><div><div><h3 class="title"><a name="d4e3175"></a>B.1.3&nbsp;The <code class="literal">&lt;intercept-url&gt;</code> Element</h3></div></div></div>
      
      <p> This element is used to define the set of URL patterns that the application is
        interested in and to configure how they should be handled. It is used to construct the
          <code class="interfacename">FilterInvocationSecurityMetadataSource</code> used by the
          <code class="classname">FilterSecurityInterceptor</code> and to exclude particular patterns from
        the filter chain entirely (by setting the attribute <code class="literal">filters="none"</code>). It
        is also responsible for configuring a <code class="classname">ChannelAuthenticationFilter</code> if
        particular URLs need to be accessed by HTTPS, for example. When matching the specified
        patterns against an incoming request, the matching is done in the order in which the
        elements are declared. So the most specific matches patterns should come first and the most
        general should come last.</p>
      <div class="section" title="pattern"><div class="titlepage"><div><div><h4 class="title"><a name="nsa-pattern"></a><code class="literal">pattern</code></h4></div></div></div>
        
        <p> The pattern which defines the URL path. The content will depend on the
            <code class="literal">path-type</code> attribute from the containing http element, so will default
          to ant path syntax. </p>
      </div>
      <div class="section" title="method"><div class="titlepage"><div><div><h4 class="title"><a name="nsa-method"></a><code class="literal">method</code></h4></div></div></div>
        
        <p> The HTTP Method which will be used in combination with the pattern to match an
          incoming request. If omitted, any method will match. If an identical pattern is specified
          with and without a method, the method-specific match will take precedence.</p>
      </div>
      <div class="section" title="access"><div class="titlepage"><div><div><h4 class="title"><a name="nsa-access"></a><code class="literal">access</code></h4></div></div></div>
        
        <p> Lists the access attributes which will be stored in the
            <code class="interfacename">FilterInvocationSecurityMetadataSource</code> for the defined URL
          pattern/method combination. This should be a comma-separated list of the security
          configuration attributes (such as role names). </p>
      </div>
      <div class="section" title="requires-channel"><div class="titlepage"><div><div><h4 class="title"><a name="nsa-requires-channel"></a><code class="literal">requires-channel</code></h4></div></div></div>
        
        <p> Can be <span class="quote">&#8220;<span class="quote">http</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">https</span>&#8221;</span> depending on whether a particular
          URL pattern should be accessed over HTTP or HTTPS respectively. Alternatively the value
            <span class="quote">&#8220;<span class="quote">any</span>&#8221;</span> can be used when there is no preference. If this attribute is present
          on any <code class="literal">&lt;intercept-url&gt;</code> element, then a
            <code class="classname">ChannelAuthenticationFilter</code> will be added to the filter stack and
          its additional dependencies added to the application
          context.</p>
        <p> If a <code class="literal">&lt;port-mappings&gt;</code> configuration is added, this will be
          used to by the <code class="classname">SecureChannelProcessor</code> and
            <code class="classname">InsecureChannelProcessor</code> beans to determine the ports used for
          redirecting to HTTP/HTTPS. </p>
      </div>
      <div class="section" title="filters"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3210"></a><code class="literal">filters</code></h4></div></div></div>
        
        <p>Can only take the value <span class="quote">&#8220;<span class="quote">none</span>&#8221;</span>. This will cause any matching request to
          bypass the Spring Security filter chain entirely. None of the rest of the
            <code class="literal">&lt;http&gt;</code> configuration will have any effect on the request and there
          will be no security context available for its duration. Access to secured methods during
          the request will fail.</p>
      </div>
    </div>
    <div class="section" title="B.1.4&nbsp;The <port-mappings&gt; Element"><div class="titlepage"><div><div><h3 class="title"><a name="d4e3216"></a>B.1.4&nbsp;The <code class="literal">&lt;port-mappings&gt;</code> Element</h3></div></div></div>
      
      <p> By default, an instance of <code class="classname">PortMapperImpl</code> will be added to the
        configuration for use in redirecting to secure and insecure URLs. This element can
        optionally be used to override the default mappings which that class defines. Each child
          <code class="literal">&lt;port-mapping&gt;</code> element defines a pair of HTTP:HTTPS ports. The
        default mappings are 80:443 and 8080:8443. An example of overriding these can be found in
        the <a class="ulink" href="#ns-requires-channel" target="_top">namespace introduction</a>. </p>
    </div>
    <div class="section" title="B.1.5&nbsp;The <form-login&gt; Element"><div class="titlepage"><div><div><h3 class="title"><a name="nsa-form-login"></a>B.1.5&nbsp;The <code class="literal">&lt;form-login&gt;</code> Element</h3></div></div></div>
      
      <p> Used to add an <code class="classname">UsernamePasswordAuthenticationFilter</code> to the
        filter stack and an <code class="classname">LoginUrlAuthenticationEntryPoint</code> to the
        application context to provide authentication on demand. This will always take precedence
        over other namespace-created entry points. If no attributes are supplied, a login page will
        be generated automatically at the URL "/spring-security-login" <sup>[<a name="d4e3229" href="#ftn.d4e3229" class="footnote">16</a>]</sup> The behaviour can be customized using the following attributes. </p>
      <div class="section" title="login-page"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3232"></a><code class="literal">login-page</code></h4></div></div></div>
        
        <p> The URL that should be used to render the login page. Maps to the
            <code class="literal">loginFormUrl</code> property of the
            <code class="classname">LoginUrlAuthenticationEntryPoint</code>. Defaults to
          "/spring-security-login". </p>
      </div>
      <div class="section" title="login-processing-url"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3238"></a><code class="literal">login-processing-url</code></h4></div></div></div>
        
        <p> Maps to the <code class="literal">filterProcessesUrl</code> property of
            <code class="classname">UsernamePasswordAuthenticationFilter</code>. The default value is
          "/j_spring_security_check". </p>
      </div>
      <div class="section" title="default-target-url"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3244"></a><code class="literal">default-target-url</code></h4></div></div></div>
        
        <p>Maps to the <code class="literal">defaultTargetUrl</code> property of
            <code class="classname">UsernamePasswordAuthenticationFilter</code>. If not set, the default
          value is "/" (the application root). A user will be taken to this URL after logging in,
          provided they were not asked to login while attempting to access a secured resource, when
          they will be taken to the originally requested URL. </p>
      </div>
      <div class="section" title="always-use-default-target"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3250"></a><code class="literal">always-use-default-target</code></h4></div></div></div>
        
        <p> If set to "true", the user will always start at the value given by
            <code class="literal">default-target-url</code>, regardless of how they arrived at the login page.
          Maps to the <code class="literal">alwaysUseDefaultTargetUrl</code> property of
            <code class="classname">UsernamePasswordAuthenticationFilter</code>. Default value is "false".
        </p>
      </div>
      <div class="section" title="authentication-failure-url"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3257"></a><code class="literal">authentication-failure-url</code></h4></div></div></div>
        
        <p> Maps to the <code class="literal">authenticationFailureUrl</code> property of
            <code class="classname">UsernamePasswordAuthenticationFilter</code>. Defines the URL the browser
          will be redirected to on login failure. Defaults to "/spring_security_login?login_error",
          which will be automatically handled by the automatic login page generator, re-rendering
          the login page with an error message. </p>
      </div>
      <div class="section" title="authentication-success-handler-ref"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3263"></a><code class="literal">authentication-success-handler-ref</code></h4></div></div></div>
        
        <p>This can be used as an alternative to <code class="literal">default-target-url</code> and
            <code class="literal">always-use-default-target</code>, giving you full control over the
          navigation flow after a successful authentication. The value should be he name of an
            <code class="interfacename">AuthenticationSuccessHandler</code> bean in the application
          context. </p>
      </div>
      <div class="section" title="authentication-failure-handler-ref"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3270"></a><code class="literal">authentication-failure-handler-ref</code></h4></div></div></div>
        
        <p>Can be used as an alternative to <code class="literal">authentication-failure-url</code>, giving
          you full control over the navigation flow after an authentication failure. The value
          should be he name of an <code class="interfacename">AuthenticationFailureHandler</code> bean
          in the application context. </p>
      </div>
    </div>
    <div class="section" title="B.1.6&nbsp;The <http-basic&gt; Element"><div class="titlepage"><div><div><h3 class="title"><a name="nsa-http-basic"></a>B.1.6&nbsp;The <code class="literal">&lt;http-basic&gt;</code> Element</h3></div></div></div>
      
      <p> Adds a <code class="classname">BasicAuthenticationFilter</code> and
          <code class="classname">BasicAuthenticationEntryPoint</code> to the configuration. The latter will
        only be used as the configuration entry point if form-based login is not enabled. </p>
    </div>
    <div class="section" title="B.1.7&nbsp;The <remember-me&gt; Element"><div class="titlepage"><div><div><h3 class="title"><a name="nsa-remember-me"></a>B.1.7&nbsp;The <code class="literal">&lt;remember-me&gt;</code> Element</h3></div></div></div>
      
      <p> Adds the <code class="classname">RememberMeAuthenticationFilter</code> to the stack. This in
        turn will be configured with either a <code class="classname">TokenBasedRememberMeServices</code>, a
          <code class="classname">PersistentTokenBasedRememberMeServices</code> or a user-specified bean
        implementing <code class="interfacename">RememberMeServices</code> depending on the attribute
        settings. </p>
      <div class="section" title="data-source-ref"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3290"></a><code class="literal">data-source-ref</code></h4></div></div></div>
        
        <p> If this is set, <code class="classname">PersistentTokenBasedRememberMeServices</code> will be
          used and configured with a <code class="classname">JdbcTokenRepositoryImpl</code> instance.
        </p>
      </div>
      <div class="section" title="token-repository-ref"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3296"></a><code class="literal">token-repository-ref</code></h4></div></div></div>
        
        <p> Configures a <code class="classname">PersistentTokenBasedRememberMeServices</code> but allows
          the use of a custom <code class="interfacename">PersistentTokenRepository</code> bean. </p>
      </div>
      <div class="section" title="services-ref"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3302"></a><code class="literal">services-ref</code></h4></div></div></div>
        
        <p> Allows complete control of the <code class="interfacename">RememberMeServices</code>
          implementation that will be used by the filter. The value should be the Id of a bean in
          the application context which implements this interface. </p>
      </div>
      <div class="section" title="token-repository-ref"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3307"></a><code class="literal">token-repository-ref</code></h4></div></div></div>
        
        <p> Configures a <code class="classname">PersistentTokenBasedRememberMeServices</code> but allows
          the use of a custom <code class="interfacename">PersistentTokenRepository</code> bean. </p>
      </div>
      <div class="section" title="The key Attribute"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3313"></a>The <code class="literal">key</code> Attribute</h4></div></div></div>
        
        <p>Maps to the "key" property of <code class="classname">AbstractRememberMeServices</code>.
          Should be set to a unique value to ensure that remember-me cookies are only valid within
          the one application <sup>[<a name="d4e3318" href="#ftn.d4e3318" class="footnote">17</a>]</sup>. </p>
      </div>
      <div class="section" title="token-validity-seconds"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3321"></a><code class="literal">token-validity-seconds</code></h4></div></div></div>
        
        <p> Maps to the <code class="literal">tokenValiditySeconds</code> property of
            <code class="classname">AbstractRememberMeServices</code>. Specifies the period in seconds for
          which the remember-me cookie should be valid. By default it will be valid for 14 days.
        </p>
      </div>
      <div class="section" title="user-service-ref"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3327"></a><code class="literal">user-service-ref</code></h4></div></div></div>
        
        <p> The remember-me services implementations require access to a
            <code class="interfacename">UserDetailsService</code>, so there has to be one defined in the
          application context. If there is only one, it will be selected and used automatically by
          the namespace configuration. If there are multiple instances, you can specify a bean Id
          explicitly using this attribute. </p>
      </div>
    </div>
    <div class="section" title="B.1.8&nbsp;The <session-management&gt; Element"><div class="titlepage"><div><div><h3 class="title"><a name="nsa-session-mgmt"></a>B.1.8&nbsp;The <code class="literal">&lt;session-management&gt;</code> Element</h3></div></div></div>
      
      <p>Session-management related functionality is implemented by the addition of a
          <code class="classname">SessionManagementFilter</code> to the filter stack.</p>
      <div class="section" title="session-fixation-protection"><div class="titlepage"><div><div><h4 class="title"><a name="session-fixation-protection"></a><code class="literal">session-fixation-protection</code></h4></div></div></div>
        
        <p> Indicates whether an existing session should be invalidated when a user authenticates
          and a new session started. If set to "none" no change will be made. "newSession" will
          create a new empty session. "migrateSession" will create a new session and copy the
          session attributes to the new session. Defaults to "migrateSession".</p>
        <p> If session fixation protection is enabled, the
            <code class="classname">SessionManagementFilter</code> is inected with a appropriately
          configured <code class="classname">DefaultSessionAuthenticationStrategy</code>. See the Javadoc
          for this class for more details. </p>
      </div>
    </div>
    <div class="section" title="B.1.9&nbsp;The <concurrency-control&gt; Element"><div class="titlepage"><div><div><h3 class="title"><a name="nsa-concurrent-session-control"></a>B.1.9&nbsp;The <code class="literal">&lt;concurrency-control&gt;</code> Element</h3></div></div></div>
      
      <p> Adds support for concurrent session control, allowing limits to be placed on the number
        of active sessions a user can have. A <code class="classname">ConcurrentSessionFilter</code> will be
        created, and a <code class="classname">ConcurrentSessionControlStrategy</code> will be used with the
          <code class="classname">SessionManagementFilter</code>. If a <code class="literal">form-login</code> element
        has been declared, the strategy object will also be injected into the created authentication
        filter. An instance of <code class="interfacename">SessionRegistry</code> (a
          <code class="classname">SessionRegistryImpl</code> instance unless the user wishes to use a custom
        bean) will be created for use by the strategy.</p>
      <div class="section" title="The max-sessions attribute"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3354"></a>The <code class="literal">max-sessions</code> attribute</h4></div></div></div>
        
        <p>Maps to the <code class="literal">maximumSessions</code> property of
            <code class="classname">ConcurrentSessionControlStrategy</code>.</p>
      </div>
      <div class="section" title="The expired-url attribute"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3360"></a>The <code class="literal">expired-url</code> attribute</h4></div></div></div>
        
        <p> The URL a user will be redirected to if they attempt to use a session which has been
          "expired" by the concurrent session controller because the user has exceeded the number of
          allowed sessions and has logged in again elsewhere. Should be set unless
            <code class="literal">exception-if-maximum-exceeded</code> is set. If no value is supplied, an
          expiry message will just be written directly back to the response. </p>
      </div>
      <div class="section" title="The error-if-maximum-exceeded attribute"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3365"></a>The <code class="literal">error-if-maximum-exceeded</code> attribute</h4></div></div></div>
        
        <p>If set to "true" a <code class="exceptionname">SessionAuthenticationException</code> will
          be raised when a user attempts to exceed the maximum allowed number of sessions. The
          default behaviour is to expire the original session. </p>
      </div>
      <div class="section" title="The session-registry-alias and session-registry-ref attributes"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3370"></a>The <code class="literal">session-registry-alias</code> and
            <code class="literal">session-registry-ref</code> attributes</h4></div></div></div>
        
        <p> The user can supply their own <code class="interfacename">SessionRegistry</code>
          implementation using the <code class="literal">session-registry-ref</code> attribute. The other
          concurrent session control beans will be wired up to use it. </p>
        <p> It can also be useful to have a reference to the internal session registry for use in
          your own beans or an admin interface. You can expose the interal bean using the
            <code class="literal">session-registry-alias</code> attribute, giving it a name that you can use
          elsewhere in your configuration. </p>
      </div>
    </div>
    <div class="section" title="B.1.10&nbsp;The <anonymous&gt; Element"><div class="titlepage"><div><div><h3 class="title"><a name="nsa-anonymous"></a>B.1.10&nbsp;The <code class="literal">&lt;anonymous&gt;</code> Element</h3></div></div></div>
      
      <p> Adds an <code class="classname">AnonymousAuthenticationFilter</code> to the stack and an
          <code class="classname">AnonymousAuthenticationProvider</code>. Required if you are using the
          <code class="literal">IS_AUTHENTICATED_ANONYMOUSLY</code> attribute. </p>
    </div>
    <div class="section" title="B.1.11&nbsp;The <x509&gt; Element"><div class="titlepage"><div><div><h3 class="title"><a name="nsa-x509"></a>B.1.11&nbsp;The <code class="literal">&lt;x509&gt;</code> Element</h3></div></div></div>
      
      <p> Adds support for X.509 authentication. An
          <code class="classname">X509AuthenticationFilter</code> will be added to the stack and an
          <code class="classname">Http403ForbiddenEntryPoint</code> bean will be created. The latter will
        only be used if no other authentication mechanisms are in use (it's only functionality is to
        return an HTTP 403 error code). A
          <code class="classname">PreAuthenticatedAuthenticationProvider</code> will also be created which
        delegates the loading of user authorities to a
          <code class="interfacename">UserDetailsService</code>. </p>
      <div class="section" title="The subject-principal-regex attribute"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3394"></a>The <code class="literal">subject-principal-regex</code> attribute</h4></div></div></div>
        
        <p> Defines a regular expression which will be used to extract the username from the
          certificate (for use with the <code class="interfacename">UserDetailsService</code>). </p>
      </div>
      <div class="section" title="The user-service-ref attribute"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3399"></a>The <code class="literal">user-service-ref</code> attribute</h4></div></div></div>
        
        <p> Allows a specific <code class="interfacename">UserDetailsService</code> to be used with
          X.509 in the case where multiple instances are configured. If not set, an attempt will be
          made to locate a suitable instance automatically and use that. </p>
      </div>
    </div>
    <div class="section" title="B.1.12&nbsp;The <openid-login&gt; Element"><div class="titlepage"><div><div><h3 class="title"><a name="nsa-openid-login"></a>B.1.12&nbsp;The <code class="literal">&lt;openid-login&gt;</code> Element</h3></div></div></div>
      
      <p> Similar to <code class="literal">&lt;form-login&gt;</code> and has the same attributes. The
        default value for <code class="literal">login-processing-url</code> is
        "/j_spring_openid_security_check". An <code class="classname">OpenIDAuthenticationFilter</code> and
          <code class="classname">OpenIDAuthenticationProvider</code> will be registered. The latter
        requires a reference to a <code class="interfacename">UserDetailsService</code>. Again, this can
        be specified by Id, using the <code class="literal">user-service-ref</code> attribute, or will be
        located automatically in the application context. </p>
    </div>
    <div class="section" title="B.1.13&nbsp;The <logout&gt; Element"><div class="titlepage"><div><div><h3 class="title"><a name="nsa-logout"></a>B.1.13&nbsp;The <code class="literal">&lt;logout&gt;</code> Element</h3></div></div></div>
      
      <p> Adds a <code class="classname">LogoutFilter</code> to the filter stack. This is configured with
        a <code class="classname">SecurityContextLogoutHandler</code>. </p>
      <div class="section" title="The logout-url attribute"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3420"></a>The <code class="literal">logout-url</code> attribute</h4></div></div></div>
        
        <p> The URL which will cause a logout (i.e. which will be processed by the filter).
          Defaults to "/j_spring_security_logout". </p>
      </div>
      <div class="section" title="The logout-success-url attribute"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3424"></a>The <code class="literal">logout-success-url</code> attribute</h4></div></div></div>
        
        <p> The destination URL which the user will be taken to after logging out. Defaults to
          "/". </p>
      </div>
      <div class="section" title="The invalidate-session attribute"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3428"></a>The <code class="literal">invalidate-session</code> attribute</h4></div></div></div>
        
        <p> Maps to the <code class="literal">invalidateHttpSession</code> of the
            <code class="classname">SecurityContextLogoutHandler</code>. Defaults to "true", so the session
          will be invalidated on logout. </p>
      </div>
    </div>
    <div class="section" title="B.1.14&nbsp;The <custom-filter&gt; Element"><div class="titlepage"><div><div><h3 class="title"><a name="d4e3434"></a>B.1.14&nbsp;The <code class="literal">&lt;custom-filter&gt;</code> Element</h3></div></div></div>
      
      <p>This element is used to add a filter to the filter chain. It doesn't create any
        additional beans but is used to select a bean of type
          <code class="interfacename">javax.servlet.Filter</code> which is already defined in the
        appllication context and add that at a particular position in the filter chain maintained by
        Spring Security. Full details can be found in the namespace chapter.</p>
    </div>
  </div>
  <div class="section" title="B.2&nbsp;Authentication Services"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e3439"></a>B.2&nbsp;Authentication Services</h2></div></div></div>
    
    <p> Before Spring Security 3.0, an <code class="interfacename">AuthenticationManager</code> was
      automatically registered internally. Now you must register one explicitly using the
        <code class="literal">&lt;authentication-manager&gt;</code> element. This creates an instance of
      Spring Security's <code class="classname">ProviderManager</code> class, which needs to be configured
      with a list of one or more <code class="interfacename">AuthenticationProvider</code> instances.
      These can either be created using syntax elements provided by the namespace, or they can be
      standard bean definitions, marked for addition to the list using the
        <code class="literal">authentication-provider</code> element. </p>
    <div class="section" title="B.2.1&nbsp;The <authentication-manager&gt; Element"><div class="titlepage"><div><div><h3 class="title"><a name="d4e3447"></a>B.2.1&nbsp;The <code class="literal">&lt;authentication-manager&gt;</code> Element</h3></div></div></div>
      
      <p> Every Spring Security application which uses the namespace must have include this
        element somewhere. It is responsible for registering the
          <code class="interfacename">AuthenticationManager</code> which provides authentication
        services to the application. It also allows you to define an alias name for the internal
        instance for use in your own configuration. Its use is described in the 
          <a class="ulink" href="#ns-auth-manager" target="_top">namespace introduction</a>. All elements which create
          <code class="interfacename">AuthenticationProvider</code> instances should be children of this
          element.</p>
      <p>
          The element also exposes an <code class="literal">erase-credentials</code> attribute which maps
          to the <code class="literal">eraseCredentialsAfterAuthentication</code> property of
          the <code class="classname">ProviderManager</code>. This is discussed in the
          <a class="ulink" href="#core-services-erasing-credentials" target="_top">Core Services</a> chapter.</p>
      <div class="section" title="The <authentication-provider&gt; Element"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3459"></a>The <code class="literal">&lt;authentication-provider&gt;</code> Element</h4></div></div></div>
        
        <p> Unless used with a <code class="literal">ref</code> attribute, this element is shorthand for configuring a
            <a class="ulink" href="#core-services-dao-provider" target="_top"><code class="classname">DaoAuthenticationProvider</code></a>.
            <code class="classname">DaoAuthenticationProvider</code> loads user information from a
            <code class="interfacename">UserDetailsService</code> and compares the username/password
          combination with the values supplied at login. The
            <code class="interfacename">UserDetailsService</code> instance can be defined either by
          using an available namespace element (<code class="literal">jdbc-user-service</code> or by using the
            <code class="literal">user-service-ref</code> attribute to point to a bean defined elsewhere in
          the application context). You can find examples of these variations in the <a class="ulink" href="#ns-auth-providers" target="_top">namespace introduction</a>. </p>
        <div class="section" title="The <password-encoder&gt; Element"><div class="titlepage"><div><div><h5 class="title"><a name="d4e3472"></a>The <code class="literal">&lt;password-encoder&gt;</code> Element</h5></div></div></div>
          
          <p>Authentication providers can optionally be configured to use a password encoder as
            described in the <a class="ulink" href="#ns-password-encoder" target="_top">namespace introduction</a>.
            This will result in the bean being injected with the appropriate
              <code class="interfacename">PasswordEncoder</code> instance, potentially with an
            accompanying <code class="interfacename">SaltSource</code> bean to provide salt values for
            hashing. </p>
        </div>
      </div>
      <div class="section" title="Using <authentication-provider&gt; to refer to an AuthenticationProvider Bean"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3479"></a>Using <code class="literal">&lt;authentication-provider&gt;</code> to refer to an
            <code class="interfacename">AuthenticationProvider</code> Bean</h4></div></div></div>
        
        <p> If you have written your own <code class="interfacename">AuthenticationProvider</code>
          implementation (or want to configure one of Spring Security's own implementations as a
          traditional bean for some reason, then you can use the following syntax to add it to the
          internal <code class="classname">ProviderManager</code>'s list: </p><pre class="programlisting">
  &lt;security:authentication-manager&gt;
    &lt;security:authentication-provider ref="myAuthenticationProvider" /&gt;
  &lt;/security:authentication-manager&gt;
  &lt;bean id="myAuthenticationProvider" class="com.something.MyAuthenticationProvider"/&gt;
  </pre>
      </div>
    </div>
  </div>
  <div class="section" title="B.3&nbsp;Method Security"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e3487"></a>B.3&nbsp;Method Security</h2></div></div></div>
    
    <div class="section" title="B.3.1&nbsp;The <global-method-security&gt; Element"><div class="titlepage"><div><div><h3 class="title"><a name="d4e3489"></a>B.3.1&nbsp;The <code class="literal">&lt;global-method-security&gt;</code> Element</h3></div></div></div>
      
      <p> This element is the primary means of adding support for securing methods on Spring
        Security beans. Methods can be secured by the use of annotations (defined at the interface
        or class level) or by defining a set of pointcuts as child elements, using AspectJ syntax. </p>
      <p> Method security uses the same <code class="interfacename">AccessDecisionManager</code>
        configuration as web security, but this can be overridden as explained above <a class="xref" href="#nsa-access-decision-manager-ref" title="access-decision-manager-ref">the section called &#8220;<code class="literal">access-decision-manager-ref</code>&#8221;</a>, using the same attribute. </p>
      <div class="section" title="The secured-annotations and jsr250-annotations Attributes"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3496"></a>The <code class="literal">secured-annotations</code> and <code class="literal">jsr250-annotations</code>
          Attributes</h4></div></div></div>
        
        <p> Setting these to "true" will enable support for Spring Security's own
            <code class="literal">@Secured</code> annotations and JSR-250 annotations, respectively. They are
          both disabled by default. Use of JSR-250 annotations also adds a
            <code class="classname">Jsr250Voter</code> to the
            <code class="interfacename">AccessDecisionManager</code>, so you need to make sure you do
          this if you are using a custom implementation and want to use these annotations. </p>
      </div>
      <div class="section" title="Securing Methods using <protect-pointcut&gt;"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3504"></a>Securing Methods using <code class="literal">&lt;protect-pointcut&gt;</code></h4></div></div></div>
        
        <p> Rather than defining security attributes on an individual method or class basis using
          the <code class="literal">@Secured</code> annotation, you can define cross-cutting security
          constraints across whole sets of methods and interfaces in your service layer using the
            <code class="literal">&lt;protect-pointcut&gt;</code> element. This has two attributes: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              <p><code class="literal">expression</code> - the pointcut expression</p>
            </li><li class="listitem">
              <p><code class="literal">access</code> - the security attributes which apply</p>
            </li></ul></div><p> You can find an example in the <a class="ulink" href="#ns-protect-pointcut" target="_top">namespace introduction</a>. </p>
      </div>
      <div class="section" title="The <after-invocation-provider&gt; Element"><div class="titlepage"><div><div><h4 class="title"><a name="nsa-custom-after-invocation"></a>The <code class="literal">&lt;after-invocation-provider&gt;</code> Element</h4></div></div></div>
        
        <p> This element can be used to decorate an
            <code class="interfacename">AfterInvocationProvider</code> for use by the security
          interceptor maintained by the <code class="literal">&lt;global-method-security&gt;</code> namespace.
          You can define zero or more of these within the <code class="literal">global-method-security</code>
          element, each with a <code class="literal">ref</code> attribute pointing to an
            <code class="interfacename">AfterInvocationProvider</code> bean instance within your
          application context. </p>
      </div>
    </div>
    <div class="section" title="B.3.2&nbsp;LDAP Namespace Options"><div class="titlepage"><div><div><h3 class="title"><a name="d4e3527"></a>B.3.2&nbsp;LDAP Namespace Options</h3></div></div></div>
      
      <p> LDAP is covered in some details in <a class="ulink" href="#ldap" target="_top">its own chapter</a>. We
        will expand on that here with some explanation of how the namespace options map to Spring
        beans. The LDAP implementation uses Spring LDAP extensively, so some familiarity with that
        project's API may be useful. </p>
      <div class="section" title="Defining the LDAP Server using the <ldap-server&gt; Element"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3531"></a>Defining the LDAP Server using the <code class="literal">&lt;ldap-server&gt;</code>
          Element</h4></div></div></div>
        
        <p> This element sets up a Spring LDAP <code class="interfacename">ContextSource</code> for
          use by the other LDAP beans, defining the location of the LDAP server and other
          information (such as a username and password, if it doesn't allow anonymous access) for
          connecting to it. It can also be used to create an embedded server for testing. Details of
          the syntax for both options are covered in the <a class="ulink" href="#ldap-server" target="_top">LDAP
            chapter</a>. The actual <code class="interfacename">ContextSource</code> implementation
          is <code class="classname">DefaultSpringSecurityContextSource</code> which extends Spring LDAP's
            <code class="classname">LdapContextSource</code> class. The <code class="literal">manager-dn</code> and
            <code class="literal">manager-password</code> attributes map to the latter's
            <code class="literal">userDn</code> and <code class="literal">password</code> properties respectively. </p>
        <p> If you only have one server defined in your application context, the other LDAP
          namespace-defined beans will use it automatically. Otherwise, you can give the element an
          "id" attribute and refer to it from other namespace beans using the
            <code class="literal">server-ref</code> attribute. This is actually the bean Id of the
            <code class="literal">ContextSource</code> instance, if you want to use it in other traditional
          Spring beans. </p>
      </div>
      <div class="section" title="The <ldap-provider&gt; Element"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3547"></a>The <code class="literal">&lt;ldap-provider&gt;</code> Element</h4></div></div></div>
        
        <p> This element is shorthand for the creation of an
            <code class="classname">LdapAuthenticationProvider</code> instance. By default this will be
          configured with a <code class="classname">BindAuthenticator</code> instance and a
            <code class="classname">DefaultAuthoritiesPopulator</code>. As with all namespace authentication
          providers, it must be included as a child of the
            <code class="literal">authentication-provider</code> element.</p>
        <div class="section" title="The user-dn-pattern Attribute"><div class="titlepage"><div><div><h5 class="title"><a name="d4e3555"></a>The <code class="literal">user-dn-pattern</code> Attribute</h5></div></div></div>
          
          <p> If your users are at a fixed location in the directory (i.e. you can work out the
            DN directly from the username without doing a directory search), you can use this
            attribute to map directly to the DN. It maps directly to the
              <code class="literal">userDnPatterns</code> property of
              <code class="classname">AbstractLdapAuthenticator</code>. </p>
        </div>
        <div class="section" title="The user-search-base and user-search-filter Attributes"><div class="titlepage"><div><div><h5 class="title"><a name="d4e3561"></a>The <code class="literal">user-search-base</code> and <code class="literal">user-search-filter</code>
            Attributes</h5></div></div></div>
          
          <p> If you need to perform a search to locate the user in the directory, then you can
            set these attributes to control the search. The <code class="classname">BindAuthenticator</code>
            will be configured with a <code class="classname">FilterBasedLdapUserSearch</code> and the
            attribute values map directly to the first two arguments of that bean's constructor. If
            these attributes aren't set and no <code class="literal">user-dn-pattern</code> has been supplied
            as an alternative, then the default search values of
              <code class="literal">user-search-filter="(uid={0})"</code> and
              <code class="literal">user-search-base=""</code> will be used. </p>
        </div>
        <div class="section" title="group-search-filter, group-search-base, group-role-attribute and role-prefix Attributes"><div class="titlepage"><div><div><h5 class="title"><a name="d4e3571"></a><code class="literal">group-search-filter</code>, <code class="literal">group-search-base</code>,
              <code class="literal">group-role-attribute</code> and <code class="literal">role-prefix</code>
            Attributes</h5></div></div></div>
          
          <p> The value of <code class="literal">group-search-base</code> is mapped to the
              <code class="literal">groupSearchBase</code> constructor argument of
              <code class="classname">DefaultAuthoritiesPopulator</code> and defaults to "ou=groups". The
            default filter value is "(uniqueMember={0})", which assumes that the entry is of type
            "groupOfUniqueNames". <code class="literal">group-role-attribute</code> maps to the
              <code class="literal">groupRoleAttribute</code> attribute and defaults to "cn". Similarly
              <code class="literal">role-prefix</code> maps to <code class="literal">rolePrefix</code> and defaults to
            "ROLE_". </p>
        </div>
        <div class="section" title="The <password-compare&gt; Element"><div class="titlepage"><div><div><h5 class="title"><a name="d4e3585"></a>The <code class="literal">&lt;password-compare&gt;</code> Element</h5></div></div></div>
          
          <p> This is used as child element to <code class="literal">&lt;ldap-provider&gt;</code> and
            switches the authentication strategy from <code class="classname">BindAuthenticator</code> to
              <code class="classname">PasswordComparisonAuthenticator</code>. This can optionally be
            supplied with a <code class="literal">hash</code> attribute or with a child
              <code class="literal">&lt;password-encoder&gt;</code> element to hash the password before
            submitting it to the directory for comparison. </p>
        </div>
      </div>
      <div class="section" title="The <ldap-user-service&gt; Element"><div class="titlepage"><div><div><h4 class="title"><a name="d4e3594"></a>The <code class="literal">&lt;ldap-user-service&gt;</code> Element</h4></div></div></div>
        
        <p> This element configures an LDAP <code class="interfacename">UserDetailsService</code>.
          The class used is <code class="classname">LdapUserDetailsService</code> which is a combination of
          a <code class="classname">FilterBasedLdapUserSearch</code> and a
            <code class="classname">DefaultAuthoritiesPopulator</code>. The attributes it supports have the
          same usage as in <code class="literal">&lt;ldap-provider&gt;</code>. </p>
      </div>
    </div>
  </div>
<div class="footnotes"><br><hr width="100" align="left"><div class="footnote">
        <p><sup>[<a name="ftn.d4e3084" href="#d4e3084" class="para">15</a>] </sup>See the <a class="ulink" href="#ns-web-xml" target="_top"> introductory chapter</a> for how to set up
          the mapping from your <code class="literal">web.xml</code></p>
      </div><div class="footnote">
          <p><sup>[<a name="ftn.d4e3229" href="#d4e3229" class="para">16</a>] </sup>This feature is really just provided for convenience and is not intended for
            production (where a view technology will have been chosen and can be used to render a
            customized login page). The class
              <code class="classname">DefaultLoginPageGeneratingFilter</code> is responsible for rendering
            the login page and will provide login forms for both normal form login and/or OpenID if
            required.</p>
        </div><div class="footnote">
            <p><sup>[<a name="ftn.d4e3318" href="#d4e3318" class="para">17</a>] </sup>This doesn't affect the use of
                <code class="classname">PersistentTokenBasedRememberMeServices</code>, where the tokens are
              stored on the server side.</p>
          </div></div></div>
</div><!--Begin LoopFuse code--><script src="http://loopfuse.net/webrecorder/js/listen.js" type="text/javascript"></script><script type="text/javascript">
_lf_cid = "LF_48be82fa";
_lf_remora();
</script><!--End LoopFuse code--></body></html>